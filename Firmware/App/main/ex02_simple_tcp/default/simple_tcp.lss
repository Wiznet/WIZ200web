
simple_tcp.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000458  00800100  000045fc  00004690  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000045fc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000e2  00800558  00800558  00004ae8  2**0
                  ALLOC
  3 .debug_aranges 00000100  00000000  00000000  00004ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000009ae  00000000  00000000  00004be8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003e22  00000000  00000000  00005596  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000dbe  00000000  00000000  000093b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000296d  00000000  00000000  0000a176  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000a40  00000000  00000000  0000cae4  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000ae4  00000000  00000000  0000d524  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000024b3  00000000  00000000  0000e008  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000108  00000000  00000000  000104bb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 46 00 	jmp	0x8c	; 0x8c <__ctors_end>
       4:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       8:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
       c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      10:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      14:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      18:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      1c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      20:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      24:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      28:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      2c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      30:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      34:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      38:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      3c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      40:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      44:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      48:	0c 94 87 0e 	jmp	0x1d0e	; 0x1d0e <__vector_18>
      4c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      50:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      54:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      58:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      5c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      60:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      64:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      68:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      6c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      70:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      74:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      78:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      7c:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      80:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      84:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>
      88:	0c 94 66 00 	jmp	0xcc	; 0xcc <__bad_interrupt>

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e1       	ldi	r29, 0x10	; 16
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	15 e0       	ldi	r17, 0x05	; 5
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	ec ef       	ldi	r30, 0xFC	; 252
      a0:	f5 e4       	ldi	r31, 0x45	; 69
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	a8 35       	cpi	r26, 0x58	; 88
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>
      b2:	1b be       	out	0x3b, r1	; 59

000000b4 <__do_clear_bss>:
      b4:	16 e0       	ldi	r17, 0x06	; 6
      b6:	a8 e5       	ldi	r26, 0x58	; 88
      b8:	b5 e0       	ldi	r27, 0x05	; 5
      ba:	01 c0       	rjmp	.+2      	; 0xbe <.do_clear_bss_start>

000000bc <.do_clear_bss_loop>:
      bc:	1d 92       	st	X+, r1

000000be <.do_clear_bss_start>:
      be:	aa 33       	cpi	r26, 0x3A	; 58
      c0:	b1 07       	cpc	r27, r17
      c2:	e1 f7       	brne	.-8      	; 0xbc <.do_clear_bss_loop>
      c4:	0e 94 ce 0d 	call	0x1b9c	; 0x1b9c <main>
      c8:	0c 94 fc 22 	jmp	0x45f8	; 0x45f8 <_exit>

000000cc <__bad_interrupt>:
      cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d0 <mcu_init>:



void mcu_init(void) 
{
	cli();
      d0:	f8 94       	cli
		
#ifndef __DEF_IINCHIP_INT__	
	EICRA=0x00;
      d2:	10 92 6a 00 	sts	0x006A, r1
	EICRB=0x00;
      d6:	1a be       	out	0x3a, r1	; 58
	EIMSK=0x00;
      d8:	19 be       	out	0x39, r1	; 57
	EIFR=0x00;
      da:	18 be       	out	0x38, r1	; 56

#if (ATMEGA128_NUM_WAIT == ATMEGA128_0WAIT)
	MCUCR = 0x80;		
	XMCRA=0x40;
#elif (ATMEGA128_NUM_WAIT == ATMEGA128_1WAIT)
	MCUCR = 0xc0;		// MCU control regiseter : enable external ram
      dc:	80 ec       	ldi	r24, 0xC0	; 192
      de:	85 bf       	out	0x35, r24	; 53
	XMCRA=0x40;		// External Memory Control Register A : 
      e0:	80 e4       	ldi	r24, 0x40	; 64
      e2:	80 93 6d 00 	sts	0x006D, r24
	XMCRA=0x42;
#else
#error "unknown atmega128 number wait type"
#endif	

	sei();				// enable interrupts
      e6:	78 94       	sei
}
      e8:	08 95       	ret

000000ea <led_toggle>:
	LED_AVR_PORT_VAL &= ~(1 << (LED_PIN_0+led));	
}

u_char led_state(u_char led)
{
	return ( ( (LED_AVR_PORT_VAL & (1 << (LED_PIN_0+led)))) ? LED_OFF : LED_ON);
      ea:	28 b3       	in	r18, 0x18	; 24
      ec:	48 2f       	mov	r20, r24
      ee:	50 e0       	ldi	r21, 0x00	; 0
      f0:	4c 5f       	subi	r20, 0xFC	; 252
      f2:	5f 4f       	sbci	r21, 0xFF	; 255
      f4:	30 e0       	ldi	r19, 0x00	; 0
      f6:	04 2e       	mov	r0, r20
      f8:	02 c0       	rjmp	.+4      	; 0xfe <led_toggle+0x14>
      fa:	35 95       	asr	r19
      fc:	27 95       	ror	r18
      fe:	0a 94       	dec	r0
     100:	e2 f7       	brpl	.-8      	; 0xfa <led_toggle+0x10>
     102:	20 ff       	sbrs	r18, 0
     104:	0b c0       	rjmp	.+22     	; 0x11c <led_toggle+0x32>

void led_toggle(u_char led)
{
	if(led_state(led)==LED_ON)
		LED_AVR_PORT_VAL &= ~(1 << (LED_PIN_0+led));
	else 	LED_AVR_PORT_VAL |= (1 << (LED_PIN_0+led));
     106:	28 b3       	in	r18, 0x18	; 24
     108:	81 e0       	ldi	r24, 0x01	; 1
     10a:	90 e0       	ldi	r25, 0x00	; 0
     10c:	02 c0       	rjmp	.+4      	; 0x112 <led_toggle+0x28>
     10e:	88 0f       	add	r24, r24
     110:	99 1f       	adc	r25, r25
     112:	4a 95       	dec	r20
     114:	e2 f7       	brpl	.-8      	; 0x10e <led_toggle+0x24>
     116:	28 2b       	or	r18, r24
     118:	28 bb       	out	0x18, r18	; 24
     11a:	08 95       	ret
}

void led_toggle(u_char led)
{
	if(led_state(led)==LED_ON)
		LED_AVR_PORT_VAL &= ~(1 << (LED_PIN_0+led));
     11c:	28 b3       	in	r18, 0x18	; 24
     11e:	81 e0       	ldi	r24, 0x01	; 1
     120:	90 e0       	ldi	r25, 0x00	; 0
     122:	02 c0       	rjmp	.+4      	; 0x128 <led_toggle+0x3e>
     124:	88 0f       	add	r24, r24
     126:	99 1f       	adc	r25, r25
     128:	4a 95       	dec	r20
     12a:	e2 f7       	brpl	.-8      	; 0x124 <led_toggle+0x3a>
     12c:	80 95       	com	r24
     12e:	82 23       	and	r24, r18
     130:	88 bb       	out	0x18, r24	; 24
     132:	08 95       	ret

00000134 <led_off>:
	else 	LED_AVR_PORT_VAL |= (1 << (LED_PIN_0+led));
}

void led_off(u_char led)
{
	LED_AVR_PORT_VAL |= (1 << (LED_PIN_0+led));
     134:	48 b3       	in	r20, 0x18	; 24
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	04 96       	adiw	r24, 0x04	; 4
     13a:	21 e0       	ldi	r18, 0x01	; 1
     13c:	30 e0       	ldi	r19, 0x00	; 0
     13e:	02 c0       	rjmp	.+4      	; 0x144 <led_off+0x10>
     140:	22 0f       	add	r18, r18
     142:	33 1f       	adc	r19, r19
     144:	8a 95       	dec	r24
     146:	e2 f7       	brpl	.-8      	; 0x140 <led_off+0xc>
     148:	42 2b       	or	r20, r18
     14a:	48 bb       	out	0x18, r20	; 24
}
     14c:	08 95       	ret

0000014e <led_on>:

void led_on(u_char led)
{
	LED_AVR_PORT_VAL &= ~(1 << (LED_PIN_0+led));	
     14e:	48 b3       	in	r20, 0x18	; 24
     150:	90 e0       	ldi	r25, 0x00	; 0
     152:	04 96       	adiw	r24, 0x04	; 4
     154:	21 e0       	ldi	r18, 0x01	; 1
     156:	30 e0       	ldi	r19, 0x00	; 0
     158:	02 c0       	rjmp	.+4      	; 0x15e <led_on+0x10>
     15a:	22 0f       	add	r18, r18
     15c:	33 1f       	adc	r19, r19
     15e:	8a 95       	dec	r24
     160:	e2 f7       	brpl	.-8      	; 0x15a <led_on+0xc>
     162:	20 95       	com	r18
     164:	24 23       	and	r18, r20
     166:	28 bb       	out	0x18, r18	; 24
}
     168:	08 95       	ret

0000016a <led_state>:

u_char led_state(u_char led)
{
	return ( ( (LED_AVR_PORT_VAL & (1 << (LED_PIN_0+led)))) ? LED_OFF : LED_ON);
     16a:	28 b3       	in	r18, 0x18	; 24
     16c:	30 e0       	ldi	r19, 0x00	; 0
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	04 96       	adiw	r24, 0x04	; 4
     172:	02 c0       	rjmp	.+4      	; 0x178 <led_state+0xe>
     174:	35 95       	asr	r19
     176:	27 95       	ror	r18
     178:	8a 95       	dec	r24
     17a:	e2 f7       	brpl	.-8      	; 0x174 <led_state+0xa>
     17c:	20 95       	com	r18
}
     17e:	82 2f       	mov	r24, r18
     180:	81 70       	andi	r24, 0x01	; 1
     182:	08 95       	ret

00000184 <sw_init>:
//-----------------------------------------------------------------------------
//EVB Switch Control
void sw_init(void)
{
	//port pull up
	SW_AVR_PORT_VAL |= SW_MASK;
     184:	83 b1       	in	r24, 0x03	; 3
     186:	80 66       	ori	r24, 0x60	; 96
     188:	83 b9       	out	0x03, r24	; 3
	SW_AVR_PORT_DIR &= ~(SW_MASK);
     18a:	82 b1       	in	r24, 0x02	; 2
     18c:	8f 79       	andi	r24, 0x9F	; 159
     18e:	82 b9       	out	0x02, r24	; 2
}
     190:	08 95       	ret

00000192 <sw_state>:

u_char sw_state(unsigned char num)
{
	//SwNum
	unsigned char ret;
	ret = SW_VALUE & (1<<(SW_PIN_0+(num)));
     192:	41 b1       	in	r20, 0x01	; 1
     194:	90 e0       	ldi	r25, 0x00	; 0
     196:	05 96       	adiw	r24, 0x05	; 5
     198:	21 e0       	ldi	r18, 0x01	; 1
     19a:	30 e0       	ldi	r19, 0x00	; 0
     19c:	02 c0       	rjmp	.+4      	; 0x1a2 <sw_state+0x10>
     19e:	22 0f       	add	r18, r18
     1a0:	33 1f       	adc	r19, r19
     1a2:	8a 95       	dec	r24
     1a4:	e2 f7       	brpl	.-8      	; 0x19e <sw_state+0xc>
     1a6:	42 23       	and	r20, r18
     1a8:	09 f0       	breq	.+2      	; 0x1ac <sw_state+0x1a>
     1aa:	41 e0       	ldi	r20, 0x01	; 1
	return ((ret)?1:0);
}
     1ac:	84 2f       	mov	r24, r20
     1ae:	08 95       	ret

000001b0 <evb_get_lcd_text>:
//-----------------------------------------------------------------------------



u_char* evb_get_lcd_text(u_char row)
{
     1b0:	98 2f       	mov	r25, r24
	if(row < LCD_MAX_ROW)
     1b2:	82 30       	cpi	r24, 0x02	; 2
     1b4:	18 f0       	brcs	.+6      	; 0x1bc <evb_get_lcd_text+0xc>
     1b6:	20 e0       	ldi	r18, 0x00	; 0
     1b8:	30 e0       	ldi	r19, 0x00	; 0
     1ba:	06 c0       	rjmp	.+12     	; 0x1c8 <evb_get_lcd_text+0x18>
		return evb_lcd_text[row];
     1bc:	81 e1       	ldi	r24, 0x11	; 17
     1be:	98 9f       	mul	r25, r24
     1c0:	90 01       	movw	r18, r0
     1c2:	11 24       	eor	r1, r1
     1c4:	28 5a       	subi	r18, 0xA8	; 168
     1c6:	3a 4f       	sbci	r19, 0xFA	; 250
	return 0;
	
}
     1c8:	c9 01       	movw	r24, r18
     1ca:	08 95       	ret

000001cc <AdcInit>:
//------------------------------------------------------------------------------
// Function Routine
//ADC Initialize
void AdcInit(void)
{
	ADMUX = 0;
     1cc:	17 b8       	out	0x07, r1	; 7
    ADCSR = ADC_ENABLE | ADC_PRESCALE_DIV32;
     1ce:	85 e8       	ldi	r24, 0x85	; 133
     1d0:	86 b9       	out	0x06, r24	; 6
}
     1d2:	08 95       	ret

000001d4 <AdcRead>:
//Read ADC Value
unsigned int AdcRead(unsigned char port)
{
	unsigned int value = 0;

	ADMUX = port&7;
     1d4:	87 70       	andi	r24, 0x07	; 7
     1d6:	87 b9       	out	0x07, r24	; 7
	ADCSR |= ADC_START_CONVERSION;
     1d8:	36 9a       	sbi	0x06, 6	; 6

	while(!(ADCSR & ADC_COMPLETE));
     1da:	34 9b       	sbis	0x06, 4	; 6
     1dc:	fe cf       	rjmp	.-4      	; 0x1da <AdcRead+0x6>

	value = ADCL;
     1de:	24 b1       	in	r18, 0x04	; 4
     1e0:	30 e0       	ldi	r19, 0x00	; 0
	value = (ADCH<<8) | value;
     1e2:	45 b1       	in	r20, 0x05	; 5
     1e4:	94 2f       	mov	r25, r20
     1e6:	80 e0       	ldi	r24, 0x00	; 0
     1e8:	28 2b       	or	r18, r24
     1ea:	39 2b       	or	r19, r25
	
	return value;
}
     1ec:	c9 01       	movw	r24, r18
     1ee:	08 95       	ret

000001f0 <evb_soft_reset>:


void evb_soft_reset(void)
{
//	set_reset_flag(SYSTEM_AUTO_RESET);
	asm volatile("jmp 0x0000");	
     1f0:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>
}
     1f4:	08 95       	ret

000001f6 <evb_set_lcd_text>:
	return 0;
	
}

void evb_set_lcd_text(u_char row, u_char* lcd)
{
     1f6:	df 92       	push	r13
     1f8:	ef 92       	push	r14
     1fa:	ff 92       	push	r15
     1fc:	0f 93       	push	r16
     1fe:	1f 93       	push	r17
     200:	f8 2e       	mov	r15, r24
     202:	e6 2e       	mov	r14, r22
     204:	d7 2e       	mov	r13, r23
	if(row < LCD_MAX_ROW && strlen((char*)lcd) <= LCD_MAX_COL)
     206:	81 e0       	ldi	r24, 0x01	; 1
     208:	8f 15       	cp	r24, r15
     20a:	d8 f1       	brcs	.+118    	; 0x282 <evb_set_lcd_text+0x8c>
     20c:	a6 2f       	mov	r26, r22
     20e:	b7 2f       	mov	r27, r23
     210:	fd 01       	movw	r30, r26
     212:	01 90       	ld	r0, Z+
     214:	00 20       	and	r0, r0
     216:	e9 f7       	brne	.-6      	; 0x212 <evb_set_lcd_text+0x1c>
     218:	31 97       	sbiw	r30, 0x01	; 1
     21a:	ea 1b       	sub	r30, r26
     21c:	fb 0b       	sbc	r31, r27
     21e:	71 97       	sbiw	r30, 0x11	; 17
     220:	80 f5       	brcc	.+96     	; 0x282 <evb_set_lcd_text+0x8c>
	{
		memset(evb_lcd_text[row],' ',LCD_MAX_COL);
     222:	01 e1       	ldi	r16, 0x11	; 17
     224:	f0 9e       	mul	r15, r16
     226:	80 01       	movw	r16, r0
     228:	11 24       	eor	r1, r1
     22a:	08 5a       	subi	r16, 0xA8	; 168
     22c:	1a 4f       	sbci	r17, 0xFA	; 250
     22e:	c8 01       	movw	r24, r16
     230:	60 e2       	ldi	r22, 0x20	; 32
     232:	70 e0       	ldi	r23, 0x00	; 0
     234:	40 e1       	ldi	r20, 0x10	; 16
     236:	50 e0       	ldi	r21, 0x00	; 0
     238:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <memset>
		evb_lcd_text[row][LCD_MAX_COL] = 0;
     23c:	8f 2d       	mov	r24, r15
     23e:	90 e0       	ldi	r25, 0x00	; 0
     240:	fc 01       	movw	r30, r24
     242:	24 e0       	ldi	r18, 0x04	; 4
     244:	ee 0f       	add	r30, r30
     246:	ff 1f       	adc	r31, r31
     248:	2a 95       	dec	r18
     24a:	e1 f7       	brne	.-8      	; 0x244 <evb_set_lcd_text+0x4e>
     24c:	e8 0f       	add	r30, r24
     24e:	f9 1f       	adc	r31, r25
     250:	e8 5a       	subi	r30, 0xA8	; 168
     252:	fa 4f       	sbci	r31, 0xFA	; 250
     254:	10 8a       	std	Z+16, r1	; 0x10
		memcpy(evb_lcd_text[row],lcd,strlen((char*)lcd));
     256:	ee 2d       	mov	r30, r14
     258:	fd 2d       	mov	r31, r13
     25a:	df 01       	movw	r26, r30
     25c:	0d 90       	ld	r0, X+
     25e:	00 20       	and	r0, r0
     260:	e9 f7       	brne	.-6      	; 0x25c <evb_set_lcd_text+0x66>
     262:	11 97       	sbiw	r26, 0x01	; 1
     264:	ae 1b       	sub	r26, r30
     266:	bf 0b       	sbc	r27, r31
     268:	c8 01       	movw	r24, r16
     26a:	6e 2d       	mov	r22, r14
     26c:	7d 2d       	mov	r23, r13
     26e:	ad 01       	movw	r20, r26
     270:	0e 94 59 1e 	call	0x3cb2	; 0x3cb2 <memcpy>
		lcd_gotoxy(0,row);
     274:	80 e0       	ldi	r24, 0x00	; 0
     276:	6f 2d       	mov	r22, r15
     278:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <lcd_gotoxy>
		lcd_puts((char*)evb_lcd_text[row]);
     27c:	c8 01       	movw	r24, r16
     27e:	0e 94 65 17 	call	0x2eca	; 0x2eca <lcd_puts>
	}
}
     282:	1f 91       	pop	r17
     284:	0f 91       	pop	r16
     286:	ff 90       	pop	r15
     288:	ef 90       	pop	r14
     28a:	df 90       	pop	r13
     28c:	08 95       	ret

0000028e <led_init>:


//-----------------------------------------------------------------------------
//EVB Switch Control
void led_init(void)
{
     28e:	0f 93       	push	r16
     290:	1f 93       	push	r17
     292:	cf 93       	push	r28
     294:	df 93       	push	r29
	u_int i;
	LED_AVR_PORT_DIR |= (1<<LED_PIN_0) | (1<<LED_PIN_1) | (1<<LED_PIN_2) | (1<<LED_PIN_3);
     296:	87 b3       	in	r24, 0x17	; 23
     298:	80 6f       	ori	r24, 0xF0	; 240
     29a:	87 bb       	out	0x17, r24	; 23
     29c:	c4 e0       	ldi	r28, 0x04	; 4
     29e:	d0 e0       	ldi	r29, 0x00	; 0
	LED_AVR_PORT_VAL |= (1 << (LED_PIN_0+led));
}

void led_on(u_char led)
{
	LED_AVR_PORT_VAL &= ~(1 << (LED_PIN_0+led));	
     2a0:	01 e0       	ldi	r16, 0x01	; 1
     2a2:	10 e0       	ldi	r17, 0x00	; 0
	else 	LED_AVR_PORT_VAL |= (1 << (LED_PIN_0+led));
}

void led_off(u_char led)
{
	LED_AVR_PORT_VAL |= (1 << (LED_PIN_0+led));
     2a4:	c4 9a       	sbi	0x18, 4	; 24
}

void led_on(u_char led)
{
	LED_AVR_PORT_VAL &= ~(1 << (LED_PIN_0+led));	
     2a6:	c5 9a       	sbi	0x18, 5	; 24
     2a8:	c6 9a       	sbi	0x18, 6	; 24
     2aa:	c7 9a       	sbi	0x18, 7	; 24
     2ac:	28 b3       	in	r18, 0x18	; 24
     2ae:	c8 01       	movw	r24, r16
     2b0:	0c 2e       	mov	r0, r28
     2b2:	02 c0       	rjmp	.+4      	; 0x2b8 <led_init+0x2a>
     2b4:	88 0f       	add	r24, r24
     2b6:	99 1f       	adc	r25, r25
     2b8:	0a 94       	dec	r0
     2ba:	e2 f7       	brpl	.-8      	; 0x2b4 <led_init+0x26>
     2bc:	80 95       	com	r24
     2be:	82 23       	and	r24, r18
     2c0:	88 bb       	out	0x18, r24	; 24
	
	for(i = 0; i < 4; i++)
	{
		led_off_all();
		led_on(i);
		wait_10ms(40);
     2c2:	88 e2       	ldi	r24, 0x28	; 40
     2c4:	90 e0       	ldi	r25, 0x00	; 0
     2c6:	0e 94 79 0e 	call	0x1cf2	; 0x1cf2 <wait_10ms>
     2ca:	21 96       	adiw	r28, 0x01	; 1
void led_init(void)
{
	u_int i;
	LED_AVR_PORT_DIR |= (1<<LED_PIN_0) | (1<<LED_PIN_1) | (1<<LED_PIN_2) | (1<<LED_PIN_3);
	
	for(i = 0; i < 4; i++)
     2cc:	c8 30       	cpi	r28, 0x08	; 8
     2ce:	d1 05       	cpc	r29, r1
     2d0:	49 f7       	brne	.-46     	; 0x2a4 <led_init+0x16>
	else 	LED_AVR_PORT_VAL |= (1 << (LED_PIN_0+led));
}

void led_off(u_char led)
{
	LED_AVR_PORT_VAL |= (1 << (LED_PIN_0+led));
     2d2:	c4 9a       	sbi	0x18, 4	; 24
		led_on(i);
		wait_10ms(40);
	}
	
	led_off_all();
}
     2d4:	c5 9a       	sbi	0x18, 5	; 24
     2d6:	c6 9a       	sbi	0x18, 6	; 24
     2d8:	c7 9a       	sbi	0x18, 7	; 24
     2da:	df 91       	pop	r29
     2dc:	cf 91       	pop	r28
     2de:	1f 91       	pop	r17
     2e0:	0f 91       	pop	r16
     2e2:	08 95       	ret

000002e4 <evb_init>:
//------------------------------------------------------------------------------
// Function Routine
//ADC Initialize
void AdcInit(void)
{
	ADMUX = 0;
     2e4:	17 b8       	out	0x07, r1	; 7
    ADCSR = ADC_ENABLE | ADC_PRESCALE_DIV32;
     2e6:	85 e8       	ldi	r24, 0x85	; 133
     2e8:	86 b9       	out	0x06, r24	; 6



void mcu_init(void) 
{
	cli();
     2ea:	f8 94       	cli
		
#ifndef __DEF_IINCHIP_INT__	
	EICRA=0x00;
     2ec:	10 92 6a 00 	sts	0x006A, r1
	EICRB=0x00;
     2f0:	1a be       	out	0x3a, r1	; 58
	EIMSK=0x00;
     2f2:	19 be       	out	0x39, r1	; 57
	EIFR=0x00;
     2f4:	18 be       	out	0x38, r1	; 56

#if (ATMEGA128_NUM_WAIT == ATMEGA128_0WAIT)
	MCUCR = 0x80;		
	XMCRA=0x40;
#elif (ATMEGA128_NUM_WAIT == ATMEGA128_1WAIT)
	MCUCR = 0xc0;		// MCU control regiseter : enable external ram
     2f6:	80 ec       	ldi	r24, 0xC0	; 192
     2f8:	85 bf       	out	0x35, r24	; 53
	XMCRA=0x40;		// External Memory Control Register A : 
     2fa:	80 e4       	ldi	r24, 0x40	; 64
     2fc:	80 93 6d 00 	sts	0x006D, r24
	XMCRA=0x42;
#else
#error "unknown atmega128 number wait type"
#endif	

	sei();				// enable interrupts
     300:	78 94       	sei
void evb_init(void)
{
	AdcInit();
	mcu_init();	

	lcd_init();	
     302:	0e 94 ff 16 	call	0x2dfe	; 0x2dfe <lcd_init>
						//0123456789abcdef 	
	evb_set_lcd_text(0,"WebSerberAK v1.1");
     306:	80 e0       	ldi	r24, 0x00	; 0
     308:	90 e0       	ldi	r25, 0x00	; 0
     30a:	60 e0       	ldi	r22, 0x00	; 0
     30c:	71 e0       	ldi	r23, 0x01	; 1
     30e:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <evb_set_lcd_text>
	evb_set_lcd_text(1,"Initialize...   ");	
     312:	81 e0       	ldi	r24, 0x01	; 1
     314:	90 e0       	ldi	r25, 0x00	; 0
     316:	61 e1       	ldi	r22, 0x11	; 17
     318:	71 e0       	ldi	r23, 0x01	; 1
     31a:	0e 94 fb 00 	call	0x1f6	; 0x1f6 <evb_set_lcd_text>
	
	uart_init(0, 7);		// Serial Port Initialize
     31e:	80 e0       	ldi	r24, 0x00	; 0
     320:	67 e0       	ldi	r22, 0x07	; 7
     322:	0e 94 94 10 	call	0x2128	; 0x2128 <uart_init>
//-----------------------------------------------------------------------------
//EVB Switch Control
void sw_init(void)
{
	//port pull up
	SW_AVR_PORT_VAL |= SW_MASK;
     326:	83 b1       	in	r24, 0x03	; 3
     328:	80 66       	ori	r24, 0x60	; 96
     32a:	83 b9       	out	0x03, r24	; 3
	SW_AVR_PORT_DIR &= ~(SW_MASK);
     32c:	82 b1       	in	r24, 0x02	; 2
     32e:	8f 79       	andi	r24, 0x9F	; 159
     330:	82 b9       	out	0x02, r24	; 2
	
	uart_init(0, 7);		// Serial Port Initialize

	sw_init();

	led_init();
     332:	0e 94 47 01 	call	0x28e	; 0x28e <led_init>
}
     336:	08 95       	ret

00000338 <disconnect>:
void disconnect(SOCKET s)
{
#ifdef __DEF_IINCHIP_DBG__
	printf("disconnect()\r\n");
#endif
	IINCHIP_WRITE(Sn_CR(s), Sn_CR_DISCON);
     338:	90 e0       	ldi	r25, 0x00	; 0
     33a:	26 e0       	ldi	r18, 0x06	; 6
     33c:	88 0f       	add	r24, r24
     33e:	99 1f       	adc	r25, r25
     340:	2a 95       	dec	r18
     342:	e1 f7       	brne	.-8      	; 0x33c <disconnect+0x4>
     344:	8d 5f       	subi	r24, 0xFD	; 253
     346:	9d 47       	sbci	r25, 0x7D	; 125
     348:	68 e0       	ldi	r22, 0x08	; 8
     34a:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
}
     34e:	08 95       	ret

00000350 <connect>:
This function return 1 for success else 0.
*********************************************************************
*/

uint8    connect(SOCKET s, uint8 * addr, uint16 port)
{
     350:	cf 92       	push	r12
     352:	df 92       	push	r13
     354:	ef 92       	push	r14
     356:	ff 92       	push	r15
     358:	0f 93       	push	r16
     35a:	1f 93       	push	r17
     35c:	cf 93       	push	r28
     35e:	df 93       	push	r29
     360:	e8 2e       	mov	r14, r24
     362:	eb 01       	movw	r28, r22
     364:	6a 01       	movw	r12, r20
   if
   (
     366:	68 81       	ld	r22, Y
     368:	6f 3f       	cpi	r22, 0xFF	; 255
     36a:	51 f4       	brne	.+20     	; 0x380 <connect+0x30>
     36c:	89 81       	ldd	r24, Y+1	; 0x01
     36e:	8f 3f       	cpi	r24, 0xFF	; 255
     370:	91 f4       	brne	.+36     	; 0x396 <connect+0x46>
     372:	8a 81       	ldd	r24, Y+2	; 0x02
     374:	8f 3f       	cpi	r24, 0xFF	; 255
     376:	79 f4       	brne	.+30     	; 0x396 <connect+0x46>
     378:	8b 81       	ldd	r24, Y+3	; 0x03
     37a:	8f 3f       	cpi	r24, 0xFF	; 255
     37c:	61 f4       	brne	.+24     	; 0x396 <connect+0x46>
     37e:	3d c0       	rjmp	.+122    	; 0x3fa <connect+0xaa>
     380:	66 23       	and	r22, r22
     382:	49 f4       	brne	.+18     	; 0x396 <connect+0x46>
     384:	89 81       	ldd	r24, Y+1	; 0x01
     386:	88 23       	and	r24, r24
     388:	31 f4       	brne	.+12     	; 0x396 <connect+0x46>
     38a:	8a 81       	ldd	r24, Y+2	; 0x02
     38c:	88 23       	and	r24, r24
     38e:	19 f4       	brne	.+6      	; 0x396 <connect+0x46>
     390:	8b 81       	ldd	r24, Y+3	; 0x03
     392:	88 23       	and	r24, r24
     394:	91 f1       	breq	.+100    	; 0x3fa <connect+0xaa>
     396:	c1 14       	cp	r12, r1
     398:	d1 04       	cpc	r13, r1
     39a:	79 f1       	breq	.+94     	; 0x3fa <connect+0xaa>
      #endif
      return 0;
   }
   
		// set destination IP
		IINCHIP_WRITE(Sn_DIPR(s), addr[0]);
     39c:	ff 24       	eor	r15, r15
     39e:	88 e0       	ldi	r24, 0x08	; 8
     3a0:	92 e0       	ldi	r25, 0x02	; 2
     3a2:	e8 0e       	add	r14, r24
     3a4:	f9 1e       	adc	r15, r25
     3a6:	87 01       	movw	r16, r14
     3a8:	36 e0       	ldi	r19, 0x06	; 6
     3aa:	00 0f       	add	r16, r16
     3ac:	11 1f       	adc	r17, r17
     3ae:	3a 95       	dec	r19
     3b0:	e1 f7       	brne	.-8      	; 0x3aa <connect+0x5a>
     3b2:	c8 01       	movw	r24, r16
     3b4:	44 96       	adiw	r24, 0x14	; 20
     3b6:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR1(s), addr[1]);
     3ba:	c8 01       	movw	r24, r16
     3bc:	45 96       	adiw	r24, 0x15	; 21
     3be:	69 81       	ldd	r22, Y+1	; 0x01
     3c0:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR2(s), addr[2]);
     3c4:	c8 01       	movw	r24, r16
     3c6:	46 96       	adiw	r24, 0x16	; 22
     3c8:	6a 81       	ldd	r22, Y+2	; 0x02
     3ca:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR3(s), addr[3]);
     3ce:	c8 01       	movw	r24, r16
     3d0:	47 96       	adiw	r24, 0x17	; 23
     3d2:	6b 81       	ldd	r22, Y+3	; 0x03
     3d4:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
	
		// set destination PORT
		IINCHIP_WRITE(Sn_DPORTR(s), port >> 8);
     3d8:	c8 01       	movw	r24, r16
     3da:	42 96       	adiw	r24, 0x12	; 18
     3dc:	6d 2d       	mov	r22, r13
     3de:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DPORTR1(s), port & 0xff);
     3e2:	c8 01       	movw	r24, r16
     3e4:	43 96       	adiw	r24, 0x13	; 19
     3e6:	6c 2d       	mov	r22, r12
     3e8:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>

		// Connect
		IINCHIP_WRITE(Sn_CR(s), Sn_CR_CONNECT);
     3ec:	c8 01       	movw	r24, r16
     3ee:	03 96       	adiw	r24, 0x03	; 3
     3f0:	64 e0       	ldi	r22, 0x04	; 4
     3f2:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
     3f6:	81 e0       	ldi	r24, 0x01	; 1
     3f8:	01 c0       	rjmp	.+2      	; 0x3fc <connect+0xac>

   return 1;   
     3fa:	80 e0       	ldi	r24, 0x00	; 0
}
     3fc:	df 91       	pop	r29
     3fe:	cf 91       	pop	r28
     400:	1f 91       	pop	r17
     402:	0f 91       	pop	r16
     404:	ff 90       	pop	r15
     406:	ef 90       	pop	r14
     408:	df 90       	pop	r13
     40a:	cf 90       	pop	r12
     40c:	08 95       	ret

0000040e <close>:
void close(SOCKET s)
{
#ifdef __DEF_IINCHIP_DBG__
	printf("close()\r\n");
#endif
	IINCHIP_WRITE(Sn_CR(s), Sn_CR_CLOSE);
     40e:	90 e0       	ldi	r25, 0x00	; 0
     410:	46 e0       	ldi	r20, 0x06	; 6
     412:	88 0f       	add	r24, r24
     414:	99 1f       	adc	r25, r25
     416:	4a 95       	dec	r20
     418:	e1 f7       	brne	.-8      	; 0x412 <close+0x4>
     41a:	8d 5f       	subi	r24, 0xFD	; 253
     41c:	9d 47       	sbci	r25, 0x7D	; 125
     41e:	60 e1       	ldi	r22, 0x10	; 16
     420:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
}
     424:	08 95       	ret

00000426 <socket>:
This function return 1 for sucess else 0.
*********************************************************************
*/

uint8 socket(SOCKET s, uint8 protocol, uint16 port, uint16 flag)
{
     426:	bf 92       	push	r11
     428:	cf 92       	push	r12
     42a:	df 92       	push	r13
     42c:	ef 92       	push	r14
     42e:	ff 92       	push	r15
     430:	0f 93       	push	r16
     432:	1f 93       	push	r17
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	b8 2e       	mov	r11, r24
     43a:	d6 2e       	mov	r13, r22
     43c:	7a 01       	movw	r14, r20
     43e:	c2 2e       	mov	r12, r18
	uint8 ret;
#ifdef __DEF_IINCHIP_DBG__
	printf("socket()\r\n");
#endif
	if ((protocol == Sn_MR_TCP) || (protocol == Sn_MR_UDP) || (protocol == Sn_MR_IPRAW) || (protocol == Sn_MR_MACRAW))
     440:	86 2f       	mov	r24, r22
     442:	81 50       	subi	r24, 0x01	; 1
     444:	84 30       	cpi	r24, 0x04	; 4
     446:	10 f0       	brcs	.+4      	; 0x44c <socket+0x26>
     448:	80 e0       	ldi	r24, 0x00	; 0
     44a:	42 c0       	rjmp	.+132    	; 0x4d0 <socket+0xaa>
	{
		close(s);
     44c:	8b 2d       	mov	r24, r11
     44e:	0e 94 07 02 	call	0x40e	; 0x40e <close>
		IINCHIP_WRITE(Sn_MR(s), protocol | flag );
     452:	cb 2d       	mov	r28, r11
     454:	d0 e0       	ldi	r29, 0x00	; 0
     456:	c8 5f       	subi	r28, 0xF8	; 248
     458:	dd 4f       	sbci	r29, 0xFD	; 253
     45a:	8e 01       	movw	r16, r28
     45c:	66 e0       	ldi	r22, 0x06	; 6
     45e:	00 0f       	add	r16, r16
     460:	11 1f       	adc	r17, r17
     462:	6a 95       	dec	r22
     464:	e1 f7       	brne	.-8      	; 0x45e <socket+0x38>
     466:	dc 28       	or	r13, r12
     468:	c8 01       	movw	r24, r16
     46a:	01 96       	adiw	r24, 0x01	; 1
     46c:	6d 2d       	mov	r22, r13
     46e:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
     472:	c8 01       	movw	r24, r16
     474:	0a 96       	adiw	r24, 0x0a	; 10
     476:	05 5f       	subi	r16, 0xF5	; 245
     478:	1f 4f       	sbci	r17, 0xFF	; 255
#ifdef __DEF_IINCHIP_DBG__
		printf("Sn_MR(%d) = 0x%02x\r\n", s, IINCHIP_READ(Sn_MR(s)));
#endif
		if (port != 0) {
     47a:	e1 14       	cp	r14, r1
     47c:	f1 04       	cpc	r15, r1
     47e:	31 f0       	breq	.+12     	; 0x48c <socket+0x66>
			IINCHIP_WRITE(Sn_PORTR(s),(uint8)((port & 0xff00) >> 8));
     480:	6f 2d       	mov	r22, r15
     482:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
			IINCHIP_WRITE((Sn_PORTR(s) + 1),(uint8)(port & 0x00ff));
     486:	c8 01       	movw	r24, r16
     488:	6e 2d       	mov	r22, r14
     48a:	10 c0       	rjmp	.+32     	; 0x4ac <socket+0x86>
		} else {
			local_port++; // if don't set the source port, set local_port number.
     48c:	20 91 e6 05 	lds	r18, 0x05E6
     490:	30 91 e7 05 	lds	r19, 0x05E7
     494:	2f 5f       	subi	r18, 0xFF	; 255
     496:	3f 4f       	sbci	r19, 0xFF	; 255
     498:	30 93 e7 05 	sts	0x05E7, r19
     49c:	20 93 e6 05 	sts	0x05E6, r18
			IINCHIP_WRITE(Sn_PORTR(s),(uint8)((local_port & 0xff00) >> 8));
     4a0:	63 2f       	mov	r22, r19
     4a2:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
			IINCHIP_WRITE((Sn_PORTR(s) + 1),(uint8)(local_port & 0x00ff));
     4a6:	c8 01       	movw	r24, r16
     4a8:	60 91 e6 05 	lds	r22, 0x05E6
     4ac:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		}
		IINCHIP_WRITE(Sn_CR(s), Sn_CR_OPEN); // run sockinit Sn_CR
     4b0:	56 e0       	ldi	r21, 0x06	; 6
     4b2:	cc 0f       	add	r28, r28
     4b4:	dd 1f       	adc	r29, r29
     4b6:	5a 95       	dec	r21
     4b8:	e1 f7       	brne	.-8      	; 0x4b2 <socket+0x8c>
     4ba:	ce 01       	movw	r24, r28
     4bc:	03 96       	adiw	r24, 0x03	; 3
     4be:	61 e0       	ldi	r22, 0x01	; 1
     4c0:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		ret = 1;
		first_send_flag[s] = 1;
     4c4:	eb 2d       	mov	r30, r11
     4c6:	f0 e0       	ldi	r31, 0x00	; 0
     4c8:	e2 52       	subi	r30, 0x22	; 34
     4ca:	fa 4f       	sbci	r31, 0xFA	; 250
     4cc:	81 e0       	ldi	r24, 0x01	; 1
     4ce:	80 83       	st	Z, r24
	}
#ifdef __DEF_IINCHIP_DBG__
	printf("Sn_SSR = 0x%02x , Protocol = 0x%02x\r\n", getSn_SSR(s), IINCHIP_READ(Sn_MR(s)));
#endif
	return ret;
}
     4d0:	df 91       	pop	r29
     4d2:	cf 91       	pop	r28
     4d4:	1f 91       	pop	r17
     4d6:	0f 91       	pop	r16
     4d8:	ff 90       	pop	r15
     4da:	ef 90       	pop	r14
     4dc:	df 90       	pop	r13
     4de:	cf 90       	pop	r12
     4e0:	bf 90       	pop	r11
     4e2:	08 95       	ret

000004e4 <igmpsend>:
#endif
	return data_len;
}

uint16 igmpsend(SOCKET s, uint8 * buf, uint16 len)
{
     4e4:	ff 92       	push	r15
     4e6:	0f 93       	push	r16
     4e8:	1f 93       	push	r17
     4ea:	cf 93       	push	r28
     4ec:	df 93       	push	r29
     4ee:	f8 2e       	mov	r15, r24
     4f0:	8b 01       	movw	r16, r22
     4f2:	ea 01       	movw	r28, r20
	uint16 ret=0;
	
#ifdef __DEF_IINCHIP_DBG__
	printf("igmpsend()\r\n");
#endif
   if (len > getIINCHIP_TxMAX(s)) ret = getIINCHIP_TxMAX(s); // check size not to exceed MAX size.
     4f4:	0e 94 b4 0a 	call	0x1568	; 0x1568 <getIINCHIP_TxMAX>
     4f8:	9e 01       	movw	r18, r28
     4fa:	40 e0       	ldi	r20, 0x00	; 0
     4fc:	50 e0       	ldi	r21, 0x00	; 0
     4fe:	62 17       	cp	r22, r18
     500:	73 07       	cpc	r23, r19
     502:	84 07       	cpc	r24, r20
     504:	95 07       	cpc	r25, r21
     506:	20 f4       	brcc	.+8      	; 0x510 <igmpsend+0x2c>
     508:	8f 2d       	mov	r24, r15
     50a:	0e 94 b4 0a 	call	0x1568	; 0x1568 <getIINCHIP_TxMAX>
     50e:	eb 01       	movw	r28, r22
   else ret = len;

	if	(ret == 0) 
     510:	20 97       	sbiw	r28, 0x00	; 0
     512:	91 f1       	breq	.+100    	; 0x578 <igmpsend+0x94>
#endif
	}
	else
	{
		// copy data
      setSn_TX_WRSR(s,ret);
     514:	ae 01       	movw	r20, r28
     516:	60 e0       	ldi	r22, 0x00	; 0
     518:	70 e0       	ldi	r23, 0x00	; 0
     51a:	8f 2d       	mov	r24, r15
     51c:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <setSn_TX_WRSR>
	  
      wiz_write_buf(s, buf, ret+(ret & 0x01));	  
     520:	9e 01       	movw	r18, r28
     522:	21 70       	andi	r18, 0x01	; 1
     524:	30 70       	andi	r19, 0x00	; 0
     526:	2c 0f       	add	r18, r28
     528:	3d 1f       	adc	r19, r29
     52a:	40 e0       	ldi	r20, 0x00	; 0
     52c:	50 e0       	ldi	r21, 0x00	; 0
     52e:	8f 2d       	mov	r24, r15
     530:	b8 01       	movw	r22, r16
     532:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <wiz_write_buf>
	  
  	   IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
     536:	8f 2d       	mov	r24, r15
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	76 e0       	ldi	r23, 0x06	; 6
     53c:	88 0f       	add	r24, r24
     53e:	99 1f       	adc	r25, r25
     540:	7a 95       	dec	r23
     542:	e1 f7       	brne	.-8      	; 0x53c <igmpsend+0x58>
     544:	8d 5f       	subi	r24, 0xFD	; 253
     546:	9d 47       	sbci	r25, 0x7D	; 125
     548:	60 e2       	ldi	r22, 0x20	; 32
     54a:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
     54e:	07 c0       	rjmp	.+14     	; 0x55e <igmpsend+0x7a>
      while (!((isr=getSn_IR(s)) & Sn_IR_SENDOK))
      {
      	status = getSn_SSR(s);
     550:	8f 2d       	mov	r24, r15
     552:	0e 94 8f 07 	call	0xf1e	; 0xf1e <getSn_SSR>
			  if ((status == SOCK_CLOSED) || (isr & Sn_IR_TIMEOUT))
     556:	88 23       	and	r24, r24
     558:	49 f0       	breq	.+18     	; 0x56c <igmpsend+0x88>
     55a:	03 fd       	sbrc	r16, 3
     55c:	07 c0       	rjmp	.+14     	; 0x56c <igmpsend+0x88>
      setSn_TX_WRSR(s,ret);
	  
      wiz_write_buf(s, buf, ret+(ret & 0x01));	  
	  
  	   IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
      while (!((isr=getSn_IR(s)) & Sn_IR_SENDOK))
     55e:	8f 2d       	mov	r24, r15
     560:	0e 94 79 07 	call	0xef2	; 0xef2 <getSn_IR>
     564:	08 2f       	mov	r16, r24
     566:	84 ff       	sbrs	r24, 4
     568:	f3 cf       	rjmp	.-26     	; 0x550 <igmpsend+0x6c>
     56a:	02 c0       	rjmp	.+4      	; 0x570 <igmpsend+0x8c>
     56c:	c0 e0       	ldi	r28, 0x00	; 0
     56e:	d0 e0       	ldi	r29, 0x00	; 0
			    printf("igmpsend fail.\r\n");
          #endif
				  ret = 0; break;
			    }
		  }
		setSn_IR(s, Sn_IR_SENDOK);
     570:	8f 2d       	mov	r24, r15
     572:	60 e1       	ldi	r22, 0x10	; 16
     574:	0e 94 84 07 	call	0xf08	; 0xf08 <setSn_IR>
	  
	}
	return ret;
}
     578:	ce 01       	movw	r24, r28
     57a:	df 91       	pop	r29
     57c:	cf 91       	pop	r28
     57e:	1f 91       	pop	r17
     580:	0f 91       	pop	r16
     582:	ff 90       	pop	r15
     584:	08 95       	ret

00000586 <sendto>:
and "len" is the data size to send and addr is the peer's Destination IP address and port is
the peer's destination port number. This function return send data size for success else -1.
*********************************************************************
*/
uint16 sendto(SOCKET s, uint8 * buf, uint16 len, uint8 * addr, uint16 port)
{
     586:	6f 92       	push	r6
     588:	7f 92       	push	r7
     58a:	8f 92       	push	r8
     58c:	9f 92       	push	r9
     58e:	bf 92       	push	r11
     590:	cf 92       	push	r12
     592:	df 92       	push	r13
     594:	ef 92       	push	r14
     596:	ff 92       	push	r15
     598:	0f 93       	push	r16
     59a:	1f 93       	push	r17
     59c:	cf 93       	push	r28
     59e:	df 93       	push	r29
     5a0:	b8 2e       	mov	r11, r24
     5a2:	3b 01       	movw	r6, r22
     5a4:	6a 01       	movw	r12, r20
     5a6:	e9 01       	movw	r28, r18
     5a8:	48 01       	movw	r8, r16
	uint16 ret=0;

#ifdef __DEF_IINCHIP_DBG__
//	printf("sendto()\r\n");
#endif
	if (len > getIINCHIP_TxMAX(s)) ret = getIINCHIP_TxMAX(s); // check size not to exceed MAX size.
     5aa:	0e 94 b4 0a 	call	0x1568	; 0x1568 <getIINCHIP_TxMAX>
     5ae:	96 01       	movw	r18, r12
     5b0:	40 e0       	ldi	r20, 0x00	; 0
     5b2:	50 e0       	ldi	r21, 0x00	; 0
     5b4:	62 17       	cp	r22, r18
     5b6:	73 07       	cpc	r23, r19
     5b8:	84 07       	cpc	r24, r20
     5ba:	95 07       	cpc	r25, r21
     5bc:	20 f4       	brcc	.+8      	; 0x5c6 <sendto+0x40>
     5be:	8b 2d       	mov	r24, r11
     5c0:	0e 94 b4 0a 	call	0x1568	; 0x1568 <getIINCHIP_TxMAX>
     5c4:	6b 01       	movw	r12, r22
	else ret = len;

	if
		(
     5c6:	68 81       	ld	r22, Y
     5c8:	66 23       	and	r22, r22
     5ca:	51 f4       	brne	.+20     	; 0x5e0 <sendto+0x5a>
     5cc:	89 81       	ldd	r24, Y+1	; 0x01
     5ce:	88 23       	and	r24, r24
     5d0:	39 f4       	brne	.+14     	; 0x5e0 <sendto+0x5a>
     5d2:	8a 81       	ldd	r24, Y+2	; 0x02
     5d4:	88 23       	and	r24, r24
     5d6:	21 f4       	brne	.+8      	; 0x5e0 <sendto+0x5a>
     5d8:	8b 81       	ldd	r24, Y+3	; 0x03
     5da:	88 23       	and	r24, r24
     5dc:	09 f4       	brne	.+2      	; 0x5e0 <sendto+0x5a>
     5de:	5c c0       	rjmp	.+184    	; 0x698 <sendto+0x112>
     5e0:	81 14       	cp	r8, r1
     5e2:	91 04       	cpc	r9, r1
     5e4:	09 f4       	brne	.+2      	; 0x5e8 <sendto+0x62>
     5e6:	58 c0       	rjmp	.+176    	; 0x698 <sendto+0x112>
     5e8:	c1 14       	cp	r12, r1
     5ea:	d1 04       	cpc	r13, r1
     5ec:	09 f4       	brne	.+2      	; 0x5f0 <sendto+0x6a>
     5ee:	54 c0       	rjmp	.+168    	; 0x698 <sendto+0x112>
	printf("Fail[invalid ip,port]\r\n");
#endif
	}
	else
	{
		IINCHIP_WRITE(Sn_DIPR(s), addr[0]);
     5f0:	eb 2c       	mov	r14, r11
     5f2:	ff 24       	eor	r15, r15
     5f4:	88 e0       	ldi	r24, 0x08	; 8
     5f6:	92 e0       	ldi	r25, 0x02	; 2
     5f8:	e8 0e       	add	r14, r24
     5fa:	f9 1e       	adc	r15, r25
     5fc:	87 01       	movw	r16, r14
     5fe:	e6 e0       	ldi	r30, 0x06	; 6
     600:	00 0f       	add	r16, r16
     602:	11 1f       	adc	r17, r17
     604:	ea 95       	dec	r30
     606:	e1 f7       	brne	.-8      	; 0x600 <sendto+0x7a>
     608:	c8 01       	movw	r24, r16
     60a:	44 96       	adiw	r24, 0x14	; 20
     60c:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR1(s), addr[1]);
     610:	c8 01       	movw	r24, r16
     612:	45 96       	adiw	r24, 0x15	; 21
     614:	69 81       	ldd	r22, Y+1	; 0x01
     616:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR2(s), addr[2]);
     61a:	c8 01       	movw	r24, r16
     61c:	46 96       	adiw	r24, 0x16	; 22
     61e:	6a 81       	ldd	r22, Y+2	; 0x02
     620:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR3(s), addr[3]);
     624:	c8 01       	movw	r24, r16
     626:	47 96       	adiw	r24, 0x17	; 23
     628:	6b 81       	ldd	r22, Y+3	; 0x03
     62a:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>

		IINCHIP_WRITE(Sn_DPORTR(s), port >> 8);
     62e:	c8 01       	movw	r24, r16
     630:	42 96       	adiw	r24, 0x12	; 18
     632:	69 2d       	mov	r22, r9
     634:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DPORTR1(s), port & 0xff);
     638:	c8 01       	movw	r24, r16
     63a:	43 96       	adiw	r24, 0x13	; 19
     63c:	68 2d       	mov	r22, r8
     63e:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>

		// copy data
		setSn_TX_WRSR(s, ret);
     642:	a6 01       	movw	r20, r12
     644:	60 e0       	ldi	r22, 0x00	; 0
     646:	70 e0       	ldi	r23, 0x00	; 0
     648:	8b 2d       	mov	r24, r11
     64a:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <setSn_TX_WRSR>

		wiz_write_buf(s, buf, ret+(ret & 0x01)); 
     64e:	96 01       	movw	r18, r12
     650:	21 70       	andi	r18, 0x01	; 1
     652:	30 70       	andi	r19, 0x00	; 0
     654:	2c 0d       	add	r18, r12
     656:	3d 1d       	adc	r19, r13
     658:	40 e0       	ldi	r20, 0x00	; 0
     65a:	50 e0       	ldi	r21, 0x00	; 0
     65c:	8b 2d       	mov	r24, r11
     65e:	b3 01       	movw	r22, r6
     660:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <wiz_write_buf>
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
     664:	c8 01       	movw	r24, r16
     666:	03 96       	adiw	r24, 0x03	; 3
     668:	60 e2       	ldi	r22, 0x20	; 32
     66a:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
     66e:	07 c0       	rjmp	.+14     	; 0x67e <sendto+0xf8>
		while (!((isr = getSn_IR(s)) & Sn_IR_SENDOK))
		{
			status = getSn_SSR(s);
     670:	8b 2d       	mov	r24, r11
     672:	0e 94 8f 07 	call	0xf1e	; 0xf1e <getSn_SSR>

			if ((status == SOCK_CLOSED) || (isr & Sn_IR_TIMEOUT))
     676:	88 23       	and	r24, r24
     678:	49 f0       	breq	.+18     	; 0x68c <sendto+0x106>
     67a:	c3 fd       	sbrc	r28, 3
     67c:	07 c0       	rjmp	.+14     	; 0x68c <sendto+0x106>
		// copy data
		setSn_TX_WRSR(s, ret);

		wiz_write_buf(s, buf, ret+(ret & 0x01)); 
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
		while (!((isr = getSn_IR(s)) & Sn_IR_SENDOK))
     67e:	8b 2d       	mov	r24, r11
     680:	0e 94 79 07 	call	0xef2	; 0xef2 <getSn_IR>
     684:	c8 2f       	mov	r28, r24
     686:	84 ff       	sbrs	r24, 4
     688:	f3 cf       	rjmp	.-26     	; 0x670 <sendto+0xea>
     68a:	02 c0       	rjmp	.+4      	; 0x690 <sendto+0x10a>
     68c:	cc 24       	eor	r12, r12
     68e:	dd 24       	eor	r13, r13
//				printf("send fail.\r\n");
#endif
				ret = 0; break;
			}
		}
		setSn_IR(s, Sn_IR_SENDOK);
     690:	8b 2d       	mov	r24, r11
     692:	60 e1       	ldi	r22, 0x10	; 16
     694:	0e 94 84 07 	call	0xf08	; 0xf08 <setSn_IR>
	}
	return ret;
}
     698:	c6 01       	movw	r24, r12
     69a:	df 91       	pop	r29
     69c:	cf 91       	pop	r28
     69e:	1f 91       	pop	r17
     6a0:	0f 91       	pop	r16
     6a2:	ff 90       	pop	r15
     6a4:	ef 90       	pop	r14
     6a6:	df 90       	pop	r13
     6a8:	cf 90       	pop	r12
     6aa:	bf 90       	pop	r11
     6ac:	9f 90       	pop	r9
     6ae:	8f 90       	pop	r8
     6b0:	7f 90       	pop	r7
     6b2:	6f 90       	pop	r6
     6b4:	08 95       	ret

000006b6 <recv>:
to be received and "len" is the data size to be read. This function return received data size
for success else -1.
*********************************************************************
*/
uint32 recv(SOCKET s, uint8 * buf, uint32 len)
{
     6b6:	cf 92       	push	r12
     6b8:	df 92       	push	r13
     6ba:	ff 92       	push	r15
     6bc:	0f 93       	push	r16
     6be:	1f 93       	push	r17
     6c0:	df 93       	push	r29
     6c2:	cf 93       	push	r28
     6c4:	00 d0       	rcall	.+0      	; 0x6c6 <recv+0x10>
     6c6:	cd b7       	in	r28, 0x3d	; 61
     6c8:	de b7       	in	r29, 0x3e	; 62
     6ca:	f8 2e       	mov	r15, r24
     6cc:	6b 01       	movw	r12, r22
	uint16 pack_size = 0;
     6ce:	1a 82       	std	Y+2, r1	; 0x02
     6d0:	19 82       	std	Y+1, r1	; 0x01

#ifdef __DEF_IINCHIP_DBG__
	printf("recv() : len=%08lx\r\n",len);
#endif

	if(IINCHIP_READ(Sn_MR(s)) & Sn_MR_ALIGN)
     6d2:	08 2f       	mov	r16, r24
     6d4:	10 e0       	ldi	r17, 0x00	; 0
     6d6:	08 5f       	subi	r16, 0xF8	; 248
     6d8:	1d 4f       	sbci	r17, 0xFD	; 253
     6da:	c8 01       	movw	r24, r16
     6dc:	a6 e0       	ldi	r26, 0x06	; 6
     6de:	88 0f       	add	r24, r24
     6e0:	99 1f       	adc	r25, r25
     6e2:	aa 95       	dec	r26
     6e4:	e1 f7       	brne	.-8      	; 0x6de <recv+0x28>
     6e6:	01 96       	adiw	r24, 0x01	; 1
     6e8:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
		wiz_read_buf(s, buf, len);

		IINCHIP_WRITE(Sn_CR(s),Sn_CR_RECV);
		return len;
	}
	wiz_read_buf(s, (uint8*)&pack_size, 2);
     6ec:	8f 2d       	mov	r24, r15
     6ee:	be 01       	movw	r22, r28
     6f0:	6f 5f       	subi	r22, 0xFF	; 255
     6f2:	7f 4f       	sbci	r23, 0xFF	; 255
     6f4:	22 e0       	ldi	r18, 0x02	; 2
     6f6:	30 e0       	ldi	r19, 0x00	; 0
     6f8:	40 e0       	ldi	r20, 0x00	; 0
     6fa:	50 e0       	ldi	r21, 0x00	; 0
     6fc:	0e 94 83 0a 	call	0x1506	; 0x1506 <wiz_read_buf>
	pack_size = SWAP16(pack_size);
     700:	99 81       	ldd	r25, Y+1	; 0x01
     702:	8a 81       	ldd	r24, Y+2	; 0x02

	len = pack_size;
     704:	9c 01       	movw	r18, r24
     706:	40 e0       	ldi	r20, 0x00	; 0
     708:	50 e0       	ldi	r21, 0x00	; 0
	if(pack_size & 0x01) len += 1;
     70a:	80 ff       	sbrs	r24, 0
     70c:	04 c0       	rjmp	.+8      	; 0x716 <recv+0x60>
     70e:	2f 5f       	subi	r18, 0xFF	; 255
     710:	3f 4f       	sbci	r19, 0xFF	; 255
     712:	4f 4f       	sbci	r20, 0xFF	; 255
     714:	5f 4f       	sbci	r21, 0xFF	; 255

		IINCHIP_WRITE(Sn_CR(s),Sn_CR_RECV);
		return len;
	}
	wiz_read_buf(s, (uint8*)&pack_size, 2);
	pack_size = SWAP16(pack_size);
     716:	9a 83       	std	Y+2, r25	; 0x02
     718:	89 83       	std	Y+1, r24	; 0x01
	if(pack_size & 0x01) len += 1;
#ifdef __DEF_IINCHIP_DBG__   
	printf("%u:pack_size=%d\r\n", s, pack_size);
#endif

	wiz_read_buf(s, buf, len);
     71a:	8f 2d       	mov	r24, r15
     71c:	b6 01       	movw	r22, r12
     71e:	0e 94 83 0a 	call	0x1506	; 0x1506 <wiz_read_buf>

	IINCHIP_WRITE(Sn_CR(s), Sn_CR_RECV);
     722:	f6 e0       	ldi	r31, 0x06	; 6
     724:	00 0f       	add	r16, r16
     726:	11 1f       	adc	r17, r17
     728:	fa 95       	dec	r31
     72a:	e1 f7       	brne	.-8      	; 0x724 <recv+0x6e>
     72c:	c8 01       	movw	r24, r16
     72e:	03 96       	adiw	r24, 0x03	; 3
     730:	60 e4       	ldi	r22, 0x40	; 64
     732:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
	return (uint32)pack_size;
     736:	29 81       	ldd	r18, Y+1	; 0x01
     738:	3a 81       	ldd	r19, Y+2	; 0x02
     73a:	40 e0       	ldi	r20, 0x00	; 0
     73c:	50 e0       	ldi	r21, 0x00	; 0
}
     73e:	b9 01       	movw	r22, r18
     740:	ca 01       	movw	r24, r20
     742:	0f 90       	pop	r0
     744:	0f 90       	pop	r0
     746:	cf 91       	pop	r28
     748:	df 91       	pop	r29
     74a:	1f 91       	pop	r17
     74c:	0f 91       	pop	r16
     74e:	ff 90       	pop	r15
     750:	df 90       	pop	r13
     752:	cf 90       	pop	r12
     754:	08 95       	ret

00000756 <recvfrom>:
IP address and port is a pointer to store the peer's port number.
This function return received data size for success else -1.
*********************************************************************
*/
uint16 recvfrom(SOCKET s,	uint8 * buf, uint16 len, uint8 * addr, uint16 *port)
{
     756:	7f 92       	push	r7
     758:	8f 92       	push	r8
     75a:	9f 92       	push	r9
     75c:	af 92       	push	r10
     75e:	bf 92       	push	r11
     760:	cf 92       	push	r12
     762:	df 92       	push	r13
     764:	ef 92       	push	r14
     766:	ff 92       	push	r15
     768:	0f 93       	push	r16
     76a:	1f 93       	push	r17
     76c:	df 93       	push	r29
     76e:	cf 93       	push	r28
     770:	cd b7       	in	r28, 0x3d	; 61
     772:	de b7       	in	r29, 0x3e	; 62
     774:	2c 97       	sbiw	r28, 0x0c	; 12
     776:	0f b6       	in	r0, 0x3f	; 63
     778:	f8 94       	cli
     77a:	de bf       	out	0x3e, r29	; 62
     77c:	0f be       	out	0x3f, r0	; 63
     77e:	cd bf       	out	0x3d, r28	; 61
     780:	78 2e       	mov	r7, r24
     782:	6b 01       	movw	r12, r22
     784:	79 01       	movw	r14, r18

#ifdef __DEF_IINCHIP_DBG__
//	printf("recvfrom()\r\n");
#endif

	if ( len > 0 )
     786:	45 2b       	or	r20, r21
     788:	19 f4       	brne	.+6      	; 0x790 <recvfrom+0x3a>
     78a:	00 e0       	ldi	r16, 0x00	; 0
     78c:	10 e0       	ldi	r17, 0x00	; 0
     78e:	1a c1       	rjmp	.+564    	; 0x9c4 <recvfrom+0x26e>
	{
		switch (IINCHIP_READ(Sn_MR(s)) & 0x07)
     790:	88 2e       	mov	r8, r24
     792:	99 24       	eor	r9, r9
     794:	88 e0       	ldi	r24, 0x08	; 8
     796:	92 e0       	ldi	r25, 0x02	; 2
     798:	88 0e       	add	r8, r24
     79a:	99 1e       	adc	r9, r25
     79c:	54 01       	movw	r10, r8
     79e:	86 e0       	ldi	r24, 0x06	; 6
     7a0:	aa 0c       	add	r10, r10
     7a2:	bb 1c       	adc	r11, r11
     7a4:	8a 95       	dec	r24
     7a6:	e1 f7       	brne	.-8      	; 0x7a0 <recvfrom+0x4a>
     7a8:	08 94       	sec
     7aa:	a1 1c       	adc	r10, r1
     7ac:	b1 1c       	adc	r11, r1
     7ae:	c5 01       	movw	r24, r10
     7b0:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
     7b4:	90 e0       	ldi	r25, 0x00	; 0
     7b6:	87 70       	andi	r24, 0x07	; 7
     7b8:	90 70       	andi	r25, 0x00	; 0
     7ba:	83 30       	cpi	r24, 0x03	; 3
     7bc:	91 05       	cpc	r25, r1
     7be:	69 f1       	breq	.+90     	; 0x81a <recvfrom+0xc4>
     7c0:	84 30       	cpi	r24, 0x04	; 4
     7c2:	91 05       	cpc	r25, r1
     7c4:	09 f4       	brne	.+2      	; 0x7c8 <recvfrom+0x72>
     7c6:	45 c0       	rjmp	.+138    	; 0x852 <recvfrom+0xfc>
     7c8:	02 97       	sbiw	r24, 0x02	; 2
     7ca:	19 f0       	breq	.+6      	; 0x7d2 <recvfrom+0x7c>
     7cc:	00 e0       	ldi	r16, 0x00	; 0
     7ce:	10 e0       	ldi	r17, 0x00	; 0
     7d0:	50 c0       	rjmp	.+160    	; 0x872 <recvfrom+0x11c>
		{
			case Sn_MR_UDP :
				wiz_read_buf(s, head, 0x08);
     7d2:	87 2d       	mov	r24, r7
     7d4:	be 01       	movw	r22, r28
     7d6:	6b 5f       	subi	r22, 0xFB	; 251
     7d8:	7f 4f       	sbci	r23, 0xFF	; 255
     7da:	28 e0       	ldi	r18, 0x08	; 8
     7dc:	30 e0       	ldi	r19, 0x00	; 0
     7de:	40 e0       	ldi	r20, 0x00	; 0
     7e0:	50 e0       	ldi	r21, 0x00	; 0
     7e2:	0e 94 83 0a 	call	0x1506	; 0x1506 <wiz_read_buf>
				// read peer's IP address, port number.
				addr[0] = head[0];
     7e6:	8d 81       	ldd	r24, Y+5	; 0x05
     7e8:	d7 01       	movw	r26, r14
     7ea:	8c 93       	st	X, r24
				addr[1] = head[1];
     7ec:	8e 81       	ldd	r24, Y+6	; 0x06
     7ee:	11 96       	adiw	r26, 0x01	; 1
     7f0:	8c 93       	st	X, r24
     7f2:	11 97       	sbiw	r26, 0x01	; 1
				addr[2] = head[2];
     7f4:	8f 81       	ldd	r24, Y+7	; 0x07
     7f6:	12 96       	adiw	r26, 0x02	; 2
     7f8:	8c 93       	st	X, r24
     7fa:	12 97       	sbiw	r26, 0x02	; 2
				addr[3] = head[3];
     7fc:	88 85       	ldd	r24, Y+8	; 0x08
     7fe:	13 96       	adiw	r26, 0x03	; 3
     800:	8c 93       	st	X, r24
				*port = head[4];
				*port = (*port << 8) + head[5];
     802:	99 85       	ldd	r25, Y+9	; 0x09
     804:	80 e0       	ldi	r24, 0x00	; 0
     806:	2a 85       	ldd	r18, Y+10	; 0x0a
     808:	82 0f       	add	r24, r18
     80a:	91 1d       	adc	r25, r1
     80c:	f8 01       	movw	r30, r16
     80e:	91 83       	std	Z+1, r25	; 0x01
     810:	80 83       	st	Z, r24
				data_len = (uint16)head[6];
				data_len = (data_len << 8) + (uint16)head[7];
     812:	9b 85       	ldd	r25, Y+11	; 0x0b
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	2c 85       	ldd	r18, Y+12	; 0x0c
     818:	29 c0       	rjmp	.+82     	; 0x86c <recvfrom+0x116>
//				printf("source Port : %d\r\n", *port);
//				printf("source IP : %d.%d.%d.%d\r\n", addr[0], addr[1], addr[2], addr[3]);
#endif
				break;
			case Sn_MR_IPRAW :
				wiz_read_buf(s, head, 0x06);
     81a:	87 2d       	mov	r24, r7
     81c:	be 01       	movw	r22, r28
     81e:	6b 5f       	subi	r22, 0xFB	; 251
     820:	7f 4f       	sbci	r23, 0xFF	; 255
     822:	26 e0       	ldi	r18, 0x06	; 6
     824:	30 e0       	ldi	r19, 0x00	; 0
     826:	40 e0       	ldi	r20, 0x00	; 0
     828:	50 e0       	ldi	r21, 0x00	; 0
     82a:	0e 94 83 0a 	call	0x1506	; 0x1506 <wiz_read_buf>
				addr[0] = head[0];
     82e:	8d 81       	ldd	r24, Y+5	; 0x05
     830:	d7 01       	movw	r26, r14
     832:	8c 93       	st	X, r24
				addr[1] = head[1];
     834:	8e 81       	ldd	r24, Y+6	; 0x06
     836:	11 96       	adiw	r26, 0x01	; 1
     838:	8c 93       	st	X, r24
     83a:	11 97       	sbiw	r26, 0x01	; 1
				addr[2] = head[2];
     83c:	8f 81       	ldd	r24, Y+7	; 0x07
     83e:	12 96       	adiw	r26, 0x02	; 2
     840:	8c 93       	st	X, r24
     842:	12 97       	sbiw	r26, 0x02	; 2
				addr[3] = head[3];
     844:	88 85       	ldd	r24, Y+8	; 0x08
     846:	13 96       	adiw	r26, 0x03	; 3
     848:	8c 93       	st	X, r24
				data_len = (uint16)head[4];
				data_len = (data_len << 8) + (uint16)head[5];
     84a:	99 85       	ldd	r25, Y+9	; 0x09
     84c:	80 e0       	ldi	r24, 0x00	; 0
     84e:	2a 85       	ldd	r18, Y+10	; 0x0a
     850:	0d c0       	rjmp	.+26     	; 0x86c <recvfrom+0x116>
				printf("IP RAW msg arrived\r\n");
				printf("source IP : %d.%d.%d.%d\r\n", addr[0], addr[1], addr[2], addr[3]);
#endif
				break;
			case Sn_MR_MACRAW :
				wiz_read_buf(s, head, 2);
     852:	87 2d       	mov	r24, r7
     854:	be 01       	movw	r22, r28
     856:	6b 5f       	subi	r22, 0xFB	; 251
     858:	7f 4f       	sbci	r23, 0xFF	; 255
     85a:	22 e0       	ldi	r18, 0x02	; 2
     85c:	30 e0       	ldi	r19, 0x00	; 0
     85e:	40 e0       	ldi	r20, 0x00	; 0
     860:	50 e0       	ldi	r21, 0x00	; 0
     862:	0e 94 83 0a 	call	0x1506	; 0x1506 <wiz_read_buf>
				data_len = (uint16)head[0];
				data_len = (data_len<<8) + (uint16)head[1];
     866:	9d 81       	ldd	r25, Y+5	; 0x05
     868:	80 e0       	ldi	r24, 0x00	; 0
     86a:	2e 81       	ldd	r18, Y+6	; 0x06
     86c:	8c 01       	movw	r16, r24
     86e:	02 0f       	add	r16, r18
     870:	11 1d       	adc	r17, r1

			default :
				break;
		}

		wiz_read_buf(s, buf, data_len+(data_len & 0x01)); // data copy.
     872:	98 01       	movw	r18, r16
     874:	21 70       	andi	r18, 0x01	; 1
     876:	30 70       	andi	r19, 0x00	; 0
     878:	20 0f       	add	r18, r16
     87a:	31 1f       	adc	r19, r17
     87c:	40 e0       	ldi	r20, 0x00	; 0
     87e:	50 e0       	ldi	r21, 0x00	; 0
     880:	87 2d       	mov	r24, r7
     882:	b6 01       	movw	r22, r12
     884:	0e 94 83 0a 	call	0x1506	; 0x1506 <wiz_read_buf>
		if((IINCHIP_READ(Sn_MR(s)) & 0x07)==Sn_MR_MACRAW)
     888:	c5 01       	movw	r24, r10
     88a:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
     88e:	87 70       	andi	r24, 0x07	; 7
     890:	84 30       	cpi	r24, 0x04	; 4
     892:	09 f0       	breq	.+2      	; 0x896 <recvfrom+0x140>
     894:	8d c0       	rjmp	.+282    	; 0x9b0 <recvfrom+0x25a>
		{
			uint8 crc[4];
#ifndef __DEF_IINCHIP_DGB__
				printf("MAC RAW msg arrived\r\n");
     896:	82 e2       	ldi	r24, 0x22	; 34
     898:	91 e0       	ldi	r25, 0x01	; 1
     89a:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
				printf("dest mac=%.2X.%.2X.%.2X.%.2X.%.2X.%.2X\r\n",buf[0],buf[1],buf[2],buf[3],buf[4],buf[5]);
     89e:	ed b7       	in	r30, 0x3d	; 61
     8a0:	fe b7       	in	r31, 0x3e	; 62
     8a2:	3e 97       	sbiw	r30, 0x0e	; 14
     8a4:	0f b6       	in	r0, 0x3f	; 63
     8a6:	f8 94       	cli
     8a8:	fe bf       	out	0x3e, r31	; 62
     8aa:	0f be       	out	0x3f, r0	; 63
     8ac:	ed bf       	out	0x3d, r30	; 61
     8ae:	31 96       	adiw	r30, 0x01	; 1
     8b0:	87 e3       	ldi	r24, 0x37	; 55
     8b2:	91 e0       	ldi	r25, 0x01	; 1
     8b4:	ad b7       	in	r26, 0x3d	; 61
     8b6:	be b7       	in	r27, 0x3e	; 62
     8b8:	12 96       	adiw	r26, 0x02	; 2
     8ba:	9c 93       	st	X, r25
     8bc:	8e 93       	st	-X, r24
     8be:	11 97       	sbiw	r26, 0x01	; 1
     8c0:	d6 01       	movw	r26, r12
     8c2:	8c 91       	ld	r24, X
     8c4:	82 83       	std	Z+2, r24	; 0x02
     8c6:	13 82       	std	Z+3, r1	; 0x03
     8c8:	11 96       	adiw	r26, 0x01	; 1
     8ca:	8c 91       	ld	r24, X
     8cc:	11 97       	sbiw	r26, 0x01	; 1
     8ce:	84 83       	std	Z+4, r24	; 0x04
     8d0:	15 82       	std	Z+5, r1	; 0x05
     8d2:	12 96       	adiw	r26, 0x02	; 2
     8d4:	8c 91       	ld	r24, X
     8d6:	12 97       	sbiw	r26, 0x02	; 2
     8d8:	86 83       	std	Z+6, r24	; 0x06
     8da:	17 82       	std	Z+7, r1	; 0x07
     8dc:	13 96       	adiw	r26, 0x03	; 3
     8de:	8c 91       	ld	r24, X
     8e0:	13 97       	sbiw	r26, 0x03	; 3
     8e2:	80 87       	std	Z+8, r24	; 0x08
     8e4:	11 86       	std	Z+9, r1	; 0x09
     8e6:	14 96       	adiw	r26, 0x04	; 4
     8e8:	8c 91       	ld	r24, X
     8ea:	14 97       	sbiw	r26, 0x04	; 4
     8ec:	82 87       	std	Z+10, r24	; 0x0a
     8ee:	13 86       	std	Z+11, r1	; 0x0b
     8f0:	15 96       	adiw	r26, 0x05	; 5
     8f2:	8c 91       	ld	r24, X
     8f4:	84 87       	std	Z+12, r24	; 0x0c
     8f6:	15 86       	std	Z+13, r1	; 0x0d
     8f8:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
				printf("src  mac=%.2X.%.2X.%.2X.%.2X.%.2X.%.2X\r\n",buf[6],buf[7],buf[8],buf[9],buf[10],buf[11]);
     8fc:	ed b7       	in	r30, 0x3d	; 61
     8fe:	fe b7       	in	r31, 0x3e	; 62
     900:	31 96       	adiw	r30, 0x01	; 1
     902:	80 e6       	ldi	r24, 0x60	; 96
     904:	91 e0       	ldi	r25, 0x01	; 1
     906:	ad b7       	in	r26, 0x3d	; 61
     908:	be b7       	in	r27, 0x3e	; 62
     90a:	12 96       	adiw	r26, 0x02	; 2
     90c:	9c 93       	st	X, r25
     90e:	8e 93       	st	-X, r24
     910:	11 97       	sbiw	r26, 0x01	; 1
     912:	d6 01       	movw	r26, r12
     914:	16 96       	adiw	r26, 0x06	; 6
     916:	8c 91       	ld	r24, X
     918:	16 97       	sbiw	r26, 0x06	; 6
     91a:	82 83       	std	Z+2, r24	; 0x02
     91c:	13 82       	std	Z+3, r1	; 0x03
     91e:	17 96       	adiw	r26, 0x07	; 7
     920:	8c 91       	ld	r24, X
     922:	17 97       	sbiw	r26, 0x07	; 7
     924:	84 83       	std	Z+4, r24	; 0x04
     926:	15 82       	std	Z+5, r1	; 0x05
     928:	18 96       	adiw	r26, 0x08	; 8
     92a:	8c 91       	ld	r24, X
     92c:	18 97       	sbiw	r26, 0x08	; 8
     92e:	86 83       	std	Z+6, r24	; 0x06
     930:	17 82       	std	Z+7, r1	; 0x07
     932:	19 96       	adiw	r26, 0x09	; 9
     934:	8c 91       	ld	r24, X
     936:	19 97       	sbiw	r26, 0x09	; 9
     938:	80 87       	std	Z+8, r24	; 0x08
     93a:	11 86       	std	Z+9, r1	; 0x09
     93c:	1a 96       	adiw	r26, 0x0a	; 10
     93e:	8c 91       	ld	r24, X
     940:	1a 97       	sbiw	r26, 0x0a	; 10
     942:	82 87       	std	Z+10, r24	; 0x0a
     944:	13 86       	std	Z+11, r1	; 0x0b
     946:	1b 96       	adiw	r26, 0x0b	; 11
     948:	8c 91       	ld	r24, X
     94a:	84 87       	std	Z+12, r24	; 0x0c
     94c:	15 86       	std	Z+13, r1	; 0x0d
     94e:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
				printf("type    =%.2X%.2X\r\n",buf[12],buf[13]); 
     952:	ed b7       	in	r30, 0x3d	; 61
     954:	fe b7       	in	r31, 0x3e	; 62
     956:	38 96       	adiw	r30, 0x08	; 8
     958:	0f b6       	in	r0, 0x3f	; 63
     95a:	f8 94       	cli
     95c:	fe bf       	out	0x3e, r31	; 62
     95e:	0f be       	out	0x3f, r0	; 63
     960:	ed bf       	out	0x3d, r30	; 61
     962:	31 96       	adiw	r30, 0x01	; 1
     964:	89 e8       	ldi	r24, 0x89	; 137
     966:	91 e0       	ldi	r25, 0x01	; 1
     968:	ad b7       	in	r26, 0x3d	; 61
     96a:	be b7       	in	r27, 0x3e	; 62
     96c:	12 96       	adiw	r26, 0x02	; 2
     96e:	9c 93       	st	X, r25
     970:	8e 93       	st	-X, r24
     972:	11 97       	sbiw	r26, 0x01	; 1
     974:	d6 01       	movw	r26, r12
     976:	1c 96       	adiw	r26, 0x0c	; 12
     978:	8c 91       	ld	r24, X
     97a:	1c 97       	sbiw	r26, 0x0c	; 12
     97c:	82 83       	std	Z+2, r24	; 0x02
     97e:	13 82       	std	Z+3, r1	; 0x03
     980:	1d 96       	adiw	r26, 0x0d	; 13
     982:	8c 91       	ld	r24, X
     984:	84 83       	std	Z+4, r24	; 0x04
     986:	15 82       	std	Z+5, r1	; 0x05
     988:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
#endif				
			wiz_read_buf(s, crc, 4);
     98c:	ed b7       	in	r30, 0x3d	; 61
     98e:	fe b7       	in	r31, 0x3e	; 62
     990:	36 96       	adiw	r30, 0x06	; 6
     992:	0f b6       	in	r0, 0x3f	; 63
     994:	f8 94       	cli
     996:	fe bf       	out	0x3e, r31	; 62
     998:	0f be       	out	0x3f, r0	; 63
     99a:	ed bf       	out	0x3d, r30	; 61
     99c:	87 2d       	mov	r24, r7
     99e:	be 01       	movw	r22, r28
     9a0:	6f 5f       	subi	r22, 0xFF	; 255
     9a2:	7f 4f       	sbci	r23, 0xFF	; 255
     9a4:	24 e0       	ldi	r18, 0x04	; 4
     9a6:	30 e0       	ldi	r19, 0x00	; 0
     9a8:	40 e0       	ldi	r20, 0x00	; 0
     9aa:	50 e0       	ldi	r21, 0x00	; 0
     9ac:	0e 94 83 0a 	call	0x1506	; 0x1506 <wiz_read_buf>
		}
		IINCHIP_WRITE(Sn_CR(s), Sn_CR_RECV);
     9b0:	b6 e0       	ldi	r27, 0x06	; 6
     9b2:	88 0c       	add	r8, r8
     9b4:	99 1c       	adc	r9, r9
     9b6:	ba 95       	dec	r27
     9b8:	e1 f7       	brne	.-8      	; 0x9b2 <recvfrom+0x25c>
     9ba:	c4 01       	movw	r24, r8
     9bc:	03 96       	adiw	r24, 0x03	; 3
     9be:	60 e4       	ldi	r22, 0x40	; 64
     9c0:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
	}
#ifdef __DEF_IINCHIP_DBG__
//	printf("recvfrom() end ..\r\n");
#endif
	return data_len;
}
     9c4:	c8 01       	movw	r24, r16
     9c6:	2c 96       	adiw	r28, 0x0c	; 12
     9c8:	0f b6       	in	r0, 0x3f	; 63
     9ca:	f8 94       	cli
     9cc:	de bf       	out	0x3e, r29	; 62
     9ce:	0f be       	out	0x3f, r0	; 63
     9d0:	cd bf       	out	0x3d, r28	; 61
     9d2:	cf 91       	pop	r28
     9d4:	df 91       	pop	r29
     9d6:	1f 91       	pop	r17
     9d8:	0f 91       	pop	r16
     9da:	ff 90       	pop	r15
     9dc:	ef 90       	pop	r14
     9de:	df 90       	pop	r13
     9e0:	cf 90       	pop	r12
     9e2:	bf 90       	pop	r11
     9e4:	af 90       	pop	r10
     9e6:	9f 90       	pop	r9
     9e8:	8f 90       	pop	r8
     9ea:	7f 90       	pop	r7
     9ec:	08 95       	ret

000009ee <listen>:
This function return 1 for success else 0.
*********************************************************************
*/

uint8 listen(SOCKET s)
{
     9ee:	ef 92       	push	r14
     9f0:	ff 92       	push	r15
     9f2:	0f 93       	push	r16
     9f4:	1f 93       	push	r17
     9f6:	f8 2e       	mov	r15, r24
	uint8 ret;
#ifdef __DEF_IINCHIP_DBG__
	printf("listen()\r\n");
#endif
	if( getSn_SSR(s) == SOCK_INIT )
     9f8:	0e 94 8f 07 	call	0xf1e	; 0xf1e <getSn_SSR>
     9fc:	83 31       	cpi	r24, 0x13	; 19
     9fe:	11 f0       	breq	.+4      	; 0xa04 <listen+0x16>
     a00:	ee 24       	eor	r14, r14
     a02:	0e c0       	rjmp	.+28     	; 0xa20 <listen+0x32>
	{
		IINCHIP_WRITE(Sn_CR(s), Sn_CR_LISTEN);
     a04:	8f 2d       	mov	r24, r15
     a06:	90 e0       	ldi	r25, 0x00	; 0
     a08:	26 e0       	ldi	r18, 0x06	; 6
     a0a:	88 0f       	add	r24, r24
     a0c:	99 1f       	adc	r25, r25
     a0e:	2a 95       	dec	r18
     a10:	e1 f7       	brne	.-8      	; 0xa0a <listen+0x1c>
     a12:	8d 5f       	subi	r24, 0xFD	; 253
     a14:	9d 47       	sbci	r25, 0x7D	; 125
     a16:	62 e0       	ldi	r22, 0x02	; 2
     a18:	0e 94 d6 05 	call	0xbac	; 0xbac <IINCHIP_WRITE>
     a1c:	ee 24       	eor	r14, r14
     a1e:	e3 94       	inc	r14
		ret = 0;
#ifdef __DEF_IINCHIP_DBG__
	printf("listen() - Failed. getSn_SSR(s) = 0x%02x \r\n", getSn_SSR(s));
#endif
	}
	printf("Sn_PORTR(%d) : 0x%02x\r\n", s, IINCHIP_READ(Sn_PORTR(s)));
     a20:	0f 2d       	mov	r16, r15
     a22:	10 e0       	ldi	r17, 0x00	; 0
     a24:	08 5f       	subi	r16, 0xF8	; 248
     a26:	1d 4f       	sbci	r17, 0xFD	; 253
     a28:	96 e0       	ldi	r25, 0x06	; 6
     a2a:	00 0f       	add	r16, r16
     a2c:	11 1f       	adc	r17, r17
     a2e:	9a 95       	dec	r25
     a30:	e1 f7       	brne	.-8      	; 0xa2a <listen+0x3c>
     a32:	c8 01       	movw	r24, r16
     a34:	0a 96       	adiw	r24, 0x0a	; 10
     a36:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
     a3a:	00 d0       	rcall	.+0      	; 0xa3c <listen+0x4e>
     a3c:	00 d0       	rcall	.+0      	; 0xa3e <listen+0x50>
     a3e:	00 d0       	rcall	.+0      	; 0xa40 <listen+0x52>
     a40:	ed b7       	in	r30, 0x3d	; 61
     a42:	fe b7       	in	r31, 0x3e	; 62
     a44:	31 96       	adiw	r30, 0x01	; 1
     a46:	2d e9       	ldi	r18, 0x9D	; 157
     a48:	31 e0       	ldi	r19, 0x01	; 1
     a4a:	ad b7       	in	r26, 0x3d	; 61
     a4c:	be b7       	in	r27, 0x3e	; 62
     a4e:	12 96       	adiw	r26, 0x02	; 2
     a50:	3c 93       	st	X, r19
     a52:	2e 93       	st	-X, r18
     a54:	11 97       	sbiw	r26, 0x01	; 1
     a56:	f2 82       	std	Z+2, r15	; 0x02
     a58:	13 82       	std	Z+3, r1	; 0x03
     a5a:	84 83       	std	Z+4, r24	; 0x04
     a5c:	15 82       	std	Z+5, r1	; 0x05
     a5e:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
	printf("Sn_PORTR(%d)+1 : 0x%02x\r\n", s, IINCHIP_READ(Sn_PORTR(s)+1));
     a62:	8d b7       	in	r24, 0x3d	; 61
     a64:	9e b7       	in	r25, 0x3e	; 62
     a66:	06 96       	adiw	r24, 0x06	; 6
     a68:	0f b6       	in	r0, 0x3f	; 63
     a6a:	f8 94       	cli
     a6c:	9e bf       	out	0x3e, r25	; 62
     a6e:	0f be       	out	0x3f, r0	; 63
     a70:	8d bf       	out	0x3d, r24	; 61
     a72:	c8 01       	movw	r24, r16
     a74:	0b 96       	adiw	r24, 0x0b	; 11
     a76:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
     a7a:	00 d0       	rcall	.+0      	; 0xa7c <listen+0x8e>
     a7c:	00 d0       	rcall	.+0      	; 0xa7e <listen+0x90>
     a7e:	00 d0       	rcall	.+0      	; 0xa80 <listen+0x92>
     a80:	ed b7       	in	r30, 0x3d	; 61
     a82:	fe b7       	in	r31, 0x3e	; 62
     a84:	31 96       	adiw	r30, 0x01	; 1
     a86:	25 eb       	ldi	r18, 0xB5	; 181
     a88:	31 e0       	ldi	r19, 0x01	; 1
     a8a:	ad b7       	in	r26, 0x3d	; 61
     a8c:	be b7       	in	r27, 0x3e	; 62
     a8e:	12 96       	adiw	r26, 0x02	; 2
     a90:	3c 93       	st	X, r19
     a92:	2e 93       	st	-X, r18
     a94:	11 97       	sbiw	r26, 0x01	; 1
     a96:	f2 82       	std	Z+2, r15	; 0x02
     a98:	13 82       	std	Z+3, r1	; 0x03
     a9a:	84 83       	std	Z+4, r24	; 0x04
     a9c:	15 82       	std	Z+5, r1	; 0x05
     a9e:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
     aa2:	8d b7       	in	r24, 0x3d	; 61
     aa4:	9e b7       	in	r25, 0x3e	; 62
     aa6:	06 96       	adiw	r24, 0x06	; 6
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	f8 94       	cli
     aac:	9e bf       	out	0x3e, r25	; 62
     aae:	0f be       	out	0x3f, r0	; 63
     ab0:	8d bf       	out	0x3d, r24	; 61
	return ret;
}
     ab2:	8e 2d       	mov	r24, r14
     ab4:	1f 91       	pop	r17
     ab6:	0f 91       	pop	r16
     ab8:	ff 90       	pop	r15
     aba:	ef 90       	pop	r14
     abc:	08 95       	ret

00000abe <send>:
This function return 1 for success else 0.
*********************************************************************
*/

uint32   send(SOCKET s, uint8 * buf, uint32 len)
{
     abe:	9f 92       	push	r9
     ac0:	af 92       	push	r10
     ac2:	bf 92       	push	r11
     ac4:	cf 92       	push	r12
     ac6:	df 92       	push	r13
     ac8:	ef 92       	push	r14
     aca:	ff 92       	push	r15
     acc:	0f 93       	push	r16
     ace:	1f 93       	push	r17
     ad0:	cf 93       	push	r28
     ad2:	df 93       	push	r29
     ad4:	98 2e       	mov	r9, r24
     ad6:	eb 01       	movw	r28, r22
     ad8:	79 01       	movw	r14, r18
     ada:	8a 01       	movw	r16, r20

      printf("%d : send()\r\n",s);
   #endif
   
   ret = len;
   if (len > getIINCHIP_TxMAX(s)) ret = getIINCHIP_TxMAX(s); // check size not to exceed MAX size.
     adc:	0e 94 b4 0a 	call	0x1568	; 0x1568 <getIINCHIP_TxMAX>
     ae0:	6e 15       	cp	r22, r14
     ae2:	7f 05       	cpc	r23, r15
     ae4:	80 07       	cpc	r24, r16
     ae6:	91 07       	cpc	r25, r17
     ae8:	28 f4       	brcc	.+10     	; 0xaf4 <send+0x36>
     aea:	89 2d       	mov	r24, r9
     aec:	0e 94 b4 0a 	call	0x1568	; 0x1568 <getIINCHIP_TxMAX>
     af0:	7b 01       	movw	r14, r22
     af2:	8c 01       	movw	r16, r24
    */
   // -----------------------
   // NOTE : CODE BLOCK START
   do                                   
   {
      freesize = getSn_TX_FSR(s);
     af4:	89 2d       	mov	r24, r9
     af6:	0e 94 82 08 	call	0x1104	; 0x1104 <getSn_TX_FSR>
     afa:	5b 01       	movw	r10, r22
     afc:	6c 01       	movw	r12, r24
      status = getSn_SSR(s);
     afe:	89 2d       	mov	r24, r9
     b00:	0e 94 8f 07 	call	0xf1e	; 0xf1e <getSn_SSR>
            printf("%d:Send Size=%08lx(%d)\r\n",s,ret,ret);
            printf("MR=%04x\r\n",*((vuint16*)MR));
            loopcnt = 0;
         }
      #endif
      if ((status != SOCK_ESTABLISHED) && (status != SOCK_CLOSE_WAIT)) return 0;
     b04:	87 31       	cpi	r24, 0x17	; 23
     b06:	11 f0       	breq	.+4      	; 0xb0c <send+0x4e>
     b08:	8c 31       	cpi	r24, 0x1C	; 28
     b0a:	e1 f5       	brne	.+120    	; 0xb84 <send+0xc6>
   } while (freesize < ret);
     b0c:	ae 14       	cp	r10, r14
     b0e:	bf 04       	cpc	r11, r15
     b10:	c0 06       	cpc	r12, r16
     b12:	d1 06       	cpc	r13, r17
     b14:	78 f3       	brcs	.-34     	; 0xaf4 <send+0x36>
   // NOTE : CODE BLOCK END
   // ---------------------
   
	 if(ret & 0x01) wiz_write_buf(s, buf, (ret+1));
     b16:	c7 01       	movw	r24, r14
     b18:	81 70       	andi	r24, 0x01	; 1
     b1a:	90 70       	andi	r25, 0x00	; 0
     b1c:	89 2b       	or	r24, r25
     b1e:	49 f0       	breq	.+18     	; 0xb32 <send+0x74>
     b20:	a8 01       	movw	r20, r16
     b22:	97 01       	movw	r18, r14
     b24:	2f 5f       	subi	r18, 0xFF	; 255
     b26:	3f 4f       	sbci	r19, 0xFF	; 255
     b28:	4f 4f       	sbci	r20, 0xFF	; 255
     b2a:	5f 4f       	sbci	r21, 0xFF	; 255
     b2c:	89 2d       	mov	r24, r9
     b2e:	be 01       	movw	r22, r28
     b30:	04 c0       	rjmp	.+8      	; 0xb3a <send+0x7c>
	 else wiz_write_buf(s,buf,ret);                   // copy data
     b32:	89 2d       	mov	r24, r9
     b34:	be 01       	movw	r22, r28
     b36:	a8 01       	movw	r20, r16
     b38:	97 01       	movw	r18, r14
     b3a:	0e 94 52 0a 	call	0x14a4	; 0x14a4 <wiz_write_buf>

   #ifdef __DEF_IINCHIP_DBG__
      loopcnt=0;
   #endif   
   
   if(!first_send_flag[s])                	 // if first send, skip.
     b3e:	e9 2d       	mov	r30, r9
     b40:	f0 e0       	ldi	r31, 0x00	; 0
     b42:	e2 52       	subi	r30, 0x22	; 34
     b44:	fa 4f       	sbci	r31, 0xFA	; 250
     b46:	80 81       	ld	r24, Z
     b48:	88 23       	and	r24, r24
     b4a:	31 f0       	breq	.+12     	; 0xb58 <send+0x9a>
     b4c:	0f c0       	rjmp	.+30     	; 0xb6c <send+0xae>
            printf("%d:Send Size=%08lx(%d)\r\n",s,ret,ret);
            printf("MR=%04x\r\n",*((vuint16*)MR));
            loopcnt = 0;
         }
      #endif
         if (getSn_SSR(s) == SOCK_CLOSED)    // check timeout or abnormal closed.
     b4e:	89 2d       	mov	r24, r9
     b50:	0e 94 8f 07 	call	0xf1e	; 0xf1e <getSn_SSR>
     b54:	88 23       	and	r24, r24
     b56:	b1 f0       	breq	.+44     	; 0xb84 <send+0xc6>
      loopcnt=0;
   #endif   
   
   if(!first_send_flag[s])                	 // if first send, skip.
   {
      while (!(getSn_IR(s) & Sn_IR_SENDOK))  // wait previous SEND command completion.
     b58:	89 2d       	mov	r24, r9
     b5a:	0e 94 79 07 	call	0xef2	; 0xef2 <getSn_IR>
     b5e:	84 ff       	sbrs	r24, 4
     b60:	f6 cf       	rjmp	.-20     	; 0xb4e <send+0x90>
               printf("%d : Send Fail. SOCK_CLOSED.\r\n",s);
            #endif
            return 0;
         }
      }
      setSn_IR(s, Sn_IR_SENDOK);             // clear Sn_IR_SENDOK	
     b62:	89 2d       	mov	r24, r9
     b64:	60 e1       	ldi	r22, 0x10	; 16
     b66:	0e 94 84 07 	call	0xf08	; 0xf08 <setSn_IR>
     b6a:	01 c0       	rjmp	.+2      	; 0xb6e <send+0xb0>
   }
   else first_send_flag[s] = 0;
     b6c:	10 82       	st	Z, r1
   
   // send
   setSn_TX_WRSR(s,ret);   
     b6e:	89 2d       	mov	r24, r9
     b70:	b8 01       	movw	r22, r16
     b72:	a7 01       	movw	r20, r14
     b74:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <setSn_TX_WRSR>
   setSn_CR(s,Sn_CR_SEND);
     b78:	89 2d       	mov	r24, r9
     b7a:	60 e2       	ldi	r22, 0x20	; 32
     b7c:	70 e0       	ldi	r23, 0x00	; 0
     b7e:	0e 94 52 07 	call	0xea4	; 0xea4 <setSn_CR>
     b82:	03 c0       	rjmp	.+6      	; 0xb8a <send+0xcc>
   return ret;
     b84:	ee 24       	eor	r14, r14
     b86:	ff 24       	eor	r15, r15
     b88:	87 01       	movw	r16, r14
}
     b8a:	b7 01       	movw	r22, r14
     b8c:	c8 01       	movw	r24, r16
     b8e:	df 91       	pop	r29
     b90:	cf 91       	pop	r28
     b92:	1f 91       	pop	r17
     b94:	0f 91       	pop	r16
     b96:	ff 90       	pop	r15
     b98:	ef 90       	pop	r14
     b9a:	df 90       	pop	r13
     b9c:	cf 90       	pop	r12
     b9e:	bf 90       	pop	r11
     ba0:	af 90       	pop	r10
     ba2:	9f 90       	pop	r9
     ba4:	08 95       	ret

00000ba6 <IINCHIP_READ>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     ba6:	fc 01       	movw	r30, r24
     ba8:	80 81       	ld	r24, Z
	  if(addr &0x01) data = *((vuint8*)IDM_DR1);
	  else data = *((vuint8*)IDM_DR);

   return data;
#endif
}
     baa:	08 95       	ret

00000bac <IINCHIP_WRITE>:

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     bac:	fc 01       	movw	r30, r24
     bae:	60 83       	st	Z, r22
    *((vuint8*)IDM_AR) = addr >> 8;
	  *((vuint8*)IDM_AR1) = addr;
	  if(addr &0x01) *((vuint8*)IDM_DR1) = data;
	  else *((vuint8*)IDM_DR) = data;
#endif
}
     bb0:	08 95       	ret

00000bb2 <getMR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     bb2:	40 91 00 80 	lds	r20, 0x8000


uint16   getMR(void)
{
   return (IINCHIP_READ(MR_) << 8 | IINCHIP_READ(MR));
}
     bb6:	20 91 01 80 	lds	r18, 0x8001
     bba:	94 2f       	mov	r25, r20
     bbc:	80 e0       	ldi	r24, 0x00	; 0
     bbe:	30 e0       	ldi	r19, 0x00	; 0
     bc0:	28 2b       	or	r18, r24
     bc2:	39 2b       	or	r19, r25
     bc4:	c9 01       	movw	r24, r18
     bc6:	08 95       	ret

00000bc8 <setMR>:
void     setMR(uint16 val)
{
   *((volatile uint8*)MR_) = val >> 8;
     bc8:	90 93 00 80 	sts	0x8000, r25
   *((volatile uint8*)MR) = val & 0xff;
     bcc:	80 93 01 80 	sts	0x8001, r24
}
     bd0:	08 95       	ret

00000bd2 <getIR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     bd2:	40 91 02 80 	lds	r20, 0x8002
/* Interrupt */ 

uint16 getIR(void)
{
   return (IINCHIP_READ(IR0) << 8 | IINCHIP_READ(IR1)); 
}
     bd6:	20 91 03 80 	lds	r18, 0x8003
     bda:	94 2f       	mov	r25, r20
     bdc:	80 e0       	ldi	r24, 0x00	; 0
     bde:	30 e0       	ldi	r19, 0x00	; 0
     be0:	28 2b       	or	r18, r24
     be2:	39 2b       	or	r19, r25
     be4:	c9 01       	movw	r24, r18
     be6:	08 95       	ret

00000be8 <setIR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     be8:	10 92 02 80 	sts	0x8002, r1
}

void setIR(uint8 s, uint16 val)
{
   IINCHIP_WRITE(IR,val&0xFF00);
}
     bec:	08 95       	ret

00000bee <getIMR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     bee:	40 91 04 80 	lds	r20, 0x8004
}

uint16   getIMR(void)
{
   return ((IINCHIP_READ(IMR0) << 8) | IINCHIP_READ(IMR1));
}
     bf2:	20 91 05 80 	lds	r18, 0x8005
     bf6:	94 2f       	mov	r25, r20
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	30 e0       	ldi	r19, 0x00	; 0
     bfc:	28 2b       	or	r18, r24
     bfe:	39 2b       	or	r19, r25
     c00:	c9 01       	movw	r24, r18
     c02:	08 95       	ret

00000c04 <setIMR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     c04:	90 93 04 80 	sts	0x8004, r25
}
void     setIMR(uint16 mask)
{
	IINCHIP_WRITE(IMR0, mask >> 8); 
	IINCHIP_WRITE(IMR1, mask & 0xff); 
}
     c08:	80 93 05 80 	sts	0x8005, r24
     c0c:	08 95       	ret

00000c0e <getSHAR>:


/* Network Information */

void getSHAR(uint8 * addr)
{
     c0e:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c10:	80 91 08 80 	lds	r24, 0x8008

/* Network Information */

void getSHAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SHAR);
     c14:	80 83       	st	Z, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c16:	80 91 09 80 	lds	r24, 0x8009
/* Network Information */

void getSHAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
     c1a:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c1c:	80 91 0a 80 	lds	r24, 0x800A

void getSHAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
	addr[2] = IINCHIP_READ(SHAR2);
     c20:	82 83       	std	Z+2, r24	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c22:	80 91 0b 80 	lds	r24, 0x800B
void getSHAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
	addr[2] = IINCHIP_READ(SHAR2);
	addr[3] = IINCHIP_READ(SHAR3);
     c26:	83 83       	std	Z+3, r24	; 0x03
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c28:	80 91 0c 80 	lds	r24, 0x800C
{
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
	addr[2] = IINCHIP_READ(SHAR2);
	addr[3] = IINCHIP_READ(SHAR3);
	addr[4] = IINCHIP_READ(SHAR4);
     c2c:	84 83       	std	Z+4, r24	; 0x04
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c2e:	80 91 0d 80 	lds	r24, 0x800D
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
	addr[2] = IINCHIP_READ(SHAR2);
	addr[3] = IINCHIP_READ(SHAR3);
	addr[4] = IINCHIP_READ(SHAR4);
	addr[5] = IINCHIP_READ(SHAR5);
     c32:	85 83       	std	Z+5, r24	; 0x05
}
     c34:	08 95       	ret

00000c36 <setSHAR>:
void setSHAR(uint8 * addr)
{
     c36:	dc 01       	movw	r26, r24
     c38:	e8 e0       	ldi	r30, 0x08	; 8
     c3a:	f0 e8       	ldi	r31, 0x80	; 128
	uint8 k;

	for(k = 0; k < 6; k++) {
		IINCHIP_WRITE(SHAR+k, addr[k]);
     c3c:	8d 91       	ld	r24, X+
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     c3e:	81 93       	st	Z+, r24
}
void setSHAR(uint8 * addr)
{
	uint8 k;

	for(k = 0; k < 6; k++) {
     c40:	80 e8       	ldi	r24, 0x80	; 128
     c42:	ee 30       	cpi	r30, 0x0E	; 14
     c44:	f8 07       	cpc	r31, r24
     c46:	d1 f7       	brne	.-12     	; 0xc3c <setSHAR+0x6>
		IINCHIP_WRITE(SHAR+k, addr[k]);
	}
}
     c48:	08 95       	ret

00000c4a <getGAR>:
void getGAR(uint8 * addr)
{
     c4a:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c4c:	80 91 10 80 	lds	r24, 0x8010
		IINCHIP_WRITE(SHAR+k, addr[k]);
	}
}
void getGAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(GAR);
     c50:	80 83       	st	Z, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c52:	80 91 11 80 	lds	r24, 0x8011
	}
}
void getGAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(GAR);
	addr[1] = IINCHIP_READ(GAR1);
     c56:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c58:	80 91 12 80 	lds	r24, 0x8012
}
void getGAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(GAR);
	addr[1] = IINCHIP_READ(GAR1);
	addr[2] = IINCHIP_READ(GAR2);
     c5c:	82 83       	std	Z+2, r24	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c5e:	80 91 13 80 	lds	r24, 0x8013
void getGAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(GAR);
	addr[1] = IINCHIP_READ(GAR1);
	addr[2] = IINCHIP_READ(GAR2);
	addr[3] = IINCHIP_READ(GAR3);
     c62:	83 83       	std	Z+3, r24	; 0x03
}
     c64:	08 95       	ret

00000c66 <setGAR>:
void setGAR(uint8 * addr)
{
     c66:	fc 01       	movw	r30, r24
	IINCHIP_WRITE((GAR),addr[0]);
     c68:	80 81       	ld	r24, Z
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     c6a:	80 93 10 80 	sts	0x8010, r24
	addr[3] = IINCHIP_READ(GAR3);
}
void setGAR(uint8 * addr)
{
	IINCHIP_WRITE((GAR),addr[0]);
	IINCHIP_WRITE((GAR1),addr[1]);
     c6e:	81 81       	ldd	r24, Z+1	; 0x01
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     c70:	80 93 11 80 	sts	0x8011, r24
}
void setGAR(uint8 * addr)
{
	IINCHIP_WRITE((GAR),addr[0]);
	IINCHIP_WRITE((GAR1),addr[1]);
	IINCHIP_WRITE((GAR2),addr[2]);
     c74:	82 81       	ldd	r24, Z+2	; 0x02
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     c76:	80 93 12 80 	sts	0x8012, r24
void setGAR(uint8 * addr)
{
	IINCHIP_WRITE((GAR),addr[0]);
	IINCHIP_WRITE((GAR1),addr[1]);
	IINCHIP_WRITE((GAR2),addr[2]);
	IINCHIP_WRITE((GAR3),addr[3]);
     c7a:	83 81       	ldd	r24, Z+3	; 0x03
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     c7c:	80 93 13 80 	sts	0x8013, r24
{
	IINCHIP_WRITE((GAR),addr[0]);
	IINCHIP_WRITE((GAR1),addr[1]);
	IINCHIP_WRITE((GAR2),addr[2]);
	IINCHIP_WRITE((GAR3),addr[3]);
}
     c80:	08 95       	ret

00000c82 <getSUBR>:

void getSUBR(uint8 * addr)
{
     c82:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c84:	80 91 14 80 	lds	r24, 0x8014
	IINCHIP_WRITE((GAR3),addr[3]);
}

void getSUBR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SUBR);
     c88:	80 83       	st	Z, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c8a:	80 91 15 80 	lds	r24, 0x8015
}

void getSUBR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SUBR);
	addr[1] = IINCHIP_READ(SUBR1);
     c8e:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c90:	80 91 16 80 	lds	r24, 0x8016

void getSUBR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SUBR);
	addr[1] = IINCHIP_READ(SUBR1);
	addr[2] = IINCHIP_READ(SUBR2);
     c94:	82 83       	std	Z+2, r24	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     c96:	80 91 17 80 	lds	r24, 0x8017
void getSUBR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SUBR);
	addr[1] = IINCHIP_READ(SUBR1);
	addr[2] = IINCHIP_READ(SUBR2);
	addr[3] = IINCHIP_READ(SUBR3);
     c9a:	83 83       	std	Z+3, r24	; 0x03
}
     c9c:	08 95       	ret

00000c9e <setSUBR>:
void setSUBR(uint8 * addr)
{
     c9e:	fc 01       	movw	r30, r24
	IINCHIP_WRITE((SUBR),addr[0]);
     ca0:	80 81       	ld	r24, Z
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     ca2:	80 93 14 80 	sts	0x8014, r24
	addr[3] = IINCHIP_READ(SUBR3);
}
void setSUBR(uint8 * addr)
{
	IINCHIP_WRITE((SUBR),addr[0]);
	IINCHIP_WRITE((SUBR1),addr[1]);
     ca6:	81 81       	ldd	r24, Z+1	; 0x01
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     ca8:	80 93 15 80 	sts	0x8015, r24
}
void setSUBR(uint8 * addr)
{
	IINCHIP_WRITE((SUBR),addr[0]);
	IINCHIP_WRITE((SUBR1),addr[1]);
	IINCHIP_WRITE((SUBR2),addr[2]);
     cac:	82 81       	ldd	r24, Z+2	; 0x02
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     cae:	80 93 16 80 	sts	0x8016, r24
void setSUBR(uint8 * addr)
{
	IINCHIP_WRITE((SUBR),addr[0]);
	IINCHIP_WRITE((SUBR1),addr[1]);
	IINCHIP_WRITE((SUBR2),addr[2]);
	IINCHIP_WRITE((SUBR3),addr[3]);
     cb2:	83 81       	ldd	r24, Z+3	; 0x03
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     cb4:	80 93 17 80 	sts	0x8017, r24
{
	IINCHIP_WRITE((SUBR),addr[0]);
	IINCHIP_WRITE((SUBR1),addr[1]);
	IINCHIP_WRITE((SUBR2),addr[2]);
	IINCHIP_WRITE((SUBR3),addr[3]);
}
     cb8:	08 95       	ret

00000cba <getSIPR>:

void getSIPR(uint8 * addr)
{
     cba:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     cbc:	80 91 18 80 	lds	r24, 0x8018
	IINCHIP_WRITE((SUBR3),addr[3]);
}

void getSIPR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SIPR);
     cc0:	80 83       	st	Z, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     cc2:	80 91 19 80 	lds	r24, 0x8019
}

void getSIPR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SIPR);
	addr[1] = IINCHIP_READ(SIPR1);
     cc6:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     cc8:	80 91 1a 80 	lds	r24, 0x801A

void getSIPR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SIPR);
	addr[1] = IINCHIP_READ(SIPR1);
	addr[2] = IINCHIP_READ(SIPR2);
     ccc:	82 83       	std	Z+2, r24	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     cce:	80 91 1b 80 	lds	r24, 0x801B
void getSIPR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SIPR);
	addr[1] = IINCHIP_READ(SIPR1);
	addr[2] = IINCHIP_READ(SIPR2);
	addr[3] = IINCHIP_READ(SIPR3);
     cd2:	83 83       	std	Z+3, r24	; 0x03
}
     cd4:	08 95       	ret

00000cd6 <setSIPR>:
void setSIPR(uint8 * addr)
{
     cd6:	fc 01       	movw	r30, r24
	IINCHIP_WRITE((SIPR),addr[0]);
     cd8:	80 81       	ld	r24, Z
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     cda:	80 93 18 80 	sts	0x8018, r24
	addr[3] = IINCHIP_READ(SIPR3);
}
void setSIPR(uint8 * addr)
{
	IINCHIP_WRITE((SIPR),addr[0]);
	IINCHIP_WRITE((SIPR1),addr[1]);
     cde:	81 81       	ldd	r24, Z+1	; 0x01
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     ce0:	80 93 19 80 	sts	0x8019, r24
}
void setSIPR(uint8 * addr)
{
	IINCHIP_WRITE((SIPR),addr[0]);
	IINCHIP_WRITE((SIPR1),addr[1]);
	IINCHIP_WRITE((SIPR2),addr[2]);
     ce4:	82 81       	ldd	r24, Z+2	; 0x02
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     ce6:	80 93 1a 80 	sts	0x801A, r24
void setSIPR(uint8 * addr)
{
	IINCHIP_WRITE((SIPR),addr[0]);
	IINCHIP_WRITE((SIPR1),addr[1]);
	IINCHIP_WRITE((SIPR2),addr[2]);
	IINCHIP_WRITE((SIPR3),addr[3]);
     cea:	83 81       	ldd	r24, Z+3	; 0x03
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     cec:	80 93 1b 80 	sts	0x801B, r24
{
	IINCHIP_WRITE((SIPR),addr[0]);
	IINCHIP_WRITE((SIPR1),addr[1]);
	IINCHIP_WRITE((SIPR2),addr[2]);
	IINCHIP_WRITE((SIPR3),addr[3]);
}
     cf0:	08 95       	ret

00000cf2 <getRTR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     cf2:	40 91 1c 80 	lds	r20, 0x801C
/* Retransmittion */

uint16   getRTR(void)
{
   return ((IINCHIP_READ(RTR0) << 8) | IINCHIP_READ(RTR1));
}
     cf6:	20 91 1d 80 	lds	r18, 0x801D
     cfa:	94 2f       	mov	r25, r20
     cfc:	80 e0       	ldi	r24, 0x00	; 0
     cfe:	30 e0       	ldi	r19, 0x00	; 0
     d00:	28 2b       	or	r18, r24
     d02:	39 2b       	or	r19, r25
     d04:	c9 01       	movw	r24, r18
     d06:	08 95       	ret

00000d08 <setRTR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     d08:	90 93 1c 80 	sts	0x801C, r25
}
void     setRTR(uint16 timeout)
{
	IINCHIP_WRITE(RTR0, timeout >> 8);
	IINCHIP_WRITE(RTR1, timeout);
}
     d0c:	80 93 1d 80 	sts	0x801D, r24
     d10:	08 95       	ret

00000d12 <getRCR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d12:	80 91 1f 80 	lds	r24, 0x801F
}

uint8    getRCR(void)
{
   return (uint8)IINCHIP_READ(RCR);
}
     d16:	08 95       	ret

00000d18 <setRCR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     d18:	80 93 1f 80 	sts	0x801F, r24
   return (uint8)IINCHIP_READ(RCR);
}
void     setRCR(uint8 retry)
{
   IINCHIP_WRITE(RCR,retry);
}
     d1c:	08 95       	ret

00000d1e <getPATR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d1e:	40 91 32 80 	lds	r20, 0x8032

/* PPPoE */
uint16   getPATR(void)
{
   return ((IINCHIP_READ(PATR0) << 8) | IINCHIP_READ(PATR1));
}
     d22:	20 91 33 80 	lds	r18, 0x8033
     d26:	94 2f       	mov	r25, r20
     d28:	80 e0       	ldi	r24, 0x00	; 0
     d2a:	30 e0       	ldi	r19, 0x00	; 0
     d2c:	28 2b       	or	r18, r24
     d2e:	39 2b       	or	r19, r25
     d30:	c9 01       	movw	r24, r18
     d32:	08 95       	ret

00000d34 <getPTIMER>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d34:	80 91 36 80 	lds	r24, 0x8036
}

uint8    getPTIMER(void)
{
   return (uint8)IINCHIP_READ(PTIMER);
}
     d38:	08 95       	ret

00000d3a <setPTIMER>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     d3a:	80 93 36 80 	sts	0x8036, r24
   return (uint8)IINCHIP_READ(PTIMER);
}
void     setPTIMER(uint8 time)
{
   IINCHIP_WRITE(PTIMER,time);
}
     d3e:	08 95       	ret

00000d40 <getPMAGICR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d40:	80 91 38 80 	lds	r24, 0x8038
}

uint8    getPMAGICR(void)
{
   return (uint8)IINCHIP_READ(PMAGICR);
}
     d44:	08 95       	ret

00000d46 <setPMAGICR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     d46:	80 93 38 80 	sts	0x8038, r24
   return (uint8)IINCHIP_READ(PMAGICR);
}
void     setPMAGICR(uint8 magic)
{
   IINCHIP_WRITE(PMAGICR,magic);
}
     d4a:	08 95       	ret

00000d4c <getPSIDR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d4c:	40 91 3c 80 	lds	r20, 0x803C
}

uint16   getPSIDR(void)
{
   return ((IINCHIP_READ(PSIDR0) << 8) | IINCHIP_READ(PSIDR1));
}
     d50:	20 91 3d 80 	lds	r18, 0x803D
     d54:	94 2f       	mov	r25, r20
     d56:	80 e0       	ldi	r24, 0x00	; 0
     d58:	30 e0       	ldi	r19, 0x00	; 0
     d5a:	28 2b       	or	r18, r24
     d5c:	39 2b       	or	r19, r25
     d5e:	c9 01       	movw	r24, r18
     d60:	08 95       	ret

00000d62 <getPDHAR>:

void     getPDHAR(uint8* addr)
{
     d62:	dc 01       	movw	r26, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d64:	e0 e4       	ldi	r30, 0x40	; 64
     d66:	f0 e8       	ldi	r31, 0x80	; 128
     d68:	80 81       	ld	r24, Z
   return ((IINCHIP_READ(PSIDR0) << 8) | IINCHIP_READ(PSIDR1));
}

void     getPDHAR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
     d6a:	1c 92       	st	X, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d6c:	80 81       	ld	r24, Z
}

void     getPDHAR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
     d6e:	11 96       	adiw	r26, 0x01	; 1
     d70:	8c 93       	st	X, r24
     d72:	11 97       	sbiw	r26, 0x01	; 1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d74:	e2 e4       	ldi	r30, 0x42	; 66
     d76:	f0 e8       	ldi	r31, 0x80	; 128
     d78:	80 81       	ld	r24, Z

void     getPDHAR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   addr[2] = (uint8)(IINCHIP_READ(PDHAR2) >> 8);
     d7a:	12 96       	adiw	r26, 0x02	; 2
     d7c:	1c 92       	st	X, r1
     d7e:	12 97       	sbiw	r26, 0x02	; 2
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d80:	80 81       	ld	r24, Z
void     getPDHAR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   addr[2] = (uint8)(IINCHIP_READ(PDHAR2) >> 8);
   addr[3] = (uint8)IINCHIP_READ(PDHAR2);
     d82:	13 96       	adiw	r26, 0x03	; 3
     d84:	8c 93       	st	X, r24
     d86:	13 97       	sbiw	r26, 0x03	; 3
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d88:	e4 e4       	ldi	r30, 0x44	; 68
     d8a:	f0 e8       	ldi	r31, 0x80	; 128
     d8c:	80 81       	ld	r24, Z
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   addr[2] = (uint8)(IINCHIP_READ(PDHAR2) >> 8);
   addr[3] = (uint8)IINCHIP_READ(PDHAR2);
   addr[4] = (uint8)(IINCHIP_READ(PDHAR4) >> 8);
     d8e:	14 96       	adiw	r26, 0x04	; 4
     d90:	1c 92       	st	X, r1
     d92:	14 97       	sbiw	r26, 0x04	; 4
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d94:	80 81       	ld	r24, Z
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   addr[2] = (uint8)(IINCHIP_READ(PDHAR2) >> 8);
   addr[3] = (uint8)IINCHIP_READ(PDHAR2);
   addr[4] = (uint8)(IINCHIP_READ(PDHAR4) >> 8);
   addr[5] = (uint8)IINCHIP_READ(PDHAR4);
     d96:	15 96       	adiw	r26, 0x05	; 5
     d98:	8c 93       	st	X, r24
}
     d9a:	08 95       	ret

00000d9c <getUIPR>:


/* ICMP packets */

void     getUIPR(uint8* addr)
{
     d9c:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     d9e:	a8 e4       	ldi	r26, 0x48	; 72
     da0:	b0 e8       	ldi	r27, 0x80	; 128
     da2:	8c 91       	ld	r24, X

/* ICMP packets */

void     getUIPR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(UIPR) >> 8);
     da4:	10 82       	st	Z, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     da6:	8c 91       	ld	r24, X
/* ICMP packets */

void     getUIPR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(UIPR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(UIPR);
     da8:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     daa:	aa e4       	ldi	r26, 0x4A	; 74
     dac:	b0 e8       	ldi	r27, 0x80	; 128
     dae:	8c 91       	ld	r24, X

void     getUIPR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(UIPR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(UIPR);
   addr[2] = (uint8)(IINCHIP_READ(UIPR2) >> 8);
     db0:	12 82       	std	Z+2, r1	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     db2:	8c 91       	ld	r24, X
void     getUIPR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(UIPR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(UIPR);
   addr[2] = (uint8)(IINCHIP_READ(UIPR2) >> 8);
   addr[3] = (uint8)IINCHIP_READ(UIPR2);   
     db4:	83 83       	std	Z+3, r24	; 0x03
}
     db6:	08 95       	ret

00000db8 <getUPORTR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     db8:	40 91 4c 80 	lds	r20, 0x804C
}

uint16   getUPORTR(void)
{
   return ((IINCHIP_READ(UPORTR0) << 8) | IINCHIP_READ(UPORTR1));
}
     dbc:	20 91 4d 80 	lds	r18, 0x804D
     dc0:	94 2f       	mov	r25, r20
     dc2:	80 e0       	ldi	r24, 0x00	; 0
     dc4:	30 e0       	ldi	r19, 0x00	; 0
     dc6:	28 2b       	or	r18, r24
     dc8:	39 2b       	or	r19, r25
     dca:	c9 01       	movw	r24, r18
     dcc:	08 95       	ret

00000dce <getFMTUR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     dce:	40 91 4e 80 	lds	r20, 0x804E
}

uint16   getFMTUR(void)
{
   return ((IINCHIP_READ(FMTUR0) << 8) | IINCHIP_READ(FMTUR1));
}
     dd2:	20 91 4f 80 	lds	r18, 0x804F
     dd6:	94 2f       	mov	r25, r20
     dd8:	80 e0       	ldi	r24, 0x00	; 0
     dda:	30 e0       	ldi	r19, 0x00	; 0
     ddc:	28 2b       	or	r18, r24
     dde:	39 2b       	or	r19, r25
     de0:	c9 01       	movw	r24, r18
     de2:	08 95       	ret

00000de4 <getPn_BRDYR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     de4:	e8 2f       	mov	r30, r24
     de6:	f0 e0       	ldi	r31, 0x00	; 0
     de8:	e8 5e       	subi	r30, 0xE8	; 232
     dea:	ff 4d       	sbci	r31, 0xDF	; 223
     dec:	ee 0f       	add	r30, r30
     dee:	ff 1f       	adc	r31, r31
     df0:	ee 0f       	add	r30, r30
     df2:	ff 1f       	adc	r31, r31
     df4:	80 81       	ld	r24, Z
/* PIN "BRYDn" */

uint8    getPn_BRDYR(uint8 p)
{
   return (uint8)IINCHIP_READ(Pn_BRDYR(p));
}
     df6:	08 95       	ret

00000df8 <setPn_BRDYR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     df8:	e8 2f       	mov	r30, r24
     dfa:	f0 e0       	ldi	r31, 0x00	; 0
     dfc:	e8 5e       	subi	r30, 0xE8	; 232
     dfe:	ff 4d       	sbci	r31, 0xDF	; 223
     e00:	ee 0f       	add	r30, r30
     e02:	ff 1f       	adc	r31, r31
     e04:	ee 0f       	add	r30, r30
     e06:	ff 1f       	adc	r31, r31
     e08:	60 83       	st	Z, r22
   return (uint8)IINCHIP_READ(Pn_BRDYR(p));
}
void     setPn_BRDYR(uint8 p, uint8 cfg)
{
   IINCHIP_WRITE(Pn_BRDYR(p),cfg);   
}
     e0a:	08 95       	ret

00000e0c <getPn_BDPTHR>:


uint16   getPn_BDPTHR(uint8 p)
{
   return ((IINCHIP_READ(Pn_BDPTHR0(p) << 8)) | IINCHIP_READ(Pn_BDPTHR1(p)));   
     e0c:	e8 2f       	mov	r30, r24
     e0e:	f0 e0       	ldi	r31, 0x00	; 0
     e10:	ee 0f       	add	r30, r30
     e12:	ff 1f       	adc	r31, r31
     e14:	ee 0f       	add	r30, r30
     e16:	ff 1f       	adc	r31, r31
     e18:	ee 59       	subi	r30, 0x9E	; 158
     e1a:	ff 47       	sbci	r31, 0x7F	; 127
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     e1c:	be 2f       	mov	r27, r30
     e1e:	aa 27       	eor	r26, r26
     e20:	9c 91       	ld	r25, X


uint16   getPn_BDPTHR(uint8 p)
{
   return ((IINCHIP_READ(Pn_BDPTHR0(p) << 8)) | IINCHIP_READ(Pn_BDPTHR1(p)));   
}
     e22:	81 81       	ldd	r24, Z+1	; 0x01
     e24:	89 2b       	or	r24, r25
     e26:	90 e0       	ldi	r25, 0x00	; 0
     e28:	08 95       	ret

00000e2a <setPn_BDPTHR>:
void     setPn_BDPTHR(uint8 p, uint16 depth)
{
   IINCHIP_WRITE(Pn_BDPTHR0(p),depth >> 8);
     e2a:	e8 2f       	mov	r30, r24
     e2c:	f0 e0       	ldi	r31, 0x00	; 0
     e2e:	ee 0f       	add	r30, r30
     e30:	ff 1f       	adc	r31, r31
     e32:	ee 0f       	add	r30, r30
     e34:	ff 1f       	adc	r31, r31
     e36:	ee 59       	subi	r30, 0x9E	; 158
     e38:	ff 47       	sbci	r31, 0x7F	; 127
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     e3a:	70 83       	st	Z, r23
}
void     setPn_BDPTHR(uint8 p, uint16 depth)
{
   IINCHIP_WRITE(Pn_BDPTHR0(p),depth >> 8);
   IINCHIP_WRITE(Pn_BDPTHR1(p),depth);
}
     e3c:	61 83       	std	Z+1, r22	; 0x01
     e3e:	08 95       	ret

00000e40 <getIDR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     e40:	40 91 fe 80 	lds	r20, 0x80FE

/* IINCHIP ID */
uint16   getIDR(void)
{
   return ((IINCHIP_READ(IDR) << 8) | IINCHIP_READ(IDR1));
}
     e44:	20 91 ff 80 	lds	r18, 0x80FF
     e48:	94 2f       	mov	r25, r20
     e4a:	80 e0       	ldi	r24, 0x00	; 0
     e4c:	30 e0       	ldi	r19, 0x00	; 0
     e4e:	28 2b       	or	r18, r24
     e50:	39 2b       	or	r19, r25
     e52:	c9 01       	movw	r24, r18
     e54:	08 95       	ret

00000e56 <getSn_MR>:

/* SOCKET control */

uint16   getSn_MR(SOCKET s)
{
   return ((IINCHIP_READ(Sn_MR_(s) << 8) | IINCHIP_READ(Sn_MR(s))));
     e56:	e8 2f       	mov	r30, r24
     e58:	f0 e0       	ldi	r31, 0x00	; 0
     e5a:	e8 5f       	subi	r30, 0xF8	; 248
     e5c:	fd 4f       	sbci	r31, 0xFD	; 253
     e5e:	66 e0       	ldi	r22, 0x06	; 6
     e60:	ee 0f       	add	r30, r30
     e62:	ff 1f       	adc	r31, r31
     e64:	6a 95       	dec	r22
     e66:	e1 f7       	brne	.-8      	; 0xe60 <getSn_MR+0xa>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     e68:	be 2f       	mov	r27, r30
     e6a:	aa 27       	eor	r26, r26
     e6c:	9c 91       	ld	r25, X
/* SOCKET control */

uint16   getSn_MR(SOCKET s)
{
   return ((IINCHIP_READ(Sn_MR_(s) << 8) | IINCHIP_READ(Sn_MR(s))));
}
     e6e:	81 81       	ldd	r24, Z+1	; 0x01
     e70:	89 2b       	or	r24, r25
     e72:	90 e0       	ldi	r25, 0x00	; 0
     e74:	08 95       	ret

00000e76 <setSn_MR>:
void     setSn_MR(SOCKET s, uint16 mode)
{
   IINCHIP_WRITE(Sn_MR_(s),mode >> 8);
     e76:	e8 2f       	mov	r30, r24
     e78:	f0 e0       	ldi	r31, 0x00	; 0
     e7a:	e8 5f       	subi	r30, 0xF8	; 248
     e7c:	fd 4f       	sbci	r31, 0xFD	; 253
     e7e:	a6 e0       	ldi	r26, 0x06	; 6
     e80:	ee 0f       	add	r30, r30
     e82:	ff 1f       	adc	r31, r31
     e84:	aa 95       	dec	r26
     e86:	e1 f7       	brne	.-8      	; 0xe80 <setSn_MR+0xa>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     e88:	70 83       	st	Z, r23
}
void     setSn_MR(SOCKET s, uint16 mode)
{
   IINCHIP_WRITE(Sn_MR_(s),mode >> 8);
   IINCHIP_WRITE(Sn_MR(s),mode);
}
     e8a:	61 83       	std	Z+1, r22	; 0x01
     e8c:	08 95       	ret

00000e8e <getSn_CR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     e8e:	e8 2f       	mov	r30, r24
     e90:	f0 e0       	ldi	r31, 0x00	; 0
     e92:	b6 e0       	ldi	r27, 0x06	; 6
     e94:	ee 0f       	add	r30, r30
     e96:	ff 1f       	adc	r31, r31
     e98:	ba 95       	dec	r27
     e9a:	e1 f7       	brne	.-8      	; 0xe94 <getSn_CR+0x6>
     e9c:	ee 5f       	subi	r30, 0xFE	; 254
     e9e:	fd 47       	sbci	r31, 0x7D	; 125
     ea0:	81 81       	ldd	r24, Z+1	; 0x01
}

uint8    getSn_CR(SOCKET s)
{
   return IINCHIP_READ(Sn_CR(s));
}
     ea2:	08 95       	ret

00000ea4 <setSn_CR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     ea4:	e8 2f       	mov	r30, r24
     ea6:	f0 e0       	ldi	r31, 0x00	; 0
     ea8:	86 e0       	ldi	r24, 0x06	; 6
     eaa:	ee 0f       	add	r30, r30
     eac:	ff 1f       	adc	r31, r31
     eae:	8a 95       	dec	r24
     eb0:	e1 f7       	brne	.-8      	; 0xeaa <setSn_CR+0x6>
     eb2:	ee 5f       	subi	r30, 0xFE	; 254
     eb4:	fd 47       	sbci	r31, 0x7D	; 125
     eb6:	df 01       	movw	r26, r30
     eb8:	11 96       	adiw	r26, 0x01	; 1
     eba:	71 83       	std	Z+1, r23	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     ebc:	61 83       	std	Z+1, r22	; 0x01
     ebe:	8c 91       	ld	r24, X
}
void     setSn_CR(SOCKET s, uint16 com)
{
   IINCHIP_WRITE(Sn_CR(s),com >> 8);
   IINCHIP_WRITE(Sn_CR(s),com);
   while(IINCHIP_READ(Sn_CR(s))); // wait until Sn_CR is cleared.
     ec0:	88 23       	and	r24, r24
     ec2:	e9 f7       	brne	.-6      	; 0xebe <setSn_CR+0x1a>
}
     ec4:	08 95       	ret

00000ec6 <getSn_IMR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     ec6:	e8 2f       	mov	r30, r24
     ec8:	f0 e0       	ldi	r31, 0x00	; 0
     eca:	96 e0       	ldi	r25, 0x06	; 6
     ecc:	ee 0f       	add	r30, r30
     ece:	ff 1f       	adc	r31, r31
     ed0:	9a 95       	dec	r25
     ed2:	e1 f7       	brne	.-8      	; 0xecc <getSn_IMR+0x6>
     ed4:	ec 5f       	subi	r30, 0xFC	; 252
     ed6:	fd 47       	sbci	r31, 0x7D	; 125
     ed8:	81 81       	ldd	r24, Z+1	; 0x01
}

uint8    getSn_IMR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_IMR(s));
}
     eda:	08 95       	ret

00000edc <setSn_IMR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     edc:	e8 2f       	mov	r30, r24
     ede:	f0 e0       	ldi	r31, 0x00	; 0
     ee0:	26 e0       	ldi	r18, 0x06	; 6
     ee2:	ee 0f       	add	r30, r30
     ee4:	ff 1f       	adc	r31, r31
     ee6:	2a 95       	dec	r18
     ee8:	e1 f7       	brne	.-8      	; 0xee2 <setSn_IMR+0x6>
     eea:	ec 5f       	subi	r30, 0xFC	; 252
     eec:	fd 47       	sbci	r31, 0x7D	; 125
     eee:	61 83       	std	Z+1, r22	; 0x01
   return (uint8)IINCHIP_READ(Sn_IMR(s));
}
void     setSn_IMR(SOCKET s, uint8 mask)
{
   IINCHIP_WRITE(Sn_IMR(s),mask);
}
     ef0:	08 95       	ret

00000ef2 <getSn_IR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     ef2:	e8 2f       	mov	r30, r24
     ef4:	f0 e0       	ldi	r31, 0x00	; 0
     ef6:	e8 5f       	subi	r30, 0xF8	; 248
     ef8:	fd 4f       	sbci	r31, 0xFD	; 253
     efa:	36 e0       	ldi	r19, 0x06	; 6
     efc:	ee 0f       	add	r30, r30
     efe:	ff 1f       	adc	r31, r31
     f00:	3a 95       	dec	r19
     f02:	e1 f7       	brne	.-8      	; 0xefc <getSn_IR+0xa>
     f04:	87 81       	ldd	r24, Z+7	; 0x07
   #ifdef __DEF_IINCHIP_INT__    // In case of using ISR routine of iinchip
      return (uint8)IINCHIP_READ(Sn_IR(s));
   #else                         // In case of processing directly
      return (uint8)IINCHIP_READ(Sn_IR(s));
   #endif   
}
     f06:	08 95       	ret

00000f08 <setSn_IR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     f08:	e8 2f       	mov	r30, r24
     f0a:	f0 e0       	ldi	r31, 0x00	; 0
     f0c:	e8 5f       	subi	r30, 0xF8	; 248
     f0e:	fd 4f       	sbci	r31, 0xFD	; 253
     f10:	46 e0       	ldi	r20, 0x06	; 6
     f12:	ee 0f       	add	r30, r30
     f14:	ff 1f       	adc	r31, r31
     f16:	4a 95       	dec	r20
     f18:	e1 f7       	brne	.-8      	; 0xf12 <setSn_IR+0xa>
     f1a:	67 83       	std	Z+7, r22	; 0x07
   #ifdef __DEF_IINCHIP_INT__    // In case of using ISR routine of iinchip
      IINCHIP_WRITE(Sn_IR(s),ir);
   #else                         // In case of processing directly
      IINCHIP_WRITE(Sn_IR(s),ir);
   #endif   
}
     f1c:	08 95       	ret

00000f1e <getSn_SSR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     f1e:	e8 2f       	mov	r30, r24
     f20:	f0 e0       	ldi	r31, 0x00	; 0
     f22:	56 e0       	ldi	r21, 0x06	; 6
     f24:	ee 0f       	add	r30, r30
     f26:	ff 1f       	adc	r31, r31
     f28:	5a 95       	dec	r21
     f2a:	e1 f7       	brne	.-8      	; 0xf24 <getSn_SSR+0x6>
     f2c:	e8 5f       	subi	r30, 0xF8	; 248
     f2e:	fd 47       	sbci	r31, 0x7D	; 125
     f30:	df 01       	movw	r26, r30
     f32:	11 96       	adiw	r26, 0x01	; 1
     f34:	81 81       	ldd	r24, Z+1	; 0x01
   ssr = (uint8)IINCHIP_READ(Sn_SSR(s));     // first read

   while(1)
   {
      ssr1 = (uint8)IINCHIP_READ(Sn_SSR(s)); // second read
      if(ssr == ssr1) break;                 // if first == sencond, Sn_SSR value is valid.
     f36:	9c 91       	ld	r25, X
     f38:	89 17       	cp	r24, r25
     f3a:	11 f0       	breq	.+4      	; 0xf40 <getSn_SSR+0x22>
     f3c:	89 2f       	mov	r24, r25
     f3e:	fb cf       	rjmp	.-10     	; 0xf36 <getSn_SSR+0x18>
      ssr = ssr1;                            // if first <> second, save second value into first.
   }
   return ssr;
}
     f40:	08 95       	ret

00000f42 <getSn_DHAR>:

void     getSn_DHAR(SOCKET s, uint8* addr)
{
     f42:	cf 93       	push	r28
     f44:	df 93       	push	r29
     f46:	9b 01       	movw	r18, r22
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
     f48:	e8 2f       	mov	r30, r24
     f4a:	f0 e0       	ldi	r31, 0x00	; 0
     f4c:	e8 5f       	subi	r30, 0xF8	; 248
     f4e:	fd 4f       	sbci	r31, 0xFD	; 253
     f50:	df 01       	movw	r26, r30
     f52:	66 e0       	ldi	r22, 0x06	; 6
     f54:	aa 0f       	add	r26, r26
     f56:	bb 1f       	adc	r27, r27
     f58:	6a 95       	dec	r22
     f5a:	e1 f7       	brne	.-8      	; 0xf54 <getSn_DHAR+0x12>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     f5c:	1c 96       	adiw	r26, 0x0c	; 12
     f5e:	8c 91       	ld	r24, X
     f60:	1c 97       	sbiw	r26, 0x0c	; 12
   return ssr;
}

void     getSn_DHAR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
     f62:	e9 01       	movw	r28, r18
     f64:	18 82       	st	Y, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     f66:	1c 96       	adiw	r26, 0x0c	; 12
     f68:	8c 91       	ld	r24, X
     f6a:	1c 97       	sbiw	r26, 0x0c	; 12
}

void     getSn_DHAR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
     f6c:	89 83       	std	Y+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     f6e:	1e 96       	adiw	r26, 0x0e	; 14
     f70:	8c 91       	ld	r24, X
     f72:	1e 97       	sbiw	r26, 0x0e	; 14

void     getSn_DHAR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DHAR2(s))>>8);
     f74:	1a 82       	std	Y+2, r1	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     f76:	1e 96       	adiw	r26, 0x0e	; 14
     f78:	8c 91       	ld	r24, X
     f7a:	1e 97       	sbiw	r26, 0x0e	; 14
void     getSn_DHAR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DHAR2(s))>>8);
   addr[3] = (uint8)IINCHIP_READ(Sn_DHAR2(s));
     f7c:	8b 83       	std	Y+3, r24	; 0x03
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     f7e:	fd 01       	movw	r30, r26
     f80:	70 96       	adiw	r30, 0x10	; 16
     f82:	80 81       	ld	r24, Z
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DHAR2(s))>>8);
   addr[3] = (uint8)IINCHIP_READ(Sn_DHAR2(s));
   addr[4] = (uint8)(IINCHIP_READ(Sn_DHAR4(s))>>8);
     f84:	1c 82       	std	Y+4, r1	; 0x04
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     f86:	80 81       	ld	r24, Z
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DHAR2(s))>>8);
   addr[3] = (uint8)IINCHIP_READ(Sn_DHAR2(s));
   addr[4] = (uint8)(IINCHIP_READ(Sn_DHAR4(s))>>8);
   addr[5] = (uint8)IINCHIP_READ(Sn_DHAR4(s));
     f88:	8d 83       	std	Y+5, r24	; 0x05
}
     f8a:	df 91       	pop	r29
     f8c:	cf 91       	pop	r28
     f8e:	08 95       	ret

00000f90 <setSn_DHAR>:

void     setSn_DHAR(SOCKET s, uint8* addr)
{
     f90:	cf 93       	push	r28
     f92:	df 93       	push	r29
     f94:	db 01       	movw	r26, r22
   IINCHIP_WRITE(Sn_DHAR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
     f96:	e8 2f       	mov	r30, r24
     f98:	f0 e0       	ldi	r31, 0x00	; 0
     f9a:	e8 5f       	subi	r30, 0xF8	; 248
     f9c:	fd 4f       	sbci	r31, 0xFD	; 253
     f9e:	9f 01       	movw	r18, r30
     fa0:	76 e0       	ldi	r23, 0x06	; 6
     fa2:	22 0f       	add	r18, r18
     fa4:	33 1f       	adc	r19, r19
     fa6:	7a 95       	dec	r23
     fa8:	e1 f7       	brne	.-8      	; 0xfa2 <setSn_DHAR+0x12>
     faa:	11 96       	adiw	r26, 0x01	; 1
     fac:	8c 91       	ld	r24, X
     fae:	11 97       	sbiw	r26, 0x01	; 1
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     fb0:	e9 01       	movw	r28, r18
     fb2:	8c 87       	std	Y+12, r24	; 0x0c
}

void     setSn_DHAR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DHAR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DHAR2(s), ((uint16)(addr[2]<<8)) + addr[3]);
     fb4:	13 96       	adiw	r26, 0x03	; 3
     fb6:	8c 91       	ld	r24, X
     fb8:	13 97       	sbiw	r26, 0x03	; 3
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     fba:	8e 87       	std	Y+14, r24	; 0x0e

void     setSn_DHAR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DHAR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DHAR2(s), ((uint16)(addr[2]<<8)) + addr[3]);
   IINCHIP_WRITE(Sn_DHAR4(s), ((uint16)(addr[4]<<8)) + addr[5]);
     fbc:	15 96       	adiw	r26, 0x05	; 5
     fbe:	8c 91       	ld	r24, X
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     fc0:	f9 01       	movw	r30, r18
     fc2:	70 96       	adiw	r30, 0x10	; 16
     fc4:	80 83       	st	Z, r24
void     setSn_DHAR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DHAR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DHAR2(s), ((uint16)(addr[2]<<8)) + addr[3]);
   IINCHIP_WRITE(Sn_DHAR4(s), ((uint16)(addr[4]<<8)) + addr[5]);
}
     fc6:	df 91       	pop	r29
     fc8:	cf 91       	pop	r28
     fca:	08 95       	ret

00000fcc <setSn_DPORTR>:
//}


void     setSn_DPORTR(SOCKET s, uint16 port)
{
 	 IINCHIP_WRITE(Sn_DPORTR0(s), port >> 8);
     fcc:	e8 2f       	mov	r30, r24
     fce:	f0 e0       	ldi	r31, 0x00	; 0
     fd0:	e8 5f       	subi	r30, 0xF8	; 248
     fd2:	fd 4f       	sbci	r31, 0xFD	; 253
     fd4:	a6 e0       	ldi	r26, 0x06	; 6
     fd6:	ee 0f       	add	r30, r30
     fd8:	ff 1f       	adc	r31, r31
     fda:	aa 95       	dec	r26
     fdc:	e1 f7       	brne	.-8      	; 0xfd6 <setSn_DPORTR+0xa>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
     fde:	72 8b       	std	Z+18, r23	; 0x12

void     setSn_DPORTR(SOCKET s, uint16 port)
{
 	 IINCHIP_WRITE(Sn_DPORTR0(s), port >> 8);
	 IINCHIP_WRITE(Sn_DPORTR1(s), port);
}
     fe0:	63 8b       	std	Z+19, r22	; 0x13
     fe2:	08 95       	ret

00000fe4 <getSn_DIPR>:

void     getSn_DIPR(SOCKET s, uint8* addr)
{
     fe4:	db 01       	movw	r26, r22
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
     fe6:	e8 2f       	mov	r30, r24
     fe8:	f0 e0       	ldi	r31, 0x00	; 0
     fea:	e8 5f       	subi	r30, 0xF8	; 248
     fec:	fd 4f       	sbci	r31, 0xFD	; 253
     fee:	86 e0       	ldi	r24, 0x06	; 6
     ff0:	ee 0f       	add	r30, r30
     ff2:	ff 1f       	adc	r31, r31
     ff4:	8a 95       	dec	r24
     ff6:	e1 f7       	brne	.-8      	; 0xff0 <getSn_DIPR+0xc>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     ff8:	84 89       	ldd	r24, Z+20	; 0x14
	 IINCHIP_WRITE(Sn_DPORTR1(s), port);
}

void     getSn_DIPR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
     ffa:	1c 92       	st	X, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
     ffc:	84 89       	ldd	r24, Z+20	; 0x14
}

void     getSn_DIPR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DIPR(s));
     ffe:	11 96       	adiw	r26, 0x01	; 1
    1000:	8c 93       	st	X, r24
    1002:	11 97       	sbiw	r26, 0x01	; 1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1004:	86 89       	ldd	r24, Z+22	; 0x16

void     getSn_DIPR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DIPR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DIPR2(s))>>8);
    1006:	12 96       	adiw	r26, 0x02	; 2
    1008:	1c 92       	st	X, r1
    100a:	12 97       	sbiw	r26, 0x02	; 2
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    100c:	86 89       	ldd	r24, Z+22	; 0x16
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DIPR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DIPR2(s))>>8);
// M_15052008 : Replace Sn_DHAR2 with Sn_DIPR.   
// addr[3] = (uint8)IINCHIP_READ(Sn_DHAR2(s));   
   addr[3] = (uint8)IINCHIP_READ(Sn_DIPR2(s));   
    100e:	13 96       	adiw	r26, 0x03	; 3
    1010:	8c 93       	st	X, r24
}
    1012:	08 95       	ret

00001014 <setSn_DIPR>:
void     setSn_DIPR(SOCKET s, uint8* addr)
{
    1014:	db 01       	movw	r26, r22
   IINCHIP_WRITE(Sn_DIPR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
    1016:	e8 2f       	mov	r30, r24
    1018:	f0 e0       	ldi	r31, 0x00	; 0
    101a:	e8 5f       	subi	r30, 0xF8	; 248
    101c:	fd 4f       	sbci	r31, 0xFD	; 253
    101e:	96 e0       	ldi	r25, 0x06	; 6
    1020:	ee 0f       	add	r30, r30
    1022:	ff 1f       	adc	r31, r31
    1024:	9a 95       	dec	r25
    1026:	e1 f7       	brne	.-8      	; 0x1020 <setSn_DIPR+0xc>
    1028:	11 96       	adiw	r26, 0x01	; 1
    102a:	8c 91       	ld	r24, X
    102c:	11 97       	sbiw	r26, 0x01	; 1
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    102e:	84 8b       	std	Z+20, r24	; 0x14
   addr[3] = (uint8)IINCHIP_READ(Sn_DIPR2(s));   
}
void     setSn_DIPR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DIPR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DIPR2(s), ((uint16)(addr[2]<<8)) + addr[3]);  
    1030:	13 96       	adiw	r26, 0x03	; 3
    1032:	8c 91       	ld	r24, X
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    1034:	86 8b       	std	Z+22, r24	; 0x16
}
void     setSn_DIPR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DIPR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DIPR2(s), ((uint16)(addr[2]<<8)) + addr[3]);  
}
    1036:	08 95       	ret

00001038 <getSn_MSSR>:

uint16   getSn_MSSR(SOCKET s)
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_MSSR0(s)) << 8;
    1038:	e8 2f       	mov	r30, r24
    103a:	f0 e0       	ldi	r31, 0x00	; 0
    103c:	e8 5f       	subi	r30, 0xF8	; 248
    103e:	fd 4f       	sbci	r31, 0xFD	; 253
    1040:	26 e0       	ldi	r18, 0x06	; 6
    1042:	ee 0f       	add	r30, r30
    1044:	ff 1f       	adc	r31, r31
    1046:	2a 95       	dec	r18
    1048:	e1 f7       	brne	.-8      	; 0x1042 <getSn_MSSR+0xa>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    104a:	20 8d       	ldd	r18, Z+24	; 0x18
}

uint16   getSn_MSSR(SOCKET s)
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_MSSR0(s)) << 8;
    104c:	92 2f       	mov	r25, r18
    104e:	80 e0       	ldi	r24, 0x00	; 0
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1050:	21 8d       	ldd	r18, Z+25	; 0x19
    1052:	30 e0       	ldi	r19, 0x00	; 0
    1054:	28 2b       	or	r18, r24
    1056:	39 2b       	or	r19, r25
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_MSSR0(s)) << 8;
	 ret |= IINCHIP_READ(Sn_MSSR1(s));
   return ret;
}
    1058:	c9 01       	movw	r24, r18
    105a:	08 95       	ret

0000105c <setSn_MSSR>:

void     setSn_MSSR(SOCKET s, uint16 mss)
{
   IINCHIP_WRITE(Sn_MSSR0(s), mss >> 8);
    105c:	e8 2f       	mov	r30, r24
    105e:	f0 e0       	ldi	r31, 0x00	; 0
    1060:	e8 5f       	subi	r30, 0xF8	; 248
    1062:	fd 4f       	sbci	r31, 0xFD	; 253
    1064:	36 e0       	ldi	r19, 0x06	; 6
    1066:	ee 0f       	add	r30, r30
    1068:	ff 1f       	adc	r31, r31
    106a:	3a 95       	dec	r19
    106c:	e1 f7       	brne	.-8      	; 0x1066 <setSn_MSSR+0xa>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    106e:	70 8f       	std	Z+24, r23	; 0x18

void     setSn_MSSR(SOCKET s, uint16 mss)
{
   IINCHIP_WRITE(Sn_MSSR0(s), mss >> 8);
   IINCHIP_WRITE(Sn_MSSR1(s), mss);
}
    1070:	61 8f       	std	Z+25, r22	; 0x19
    1072:	08 95       	ret

00001074 <getSn_KPALVTR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1074:	e8 2f       	mov	r30, r24
    1076:	f0 e0       	ldi	r31, 0x00	; 0
    1078:	e8 5f       	subi	r30, 0xF8	; 248
    107a:	fd 4f       	sbci	r31, 0xFD	; 253
    107c:	46 e0       	ldi	r20, 0x06	; 6
    107e:	ee 0f       	add	r30, r30
    1080:	ff 1f       	adc	r31, r31
    1082:	4a 95       	dec	r20
    1084:	e1 f7       	brne	.-8      	; 0x107e <getSn_KPALVTR+0xa>
    1086:	83 8d       	ldd	r24, Z+27	; 0x1b
/* SOCKET communication */

uint8    getSn_KPALVTR(SOCKET s)
{
   return (uint8)(IINCHIP_READ(Sn_KPALVTR(s)) >> 8);
}
    1088:	80 e0       	ldi	r24, 0x00	; 0
    108a:	08 95       	ret

0000108c <setSn_KPALVTR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    108c:	e8 2f       	mov	r30, r24
    108e:	f0 e0       	ldi	r31, 0x00	; 0
    1090:	e8 5f       	subi	r30, 0xF8	; 248
    1092:	fd 4f       	sbci	r31, 0xFD	; 253
    1094:	56 e0       	ldi	r21, 0x06	; 6
    1096:	ee 0f       	add	r30, r30
    1098:	ff 1f       	adc	r31, r31
    109a:	5a 95       	dec	r21
    109c:	e1 f7       	brne	.-8      	; 0x1096 <setSn_KPALVTR+0xa>
    109e:	23 8d       	ldd	r18, Z+27	; 0x1b

void     setSn_KPALVTR(SOCKET s, uint8 time)
{
   uint16 keepalive=0;
   keepalive = (IINCHIP_READ(Sn_KPALVTR(s)) & 0x00FF) + ((uint16)time<<8);
   IINCHIP_WRITE(Sn_KPALVTR(s),keepalive);
    10a0:	96 2f       	mov	r25, r22
    10a2:	80 e0       	ldi	r24, 0x00	; 0
    10a4:	82 0f       	add	r24, r18
    10a6:	91 1d       	adc	r25, r1
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    10a8:	83 8f       	std	Z+27, r24	; 0x1b
void     setSn_KPALVTR(SOCKET s, uint8 time)
{
   uint16 keepalive=0;
   keepalive = (IINCHIP_READ(Sn_KPALVTR(s)) & 0x00FF) + ((uint16)time<<8);
   IINCHIP_WRITE(Sn_KPALVTR(s),keepalive);
}
    10aa:	08 95       	ret

000010ac <getSn_TX_WRSR>:
	union {
		uint32 s32;
		uint8 s8[4];
	} u32;

	u32.s8[3] = IINCHIP_READ(Sn_TX_WRSR(s));
    10ac:	e8 2f       	mov	r30, r24
    10ae:	f0 e0       	ldi	r31, 0x00	; 0
    10b0:	ee 0f       	add	r30, r30
    10b2:	ff 1f       	adc	r31, r31
    10b4:	ef 5e       	subi	r30, 0xEF	; 239
    10b6:	fb 4f       	sbci	r31, 0xFB	; 251
    10b8:	df 01       	movw	r26, r30
    10ba:	65 e0       	ldi	r22, 0x05	; 5
    10bc:	aa 0f       	add	r26, r26
    10be:	bb 1f       	adc	r27, r27
    10c0:	6a 95       	dec	r22
    10c2:	e1 f7       	brne	.-8      	; 0x10bc <getSn_TX_WRSR+0x10>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    10c4:	9c 91       	ld	r25, X
	u32.s8[2] = IINCHIP_READ(Sn_TX_WRSR1(s));
	u32.s8[1] = IINCHIP_READ(Sn_TX_WRSR2(s));
	u32.s8[0] = IINCHIP_READ(Sn_TX_WRSR3(s));

	return u32.s32;
}
    10c6:	11 96       	adiw	r26, 0x01	; 1
    10c8:	8c 91       	ld	r24, X
    10ca:	11 97       	sbiw	r26, 0x01	; 1
    10cc:	fd 01       	movw	r30, r26
    10ce:	32 96       	adiw	r30, 0x02	; 2
    10d0:	70 81       	ld	r23, Z
    10d2:	13 96       	adiw	r26, 0x03	; 3
    10d4:	6c 91       	ld	r22, X
    10d6:	08 95       	ret

000010d8 <setSn_TX_WRSR>:
		uint8 s8[4];
	} u32;

	u32.s32 = size;

	IINCHIP_WRITE(Sn_TX_WRSR(s), u32.s8[3]);
    10d8:	e8 2f       	mov	r30, r24
    10da:	f0 e0       	ldi	r31, 0x00	; 0
    10dc:	ee 0f       	add	r30, r30
    10de:	ff 1f       	adc	r31, r31
    10e0:	ef 5e       	subi	r30, 0xEF	; 239
    10e2:	fb 4f       	sbci	r31, 0xFB	; 251
    10e4:	df 01       	movw	r26, r30
    10e6:	e5 e0       	ldi	r30, 0x05	; 5
    10e8:	aa 0f       	add	r26, r26
    10ea:	bb 1f       	adc	r27, r27
    10ec:	ea 95       	dec	r30
    10ee:	e1 f7       	brne	.-8      	; 0x10e8 <setSn_TX_WRSR+0x10>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    10f0:	7c 93       	st	X, r23

	IINCHIP_WRITE(Sn_TX_WRSR(s), u32.s8[3]);
	IINCHIP_WRITE(Sn_TX_WRSR1(s), u32.s8[2]);
	IINCHIP_WRITE(Sn_TX_WRSR2(s), u32.s8[1]);
	IINCHIP_WRITE(Sn_TX_WRSR3(s), u32.s8[0]);
}
    10f2:	11 96       	adiw	r26, 0x01	; 1
    10f4:	6c 93       	st	X, r22
    10f6:	11 97       	sbiw	r26, 0x01	; 1
    10f8:	fd 01       	movw	r30, r26
    10fa:	32 96       	adiw	r30, 0x02	; 2
    10fc:	50 83       	st	Z, r21
    10fe:	13 96       	adiw	r26, 0x03	; 3
    1100:	4c 93       	st	X, r20
    1102:	08 95       	ret

00001104 <getSn_TX_FSR>:

uint32   getSn_TX_FSR(SOCKET s)
{
    1104:	6f 92       	push	r6
    1106:	7f 92       	push	r7
    1108:	8f 92       	push	r8
    110a:	9f 92       	push	r9
    110c:	af 92       	push	r10
    110e:	bf 92       	push	r11
    1110:	cf 92       	push	r12
    1112:	df 92       	push	r13
    1114:	ef 92       	push	r14
    1116:	ff 92       	push	r15
    1118:	0f 93       	push	r16
    111a:	1f 93       	push	r17
    111c:	cf 93       	push	r28
    111e:	df 93       	push	r29
   uint32 free_tx_size=0;
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	88 5f       	subi	r24, 0xF8	; 248
    1124:	9d 4f       	sbci	r25, 0xFD	; 253
    1126:	56 e0       	ldi	r21, 0x06	; 6
    1128:	88 0f       	add	r24, r24
    112a:	99 1f       	adc	r25, r25
    112c:	5a 95       	dec	r21
    112e:	e1 f7       	brne	.-8      	; 0x1128 <getSn_TX_FSR+0x24>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1130:	44 e2       	ldi	r20, 0x24	; 36
    1132:	84 2e       	mov	r8, r20
    1134:	91 2c       	mov	r9, r1
    1136:	88 0e       	add	r8, r24
    1138:	99 1e       	adc	r9, r25
   uint32 free_tx_size=0;
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
    113a:	bc 01       	movw	r22, r24
    113c:	6b 5d       	subi	r22, 0xDB	; 219
    113e:	7f 4f       	sbci	r23, 0xFF	; 255
    1140:	ec 01       	movw	r28, r24
    1142:	a6 96       	adiw	r28, 0x26	; 38
    1144:	37 e2       	ldi	r19, 0x27	; 39
    1146:	63 2e       	mov	r6, r19
    1148:	71 2c       	mov	r7, r1
    114a:	68 0e       	add	r6, r24
    114c:	79 1e       	adc	r7, r25
    114e:	aa 24       	eor	r10, r10
    1150:	bb 24       	eor	r11, r11
    1152:	65 01       	movw	r12, r10
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1154:	d4 01       	movw	r26, r8
    1156:	8c 91       	ld	r24, X
   uint32 free_tx_size=0;
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
    1158:	90 e0       	ldi	r25, 0x00	; 0
    115a:	a0 e0       	ldi	r26, 0x00	; 0
    115c:	b0 e0       	ldi	r27, 0x00	; 0
    115e:	ba 2f       	mov	r27, r26
    1160:	a9 2f       	mov	r26, r25
    1162:	98 2f       	mov	r25, r24
    1164:	88 27       	eor	r24, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1166:	fb 01       	movw	r30, r22
    1168:	20 81       	ld	r18, Z
   uint32 free_tx_size=0;
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
    116a:	82 0f       	add	r24, r18
    116c:	91 1d       	adc	r25, r1
    116e:	a1 1d       	adc	r26, r1
    1170:	b1 1d       	adc	r27, r1
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR2(s));
    1172:	ba 2f       	mov	r27, r26
    1174:	a9 2f       	mov	r26, r25
    1176:	98 2f       	mov	r25, r24
    1178:	88 27       	eor	r24, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    117a:	28 81       	ld	r18, Y
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR2(s));
    117c:	82 0f       	add	r24, r18
    117e:	91 1d       	adc	r25, r1
    1180:	a1 1d       	adc	r26, r1
    1182:	b1 1d       	adc	r27, r1
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR3(s));                                                       
    1184:	ee 24       	eor	r14, r14
    1186:	f8 2e       	mov	r15, r24
    1188:	09 2f       	mov	r16, r25
    118a:	1a 2f       	mov	r17, r26
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    118c:	d3 01       	movw	r26, r6
    118e:	8c 91       	ld	r24, X
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR2(s));
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR3(s));                                                       
    1190:	e8 0e       	add	r14, r24
    1192:	f1 1c       	adc	r15, r1
    1194:	01 1d       	adc	r16, r1
    1196:	11 1d       	adc	r17, r1
      if(free_tx_size == free_tx_size1) break;                             // if first == sencond, Sn_TX_FSR value is valid.                                                          
    1198:	ea 14       	cp	r14, r10
    119a:	fb 04       	cpc	r15, r11
    119c:	0c 05       	cpc	r16, r12
    119e:	1d 05       	cpc	r17, r13
    11a0:	29 f0       	breq	.+10     	; 0x11ac <getSn_TX_FSR+0xa8>
    11a2:	c7 01       	movw	r24, r14
    11a4:	d8 01       	movw	r26, r16
    11a6:	5c 01       	movw	r10, r24
    11a8:	6d 01       	movw	r12, r26
    11aa:	d4 cf       	rjmp	.-88     	; 0x1154 <getSn_TX_FSR+0x50>
      free_tx_size1 = free_tx_size;                                        // save second value into firs                                                    
   }                                                                       
   return free_tx_size;                                                    
}                                                                          
    11ac:	b5 01       	movw	r22, r10
    11ae:	c6 01       	movw	r24, r12
    11b0:	df 91       	pop	r29
    11b2:	cf 91       	pop	r28
    11b4:	1f 91       	pop	r17
    11b6:	0f 91       	pop	r16
    11b8:	ff 90       	pop	r15
    11ba:	ef 90       	pop	r14
    11bc:	df 90       	pop	r13
    11be:	cf 90       	pop	r12
    11c0:	bf 90       	pop	r11
    11c2:	af 90       	pop	r10
    11c4:	9f 90       	pop	r9
    11c6:	8f 90       	pop	r8
    11c8:	7f 90       	pop	r7
    11ca:	6f 90       	pop	r6
    11cc:	08 95       	ret

000011ce <getSn_RX_RSR>:

uint32   getSn_RX_RSR(SOCKET s)
{
    11ce:	6f 92       	push	r6
    11d0:	7f 92       	push	r7
    11d2:	8f 92       	push	r8
    11d4:	9f 92       	push	r9
    11d6:	af 92       	push	r10
    11d8:	bf 92       	push	r11
    11da:	cf 92       	push	r12
    11dc:	df 92       	push	r13
    11de:	ef 92       	push	r14
    11e0:	ff 92       	push	r15
    11e2:	0f 93       	push	r16
    11e4:	1f 93       	push	r17
    11e6:	cf 93       	push	r28
    11e8:	df 93       	push	r29
   uint32 received_rx_size=0;
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
    11ea:	90 e0       	ldi	r25, 0x00	; 0
    11ec:	88 5f       	subi	r24, 0xF8	; 248
    11ee:	9d 4f       	sbci	r25, 0xFD	; 253
    11f0:	46 e0       	ldi	r20, 0x06	; 6
    11f2:	88 0f       	add	r24, r24
    11f4:	99 1f       	adc	r25, r25
    11f6:	4a 95       	dec	r20
    11f8:	e1 f7       	brne	.-8      	; 0x11f2 <getSn_RX_RSR+0x24>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    11fa:	38 e2       	ldi	r19, 0x28	; 40
    11fc:	83 2e       	mov	r8, r19
    11fe:	91 2c       	mov	r9, r1
    1200:	88 0e       	add	r8, r24
    1202:	99 1e       	adc	r9, r25
   uint32 received_rx_size=0;
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
    1204:	bc 01       	movw	r22, r24
    1206:	67 5d       	subi	r22, 0xD7	; 215
    1208:	7f 4f       	sbci	r23, 0xFF	; 255
    120a:	ec 01       	movw	r28, r24
    120c:	aa 96       	adiw	r28, 0x2a	; 42
    120e:	2b e2       	ldi	r18, 0x2B	; 43
    1210:	62 2e       	mov	r6, r18
    1212:	71 2c       	mov	r7, r1
    1214:	68 0e       	add	r6, r24
    1216:	79 1e       	adc	r7, r25
    1218:	01 e0       	ldi	r16, 0x01	; 1
    121a:	a0 2e       	mov	r10, r16
    121c:	b1 2c       	mov	r11, r1
    121e:	c1 2c       	mov	r12, r1
    1220:	d1 2c       	mov	r13, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1222:	d4 01       	movw	r26, r8
    1224:	8c 91       	ld	r24, X
   uint32 received_rx_size=0;
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	a0 e0       	ldi	r26, 0x00	; 0
    122a:	b0 e0       	ldi	r27, 0x00	; 0
    122c:	ba 2f       	mov	r27, r26
    122e:	a9 2f       	mov	r26, r25
    1230:	98 2f       	mov	r25, r24
    1232:	88 27       	eor	r24, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1234:	fb 01       	movw	r30, r22
    1236:	20 81       	ld	r18, Z
   uint32 received_rx_size=0;
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
    1238:	82 0f       	add	r24, r18
    123a:	91 1d       	adc	r25, r1
    123c:	a1 1d       	adc	r26, r1
    123e:	b1 1d       	adc	r27, r1
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR2(s));
    1240:	ba 2f       	mov	r27, r26
    1242:	a9 2f       	mov	r26, r25
    1244:	98 2f       	mov	r25, r24
    1246:	88 27       	eor	r24, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1248:	28 81       	ld	r18, Y
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR2(s));
    124a:	82 0f       	add	r24, r18
    124c:	91 1d       	adc	r25, r1
    124e:	a1 1d       	adc	r26, r1
    1250:	b1 1d       	adc	r27, r1
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR3(s));                                  
    1252:	ee 24       	eor	r14, r14
    1254:	f8 2e       	mov	r15, r24
    1256:	09 2f       	mov	r16, r25
    1258:	1a 2f       	mov	r17, r26
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    125a:	d3 01       	movw	r26, r6
    125c:	8c 91       	ld	r24, X
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR2(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR3(s));                                  
    125e:	e8 0e       	add	r14, r24
    1260:	f1 1c       	adc	r15, r1
    1262:	01 1d       	adc	r16, r1
    1264:	11 1d       	adc	r17, r1
      if(received_rx_size == received_rx_size1) break;                                                                         
    1266:	ea 14       	cp	r14, r10
    1268:	fb 04       	cpc	r15, r11
    126a:	0c 05       	cpc	r16, r12
    126c:	1d 05       	cpc	r17, r13
    126e:	29 f0       	breq	.+10     	; 0x127a <getSn_RX_RSR+0xac>
    1270:	c7 01       	movw	r24, r14
    1272:	d8 01       	movw	r26, r16
    1274:	5c 01       	movw	r10, r24
    1276:	6d 01       	movw	r12, r26
    1278:	d4 cf       	rjmp	.-88     	; 0x1222 <getSn_RX_RSR+0x54>
      received_rx_size1 = received_rx_size;                                      // if first == sencond, Sn_RX_RSR value is valid.
   }                                                                             // save second value into firs                
   return received_rx_size;   
}
    127a:	b5 01       	movw	r22, r10
    127c:	c6 01       	movw	r24, r12
    127e:	df 91       	pop	r29
    1280:	cf 91       	pop	r28
    1282:	1f 91       	pop	r17
    1284:	0f 91       	pop	r16
    1286:	ff 90       	pop	r15
    1288:	ef 90       	pop	r14
    128a:	df 90       	pop	r13
    128c:	cf 90       	pop	r12
    128e:	bf 90       	pop	r11
    1290:	af 90       	pop	r10
    1292:	9f 90       	pop	r9
    1294:	8f 90       	pop	r8
    1296:	7f 90       	pop	r7
    1298:	6f 90       	pop	r6
    129a:	08 95       	ret

0000129c <setSn_TX_FIFOR>:


void     setSn_TX_FIFOR(SOCKET s, uint16 data)
{
   IINCHIP_WRITE(Sn_TX_FIFOR(s), data >> 8);
    129c:	e8 2f       	mov	r30, r24
    129e:	f0 e0       	ldi	r31, 0x00	; 0
    12a0:	e8 5f       	subi	r30, 0xF8	; 248
    12a2:	fd 4f       	sbci	r31, 0xFD	; 253
    12a4:	56 e0       	ldi	r21, 0x06	; 6
    12a6:	ee 0f       	add	r30, r30
    12a8:	ff 1f       	adc	r31, r31
    12aa:	5a 95       	dec	r21
    12ac:	e1 f7       	brne	.-8      	; 0x12a6 <setSn_TX_FIFOR+0xa>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    12ae:	76 a7       	std	Z+46, r23	; 0x2e

void     setSn_TX_FIFOR(SOCKET s, uint16 data)
{
   IINCHIP_WRITE(Sn_TX_FIFOR(s), data >> 8);
   IINCHIP_WRITE(Sn_TX_FIFOR1(s), data);
}
    12b0:	67 a7       	std	Z+47, r22	; 0x2f
    12b2:	08 95       	ret

000012b4 <getSn_RX_FIFOR>:

uint16   getSn_RX_FIFOR(SOCKET s)
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_RX_FIFOR(s)) << 8;
    12b4:	e8 2f       	mov	r30, r24
    12b6:	f0 e0       	ldi	r31, 0x00	; 0
    12b8:	e8 5f       	subi	r30, 0xF8	; 248
    12ba:	fd 4f       	sbci	r31, 0xFD	; 253
    12bc:	66 e0       	ldi	r22, 0x06	; 6
    12be:	ee 0f       	add	r30, r30
    12c0:	ff 1f       	adc	r31, r31
    12c2:	6a 95       	dec	r22
    12c4:	e1 f7       	brne	.-8      	; 0x12be <getSn_RX_FIFOR+0xa>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    12c6:	20 a9       	ldd	r18, Z+48	; 0x30
}

uint16   getSn_RX_FIFOR(SOCKET s)
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_RX_FIFOR(s)) << 8;
    12c8:	92 2f       	mov	r25, r18
    12ca:	80 e0       	ldi	r24, 0x00	; 0
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    12cc:	21 a9       	ldd	r18, Z+49	; 0x31
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	28 2b       	or	r18, r24
    12d2:	39 2b       	or	r19, r25
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_RX_FIFOR(s)) << 8;
	 ret |= IINCHIP_READ(Sn_RX_FIFOR1(s));
   return ret;
}
    12d4:	c9 01       	movw	r24, r18
    12d6:	08 95       	ret

000012d8 <getSn_PROTOR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    12d8:	e8 2f       	mov	r30, r24
    12da:	f0 e0       	ldi	r31, 0x00	; 0
    12dc:	e8 5f       	subi	r30, 0xF8	; 248
    12de:	fd 4f       	sbci	r31, 0xFD	; 253
    12e0:	76 e0       	ldi	r23, 0x06	; 6
    12e2:	ee 0f       	add	r30, r30
    12e4:	ff 1f       	adc	r31, r31
    12e6:	7a 95       	dec	r23
    12e8:	e1 f7       	brne	.-8      	; 0x12e2 <getSn_PROTOR+0xa>
    12ea:	83 8d       	ldd	r24, Z+27	; 0x1b
/* IP header field */

uint8    getSn_PROTOR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_PROTOR(s));
}
    12ec:	08 95       	ret

000012ee <setSn_PROTOR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    12ee:	e8 2f       	mov	r30, r24
    12f0:	f0 e0       	ldi	r31, 0x00	; 0
    12f2:	e8 5f       	subi	r30, 0xF8	; 248
    12f4:	fd 4f       	sbci	r31, 0xFD	; 253
    12f6:	a6 e0       	ldi	r26, 0x06	; 6
    12f8:	ee 0f       	add	r30, r30
    12fa:	ff 1f       	adc	r31, r31
    12fc:	aa 95       	dec	r26
    12fe:	e1 f7       	brne	.-8      	; 0x12f8 <setSn_PROTOR+0xa>
    1300:	83 8d       	ldd	r24, Z+27	; 0x1b
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    1302:	63 8f       	std	Z+27, r22	; 0x1b
void     setSn_PROTOR(SOCKET s, uint8 pronum)
{
   uint16 protocolnum;
   protocolnum = (IINCHIP_READ(Sn_PROTOR(s)) & 0xFF00) + pronum;
   IINCHIP_WRITE(Sn_PROTOR(s),protocolnum);
}
    1304:	08 95       	ret

00001306 <getSn_TOSR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1306:	e8 2f       	mov	r30, r24
    1308:	f0 e0       	ldi	r31, 0x00	; 0
    130a:	e8 5f       	subi	r30, 0xF8	; 248
    130c:	fd 4f       	sbci	r31, 0xFD	; 253
    130e:	b6 e0       	ldi	r27, 0x06	; 6
    1310:	ee 0f       	add	r30, r30
    1312:	ff 1f       	adc	r31, r31
    1314:	ba 95       	dec	r27
    1316:	e1 f7       	brne	.-8      	; 0x1310 <getSn_TOSR+0xa>
    1318:	84 8d       	ldd	r24, Z+28	; 0x1c
}

uint8    getSn_TOSR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_TOSR(s));
}
    131a:	08 95       	ret

0000131c <setSn_TOSR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    131c:	e8 2f       	mov	r30, r24
    131e:	f0 e0       	ldi	r31, 0x00	; 0
    1320:	e8 5f       	subi	r30, 0xF8	; 248
    1322:	fd 4f       	sbci	r31, 0xFD	; 253
    1324:	86 e0       	ldi	r24, 0x06	; 6
    1326:	ee 0f       	add	r30, r30
    1328:	ff 1f       	adc	r31, r31
    132a:	8a 95       	dec	r24
    132c:	e1 f7       	brne	.-8      	; 0x1326 <setSn_TOSR+0xa>
    132e:	64 8f       	std	Z+28, r22	; 0x1c
   return (uint8)IINCHIP_READ(Sn_TOSR(s));
}
void     setSn_TOSR(SOCKET s, uint8 tos)
{
   IINCHIP_WRITE(Sn_TOSR(s),tos);
}
    1330:	08 95       	ret

00001332 <getSn_TTLR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    1332:	e8 2f       	mov	r30, r24
    1334:	f0 e0       	ldi	r31, 0x00	; 0
    1336:	e8 5f       	subi	r30, 0xF8	; 248
    1338:	fd 4f       	sbci	r31, 0xFD	; 253
    133a:	96 e0       	ldi	r25, 0x06	; 6
    133c:	ee 0f       	add	r30, r30
    133e:	ff 1f       	adc	r31, r31
    1340:	9a 95       	dec	r25
    1342:	e1 f7       	brne	.-8      	; 0x133c <getSn_TTLR+0xa>
    1344:	86 8d       	ldd	r24, Z+30	; 0x1e
}

uint8    getSn_TTLR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_TTLR(s));
}
    1346:	08 95       	ret

00001348 <setSn_TTLR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    1348:	e8 2f       	mov	r30, r24
    134a:	f0 e0       	ldi	r31, 0x00	; 0
    134c:	e8 5f       	subi	r30, 0xF8	; 248
    134e:	fd 4f       	sbci	r31, 0xFD	; 253
    1350:	26 e0       	ldi	r18, 0x06	; 6
    1352:	ee 0f       	add	r30, r30
    1354:	ff 1f       	adc	r31, r31
    1356:	2a 95       	dec	r18
    1358:	e1 f7       	brne	.-8      	; 0x1352 <setSn_TTLR+0xa>
    135a:	66 8f       	std	Z+30, r22	; 0x1e
   return (uint8)IINCHIP_READ(Sn_TTLR(s));
}
void     setSn_TTLR(SOCKET s, uint8 ttl)
{
   IINCHIP_WRITE(Sn_TTLR(s),ttl);
}
    135c:	08 95       	ret

0000135e <getSn_FRAGR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
    135e:	e8 2f       	mov	r30, r24
    1360:	f0 e0       	ldi	r31, 0x00	; 0
    1362:	e8 5f       	subi	r30, 0xF8	; 248
    1364:	fd 4f       	sbci	r31, 0xFD	; 253
    1366:	36 e0       	ldi	r19, 0x06	; 6
    1368:	ee 0f       	add	r30, r30
    136a:	ff 1f       	adc	r31, r31
    136c:	3a 95       	dec	r19
    136e:	e1 f7       	brne	.-8      	; 0x1368 <getSn_FRAGR+0xa>
    1370:	84 a5       	ldd	r24, Z+44	; 0x2c
}

uint8    getSn_FRAGR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_FRAGR(s));
}
    1372:	08 95       	ret

00001374 <setSn_FRAGR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    1374:	e8 2f       	mov	r30, r24
    1376:	f0 e0       	ldi	r31, 0x00	; 0
    1378:	e8 5f       	subi	r30, 0xF8	; 248
    137a:	fd 4f       	sbci	r31, 0xFD	; 253
    137c:	46 e0       	ldi	r20, 0x06	; 6
    137e:	ee 0f       	add	r30, r30
    1380:	ff 1f       	adc	r31, r31
    1382:	4a 95       	dec	r20
    1384:	e1 f7       	brne	.-8      	; 0x137e <setSn_FRAGR+0xa>
    1386:	64 a7       	std	Z+44, r22	; 0x2c
}

void     setSn_FRAGR(SOCKET s, uint8 frag)
{
   IINCHIP_WRITE(Sn_FRAGR(s),frag);
}
    1388:	08 95       	ret

0000138a <sysinit>:


/* Internal memory operation */
 
uint8    sysinit(uint8* tx_size, uint8* rx_size)
{
    138a:	cf 92       	push	r12
    138c:	df 92       	push	r13
    138e:	ef 92       	push	r14
    1390:	ff 92       	push	r15
    1392:	0f 93       	push	r16
    1394:	1f 93       	push	r17
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
    139a:	6c 01       	movw	r12, r24
    139c:	9b 01       	movw	r18, r22
    139e:	7b 01       	movw	r14, r22
    13a0:	b6 01       	movw	r22, r12
    13a2:	e9 01       	movw	r28, r18
    13a4:	00 e0       	ldi	r16, 0x00	; 0
    13a6:	10 e0       	ldi	r17, 0x00	; 0
    13a8:	40 e0       	ldi	r20, 0x00	; 0
    13aa:	50 e0       	ldi	r21, 0x00	; 0
    13ac:	20 e0       	ldi	r18, 0x00	; 0
    13ae:	30 e0       	ldi	r19, 0x00	; 0
   uint16 ssum=0,rsum=0;
   uint mem_cfg = 0;
   
   for(i=0; i < MAX_SOCK_NUM; i++)
   {
      if(tx_size[i] > 64)
    13b0:	db 01       	movw	r26, r22
    13b2:	8c 91       	ld	r24, X
    13b4:	81 34       	cpi	r24, 0x41	; 65
    13b6:	08 f0       	brcs	.+2      	; 0x13ba <sysinit+0x30>
    13b8:	6b c0       	rjmp	.+214    	; 0x1490 <sysinit+0x106>
      #ifdef __DEF_IINCHIP_DBG__
         printf("Illegal Channel(%d) TX Memory Size.\r\n",i);
      #endif
         return 0;
      }
      if(rx_size[i] > 64)
    13ba:	98 81       	ld	r25, Y
    13bc:	91 34       	cpi	r25, 0x41	; 65
    13be:	08 f0       	brcs	.+2      	; 0x13c2 <sysinit+0x38>
    13c0:	67 c0       	rjmp	.+206    	; 0x1490 <sysinit+0x106>
      #ifdef __DEF_IINCHIP_DBG__         
         printf("Illegal Channel(%d) RX Memory Size.\r\n",i);
      #endif
         return 0;
      }
      ssum += (uint16)tx_size[i];
    13c2:	08 0f       	add	r16, r24
    13c4:	11 1d       	adc	r17, r1
      rsum += (uint16)rx_size[i];
    13c6:	49 0f       	add	r20, r25
    13c8:	51 1d       	adc	r21, r1
      TXMEM_SIZE[i] = ((uint32)tx_size[i]) << 10;
    13ca:	f9 01       	movw	r30, r18
    13cc:	e0 5f       	subi	r30, 0xF0	; 240
    13ce:	f9 4f       	sbci	r31, 0xF9	; 249
    13d0:	90 e0       	ldi	r25, 0x00	; 0
    13d2:	a0 e0       	ldi	r26, 0x00	; 0
    13d4:	b0 e0       	ldi	r27, 0x00	; 0
    13d6:	07 2e       	mov	r0, r23
    13d8:	7a e0       	ldi	r23, 0x0A	; 10
    13da:	88 0f       	add	r24, r24
    13dc:	99 1f       	adc	r25, r25
    13de:	aa 1f       	adc	r26, r26
    13e0:	bb 1f       	adc	r27, r27
    13e2:	7a 95       	dec	r23
    13e4:	d1 f7       	brne	.-12     	; 0x13da <sysinit+0x50>
    13e6:	70 2d       	mov	r23, r0
    13e8:	80 83       	st	Z, r24
    13ea:	91 83       	std	Z+1, r25	; 0x01
    13ec:	a2 83       	std	Z+2, r26	; 0x02
    13ee:	b3 83       	std	Z+3, r27	; 0x03
      RXMEM_SIZE[i] = ((uint32)rx_size[i]) << 10;
    13f0:	f9 01       	movw	r30, r18
    13f2:	e0 51       	subi	r30, 0x10	; 16
    13f4:	fa 4f       	sbci	r31, 0xFA	; 250
    13f6:	89 91       	ld	r24, Y+
    13f8:	90 e0       	ldi	r25, 0x00	; 0
    13fa:	a0 e0       	ldi	r26, 0x00	; 0
    13fc:	b0 e0       	ldi	r27, 0x00	; 0
    13fe:	07 2e       	mov	r0, r23
    1400:	7a e0       	ldi	r23, 0x0A	; 10
    1402:	88 0f       	add	r24, r24
    1404:	99 1f       	adc	r25, r25
    1406:	aa 1f       	adc	r26, r26
    1408:	bb 1f       	adc	r27, r27
    140a:	7a 95       	dec	r23
    140c:	d1 f7       	brne	.-12     	; 0x1402 <sysinit+0x78>
    140e:	70 2d       	mov	r23, r0
    1410:	80 83       	st	Z, r24
    1412:	91 83       	std	Z+1, r25	; 0x01
    1414:	a2 83       	std	Z+2, r26	; 0x02
    1416:	b3 83       	std	Z+3, r27	; 0x03
    1418:	6f 5f       	subi	r22, 0xFF	; 255
    141a:	7f 4f       	sbci	r23, 0xFF	; 255
    141c:	2c 5f       	subi	r18, 0xFC	; 252
    141e:	3f 4f       	sbci	r19, 0xFF	; 255
   uint8 k;
   uint16 i;
   uint16 ssum=0,rsum=0;
   uint mem_cfg = 0;
   
   for(i=0; i < MAX_SOCK_NUM; i++)
    1420:	20 32       	cpi	r18, 0x20	; 32
    1422:	31 05       	cpc	r19, r1
    1424:	29 f6       	brne	.-118    	; 0x13b0 <sysinit+0x26>
      ssum += (uint16)tx_size[i];
      rsum += (uint16)rx_size[i];
      TXMEM_SIZE[i] = ((uint32)tx_size[i]) << 10;
      RXMEM_SIZE[i] = ((uint32)rx_size[i]) << 10;
   }
   if( (ssum % 8) || ((ssum + rsum) != 128) )
    1426:	c8 01       	movw	r24, r16
    1428:	87 70       	andi	r24, 0x07	; 7
    142a:	90 70       	andi	r25, 0x00	; 0
    142c:	89 2b       	or	r24, r25
    142e:	81 f5       	brne	.+96     	; 0x1490 <sysinit+0x106>
    1430:	40 0f       	add	r20, r16
    1432:	51 1f       	adc	r21, r17
    1434:	40 38       	cpi	r20, 0x80	; 128
    1436:	51 05       	cpc	r21, r1
    1438:	59 f5       	brne	.+86     	; 0x1490 <sysinit+0x106>
    143a:	e0 e2       	ldi	r30, 0x20	; 32
    143c:	f0 e8       	ldi	r31, 0x80	; 128
      return 0;
   }
   
   k = 0;
   for(i = TMSR0; i <= TMSR7; i++) {
      IINCHIP_WRITE(i, tx_size[k]);
    143e:	d6 01       	movw	r26, r12
    1440:	8d 91       	ld	r24, X+
    1442:	6d 01       	movw	r12, r26
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    1444:	81 93       	st	Z+, r24
   #endif
      return 0;
   }
   
   k = 0;
   for(i = TMSR0; i <= TMSR7; i++) {
    1446:	b0 e8       	ldi	r27, 0x80	; 128
    1448:	e8 32       	cpi	r30, 0x28	; 40
    144a:	fb 07       	cpc	r31, r27
    144c:	c1 f7       	brne	.-16     	; 0x143e <sysinit+0xb4>
   k++;
	 }
   
   k = 0;
   for(i = RMSR0; i <= RMSR7; i++) {
      IINCHIP_WRITE(i, rx_size[k]);
    144e:	d7 01       	movw	r26, r14
    1450:	8d 91       	ld	r24, X+
    1452:	7d 01       	movw	r14, r26
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    1454:	81 93       	st	Z+, r24
      IINCHIP_WRITE(i, tx_size[k]);
   k++;
	 }
   
   k = 0;
   for(i = RMSR0; i <= RMSR7; i++) {
    1456:	b0 e8       	ldi	r27, 0x80	; 128
    1458:	e0 33       	cpi	r30, 0x30	; 48
    145a:	fb 07       	cpc	r31, r27
    145c:	c1 f7       	brne	.-16     	; 0x144e <sysinit+0xc4>
      IINCHIP_WRITE(i, rx_size[k]);
   k++;
   }
   
   for(i=0; i <ssum/8 ; i++)
    145e:	c8 01       	movw	r24, r16
    1460:	73 e0       	ldi	r23, 0x03	; 3
    1462:	96 95       	lsr	r25
    1464:	87 95       	ror	r24
    1466:	7a 95       	dec	r23
    1468:	e1 f7       	brne	.-8      	; 0x1462 <sysinit+0xd8>
    146a:	40 e0       	ldi	r20, 0x00	; 0
    146c:	50 e0       	ldi	r21, 0x00	; 0
    146e:	20 e0       	ldi	r18, 0x00	; 0
    1470:	30 e0       	ldi	r19, 0x00	; 0
    1472:	05 c0       	rjmp	.+10     	; 0x147e <sysinit+0xf4>
   {
      mem_cfg <<= 1;
    1474:	22 0f       	add	r18, r18
    1476:	33 1f       	adc	r19, r19
      mem_cfg |= 1;
    1478:	21 60       	ori	r18, 0x01	; 1
   for(i = RMSR0; i <= RMSR7; i++) {
      IINCHIP_WRITE(i, rx_size[k]);
   k++;
   }
   
   for(i=0; i <ssum/8 ; i++)
    147a:	4f 5f       	subi	r20, 0xFF	; 255
    147c:	5f 4f       	sbci	r21, 0xFF	; 255
    147e:	48 17       	cp	r20, r24
    1480:	59 07       	cpc	r21, r25
    1482:	c0 f3       	brcs	.-16     	; 0x1474 <sysinit+0xea>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
    1484:	30 93 30 80 	sts	0x8030, r19
      printf("%02d : %07dKB : %07dKB \r\n", 6, (uint8)(IINCHIP_READ(TMSR6)),(uint8)(IINCHIP_READ(RMSR6)));
      printf("%02d : %07dKB : %07dKB \r\n", 7, (uint8)(IINCHIP_READ(TMSR7)),(uint8)(IINCHIP_READ(RMSR7)));
      printf("\r\nMTYPER=%04x\r\n",IINCHIP_READ(MTYPER));
   #endif
   
   return 1;
    1488:	20 93 31 80 	sts	0x8031, r18
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	01 c0       	rjmp	.+2      	; 0x1492 <sysinit+0x108>
    1490:	80 e0       	ldi	r24, 0x00	; 0
}
    1492:	df 91       	pop	r29
    1494:	cf 91       	pop	r28
    1496:	1f 91       	pop	r17
    1498:	0f 91       	pop	r16
    149a:	ff 90       	pop	r15
    149c:	ef 90       	pop	r14
    149e:	df 90       	pop	r13
    14a0:	cf 90       	pop	r12
    14a2:	08 95       	ret

000014a4 <wiz_write_buf>:

uint32   wiz_write_buf(SOCKET s,uint8* buf,uint32 len)
{
    14a4:	ef 92       	push	r14
    14a6:	ff 92       	push	r15
    14a8:	0f 93       	push	r16
    14aa:	1f 93       	push	r17
    14ac:	cf 93       	push	r28
    14ae:	df 93       	push	r29
    14b0:	79 01       	movw	r14, r18
    14b2:	8a 01       	movw	r16, r20
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;					
				for(z=0; z<len; z+=2) { 
					*((vuint8*)Sn_TX_FIFOR(s)) = *(buf+z);
    14b4:	90 e0       	ldi	r25, 0x00	; 0
    14b6:	88 5f       	subi	r24, 0xF8	; 248
    14b8:	9d 4f       	sbci	r25, 0xFD	; 253
    14ba:	26 e0       	ldi	r18, 0x06	; 6
    14bc:	88 0f       	add	r24, r24
    14be:	99 1f       	adc	r25, r25
    14c0:	2a 95       	dec	r18
    14c2:	e1 f7       	brne	.-8      	; 0x14bc <wiz_write_buf+0x18>
    14c4:	ec 01       	movw	r28, r24
    14c6:	ae 96       	adiw	r28, 0x2e	; 46
					*((vuint8*)Sn_TX_FIFOR1(s)) = *(buf+z+1);
    14c8:	dc 01       	movw	r26, r24
    14ca:	9f 96       	adiw	r26, 0x2f	; 47
    14cc:	fb 01       	movw	r30, r22
    14ce:	20 e0       	ldi	r18, 0x00	; 0
    14d0:	30 e0       	ldi	r19, 0x00	; 0
    14d2:	40 e0       	ldi	r20, 0x00	; 0
    14d4:	50 e0       	ldi	r21, 0x00	; 0
    14d6:	09 c0       	rjmp	.+18     	; 0x14ea <wiz_write_buf+0x46>
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;					
				for(z=0; z<len; z+=2) { 
					*((vuint8*)Sn_TX_FIFOR(s)) = *(buf+z);
    14d8:	80 81       	ld	r24, Z
    14da:	88 83       	st	Y, r24
					*((vuint8*)Sn_TX_FIFOR1(s)) = *(buf+z+1);
    14dc:	81 81       	ldd	r24, Z+1	; 0x01
    14de:	8c 93       	st	X, r24
uint32   wiz_write_buf(SOCKET s,uint8* buf,uint32 len)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;					
				for(z=0; z<len; z+=2) { 
    14e0:	2e 5f       	subi	r18, 0xFE	; 254
    14e2:	3f 4f       	sbci	r19, 0xFF	; 255
    14e4:	4f 4f       	sbci	r20, 0xFF	; 255
    14e6:	5f 4f       	sbci	r21, 0xFF	; 255
    14e8:	32 96       	adiw	r30, 0x02	; 2
    14ea:	2e 15       	cp	r18, r14
    14ec:	3f 05       	cpc	r19, r15
    14ee:	40 07       	cpc	r20, r16
    14f0:	51 07       	cpc	r21, r17
    14f2:	90 f3       	brcs	.-28     	; 0x14d8 <wiz_write_buf+0x34>
   #endif 
#else
   #error "Undefined __DEF_IINCHIP_ADDRESS_MODE__"   
#endif
    return len;   
}
    14f4:	b7 01       	movw	r22, r14
    14f6:	c8 01       	movw	r24, r16
    14f8:	df 91       	pop	r29
    14fa:	cf 91       	pop	r28
    14fc:	1f 91       	pop	r17
    14fe:	0f 91       	pop	r16
    1500:	ff 90       	pop	r15
    1502:	ef 90       	pop	r14
    1504:	08 95       	ret

00001506 <wiz_read_buf>:

uint32   wiz_read_buf(SOCKET s, uint8* buf,uint32 len)
{
    1506:	ef 92       	push	r14
    1508:	ff 92       	push	r15
    150a:	0f 93       	push	r16
    150c:	1f 93       	push	r17
    150e:	cf 93       	push	r28
    1510:	df 93       	push	r29
    1512:	79 01       	movw	r14, r18
    1514:	8a 01       	movw	r16, r20

#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;	
				for(z=0; z<len; z+=2) { 
					*(buf+z) = *((vuint8*)Sn_RX_FIFOR(s));
    1516:	90 e0       	ldi	r25, 0x00	; 0
    1518:	88 5f       	subi	r24, 0xF8	; 248
    151a:	9d 4f       	sbci	r25, 0xFD	; 253
    151c:	36 e0       	ldi	r19, 0x06	; 6
    151e:	88 0f       	add	r24, r24
    1520:	99 1f       	adc	r25, r25
    1522:	3a 95       	dec	r19
    1524:	e1 f7       	brne	.-8      	; 0x151e <wiz_read_buf+0x18>
    1526:	ec 01       	movw	r28, r24
    1528:	e0 96       	adiw	r28, 0x30	; 48
					*(buf+z+1) = *((vuint8*)Sn_RX_FIFOR1(s));
    152a:	dc 01       	movw	r26, r24
    152c:	d1 96       	adiw	r26, 0x31	; 49
    152e:	fb 01       	movw	r30, r22
    1530:	20 e0       	ldi	r18, 0x00	; 0
    1532:	30 e0       	ldi	r19, 0x00	; 0
    1534:	40 e0       	ldi	r20, 0x00	; 0
    1536:	50 e0       	ldi	r21, 0x00	; 0
    1538:	09 c0       	rjmp	.+18     	; 0x154c <wiz_read_buf+0x46>

#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;	
				for(z=0; z<len; z+=2) { 
					*(buf+z) = *((vuint8*)Sn_RX_FIFOR(s));
    153a:	88 81       	ld	r24, Y
    153c:	80 83       	st	Z, r24
					*(buf+z+1) = *((vuint8*)Sn_RX_FIFOR1(s));
    153e:	8c 91       	ld	r24, X
    1540:	81 83       	std	Z+1, r24	; 0x01
{

#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;	
				for(z=0; z<len; z+=2) { 
    1542:	2e 5f       	subi	r18, 0xFE	; 254
    1544:	3f 4f       	sbci	r19, 0xFF	; 255
    1546:	4f 4f       	sbci	r20, 0xFF	; 255
    1548:	5f 4f       	sbci	r21, 0xFF	; 255
    154a:	32 96       	adiw	r30, 0x02	; 2
    154c:	2e 15       	cp	r18, r14
    154e:	3f 05       	cpc	r19, r15
    1550:	40 07       	cpc	r20, r16
    1552:	51 07       	cpc	r21, r17
    1554:	90 f3       	brcs	.-28     	; 0x153a <wiz_read_buf+0x34>
   #endif 
#else
   #error "Undefined __DEF_IINCHIP_ADDRESS_MODE__"   
#endif
    return len;
}
    1556:	b7 01       	movw	r22, r14
    1558:	c8 01       	movw	r24, r16
    155a:	df 91       	pop	r29
    155c:	cf 91       	pop	r28
    155e:	1f 91       	pop	r17
    1560:	0f 91       	pop	r16
    1562:	ff 90       	pop	r15
    1564:	ef 90       	pop	r14
    1566:	08 95       	ret

00001568 <getIINCHIP_TxMAX>:


uint32   getIINCHIP_TxMAX(SOCKET s)
{
    1568:	e8 2f       	mov	r30, r24
    156a:	f0 e0       	ldi	r31, 0x00	; 0
    156c:	ee 0f       	add	r30, r30
    156e:	ff 1f       	adc	r31, r31
    1570:	ee 0f       	add	r30, r30
    1572:	ff 1f       	adc	r31, r31
    1574:	e0 5f       	subi	r30, 0xF0	; 240
    1576:	f9 4f       	sbci	r31, 0xF9	; 249
    1578:	60 81       	ld	r22, Z
    157a:	71 81       	ldd	r23, Z+1	; 0x01
   return TXMEM_SIZE[s];
}
    157c:	82 81       	ldd	r24, Z+2	; 0x02
    157e:	93 81       	ldd	r25, Z+3	; 0x03
    1580:	08 95       	ret

00001582 <getIINCHIP_RxMAX>:

uint32   getIINCHIP_RxMAX(SOCKET s)
{
    1582:	e8 2f       	mov	r30, r24
    1584:	f0 e0       	ldi	r31, 0x00	; 0
    1586:	ee 0f       	add	r30, r30
    1588:	ff 1f       	adc	r31, r31
    158a:	ee 0f       	add	r30, r30
    158c:	ff 1f       	adc	r31, r31
    158e:	e0 51       	subi	r30, 0x10	; 16
    1590:	fa 4f       	sbci	r31, 0xFA	; 250
    1592:	60 81       	ld	r22, Z
    1594:	71 81       	ldd	r23, Z+1	; 0x01
   return RXMEM_SIZE[s];
}
    1596:	82 81       	ldd	r24, Z+2	; 0x02
    1598:	93 81       	ldd	r25, Z+3	; 0x03
    159a:	08 95       	ret

0000159c <iinchip_init>:

/* Initialization & Interrupt request routine */

void     iinchip_init(void)
{
	*((volatile uint8*)MR) = MR_RST;
    159c:	80 e8       	ldi	r24, 0x80	; 128
    159e:	80 93 01 80 	sts	0x8001, r24
	wait_1ms(5);				// wait PLL lock
    15a2:	85 e0       	ldi	r24, 0x05	; 5
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <wait_1ms>
		*((volatile uint8*)MR) = MR_IND;
    #ifndef __DEF_IINCHIP_DBG__	
	      printf("MR value is %04x\r\n",*((volatile uint8*)MR));
    #endif	
#endif
}
    15aa:	08 95       	ret

000015ac <ProcessUDP>:
		break;		
	}
}

void ProcessUDP(SOCKET Sock, unsigned int Port)
{
    15ac:	7f 92       	push	r7
    15ae:	8f 92       	push	r8
    15b0:	9f 92       	push	r9
    15b2:	af 92       	push	r10
    15b4:	bf 92       	push	r11
    15b6:	cf 92       	push	r12
    15b8:	df 92       	push	r13
    15ba:	ef 92       	push	r14
    15bc:	ff 92       	push	r15
    15be:	0f 93       	push	r16
    15c0:	1f 93       	push	r17
    15c2:	df 93       	push	r29
    15c4:	cf 93       	push	r28
    15c6:	cd b7       	in	r28, 0x3d	; 61
    15c8:	de b7       	in	r29, 0x3e	; 62
    15ca:	ca 5b       	subi	r28, 0xBA	; 186
    15cc:	d5 40       	sbci	r29, 0x05	; 5
    15ce:	0f b6       	in	r0, 0x3f	; 63
    15d0:	f8 94       	cli
    15d2:	de bf       	out	0x3e, r29	; 62
    15d4:	0f be       	out	0x3f, r0	; 63
    15d6:	cd bf       	out	0x3d, r28	; 61
    15d8:	78 2e       	mov	r7, r24
    15da:	8b 01       	movw	r16, r22
	uint8 destip[4];
	uint16 destport;

	unsigned char data_buf[MAX_BUF_SIZE];

	switch(getSn_SSR(Sock))
    15dc:	0e 94 8f 07 	call	0xf1e	; 0xf1e <getSn_SSR>
    15e0:	88 23       	and	r24, r24
    15e2:	09 f4       	brne	.+2      	; 0x15e6 <ProcessUDP+0x3a>
    15e4:	77 c0       	rjmp	.+238    	; 0x16d4 <ProcessUDP+0x128>
    15e6:	82 32       	cpi	r24, 0x22	; 34
    15e8:	09 f0       	breq	.+2      	; 0x15ec <ProcessUDP+0x40>
    15ea:	7e c0       	rjmp	.+252    	; 0x16e8 <ProcessUDP+0x13c>
	{
		// -------------------------------
		case SOCK_UDP:                                     // 
			if((len=getSn_RX_RSR(Sock)) > 0)                   // check the size of received data
    15ec:	87 2d       	mov	r24, r7
    15ee:	0e 94 e7 08 	call	0x11ce	; 0x11ce <getSn_RX_RSR>
    15f2:	9b 01       	movw	r18, r22
    15f4:	ac 01       	movw	r20, r24
    15f6:	61 15       	cp	r22, r1
    15f8:	71 05       	cpc	r23, r1
    15fa:	81 05       	cpc	r24, r1
    15fc:	91 05       	cpc	r25, r1
    15fe:	09 f4       	brne	.+2      	; 0x1602 <ProcessUDP+0x56>
    1600:	73 c0       	rjmp	.+230    	; 0x16e8 <ProcessUDP+0x13c>
			{
				len = recvfrom(Sock,data_buf,len,destip,&destport);  // receive data from a destination
    1602:	97 e0       	ldi	r25, 0x07	; 7
    1604:	e9 2e       	mov	r14, r25
    1606:	f1 2c       	mov	r15, r1
    1608:	ec 0e       	add	r14, r28
    160a:	fd 1e       	adc	r15, r29
    160c:	83 e0       	ldi	r24, 0x03	; 3
    160e:	c8 2e       	mov	r12, r24
    1610:	d1 2c       	mov	r13, r1
    1612:	cc 0e       	add	r12, r28
    1614:	dd 1e       	adc	r13, r29
    1616:	87 2d       	mov	r24, r7
    1618:	b7 01       	movw	r22, r14
    161a:	a9 01       	movw	r20, r18
    161c:	96 01       	movw	r18, r12
    161e:	8e 01       	movw	r16, r28
    1620:	0f 5f       	subi	r16, 0xFF	; 255
    1622:	1f 4f       	sbci	r17, 0xFF	; 255
    1624:	0e 94 ab 03 	call	0x756	; 0x756 <recvfrom>
    1628:	ac 01       	movw	r20, r24
    162a:	4c 01       	movw	r8, r24
    162c:	aa 24       	eor	r10, r10
    162e:	bb 24       	eor	r11, r11
				if(len !=sendto(Sock,data_buf,len,destip,destport))  // send the data to the destination
    1630:	09 81       	ldd	r16, Y+1	; 0x01
    1632:	1a 81       	ldd	r17, Y+2	; 0x02
    1634:	87 2d       	mov	r24, r7
    1636:	b7 01       	movw	r22, r14
    1638:	96 01       	movw	r18, r12
    163a:	0e 94 c3 02 	call	0x586	; 0x586 <sendto>
    163e:	a0 e0       	ldi	r26, 0x00	; 0
    1640:	b0 e0       	ldi	r27, 0x00	; 0
    1642:	88 16       	cp	r8, r24
    1644:	99 06       	cpc	r9, r25
    1646:	aa 06       	cpc	r10, r26
    1648:	bb 06       	cpc	r11, r27
    164a:	09 f4       	brne	.+2      	; 0x164e <ProcessUDP+0xa2>
    164c:	4d c0       	rjmp	.+154    	; 0x16e8 <ProcessUDP+0x13c>
				{
					printf("%d : Sendto Fail.len=%ld,",Sock,len);
    164e:	8d b7       	in	r24, 0x3d	; 61
    1650:	9e b7       	in	r25, 0x3e	; 62
    1652:	08 97       	sbiw	r24, 0x08	; 8
    1654:	0f b6       	in	r0, 0x3f	; 63
    1656:	f8 94       	cli
    1658:	9e bf       	out	0x3e, r25	; 62
    165a:	0f be       	out	0x3f, r0	; 63
    165c:	8d bf       	out	0x3d, r24	; 61
    165e:	ed b7       	in	r30, 0x3d	; 61
    1660:	fe b7       	in	r31, 0x3e	; 62
    1662:	31 96       	adiw	r30, 0x01	; 1
    1664:	8f ec       	ldi	r24, 0xCF	; 207
    1666:	91 e0       	ldi	r25, 0x01	; 1
    1668:	ad b7       	in	r26, 0x3d	; 61
    166a:	be b7       	in	r27, 0x3e	; 62
    166c:	12 96       	adiw	r26, 0x02	; 2
    166e:	9c 93       	st	X, r25
    1670:	8e 93       	st	-X, r24
    1672:	11 97       	sbiw	r26, 0x01	; 1
    1674:	72 82       	std	Z+2, r7	; 0x02
    1676:	13 82       	std	Z+3, r1	; 0x03
    1678:	84 82       	std	Z+4, r8	; 0x04
    167a:	95 82       	std	Z+5, r9	; 0x05
    167c:	a6 82       	std	Z+6, r10	; 0x06
    167e:	b7 82       	std	Z+7, r11	; 0x07
    1680:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
					printf("%d.%d.%d.%d(%d)\r\n",destip[0],destip[1],destip[2],destip[3],destport);
    1684:	00 d0       	rcall	.+0      	; 0x1686 <ProcessUDP+0xda>
    1686:	00 d0       	rcall	.+0      	; 0x1688 <ProcessUDP+0xdc>
    1688:	ed b7       	in	r30, 0x3d	; 61
    168a:	fe b7       	in	r31, 0x3e	; 62
    168c:	31 96       	adiw	r30, 0x01	; 1
    168e:	89 ee       	ldi	r24, 0xE9	; 233
    1690:	91 e0       	ldi	r25, 0x01	; 1
    1692:	ad b7       	in	r26, 0x3d	; 61
    1694:	be b7       	in	r27, 0x3e	; 62
    1696:	12 96       	adiw	r26, 0x02	; 2
    1698:	9c 93       	st	X, r25
    169a:	8e 93       	st	-X, r24
    169c:	11 97       	sbiw	r26, 0x01	; 1
    169e:	8b 81       	ldd	r24, Y+3	; 0x03
    16a0:	82 83       	std	Z+2, r24	; 0x02
    16a2:	13 82       	std	Z+3, r1	; 0x03
    16a4:	8c 81       	ldd	r24, Y+4	; 0x04
    16a6:	84 83       	std	Z+4, r24	; 0x04
    16a8:	15 82       	std	Z+5, r1	; 0x05
    16aa:	8d 81       	ldd	r24, Y+5	; 0x05
    16ac:	86 83       	std	Z+6, r24	; 0x06
    16ae:	17 82       	std	Z+7, r1	; 0x07
    16b0:	8e 81       	ldd	r24, Y+6	; 0x06
    16b2:	80 87       	std	Z+8, r24	; 0x08
    16b4:	11 86       	std	Z+9, r1	; 0x09
    16b6:	89 81       	ldd	r24, Y+1	; 0x01
    16b8:	9a 81       	ldd	r25, Y+2	; 0x02
    16ba:	93 87       	std	Z+11, r25	; 0x0b
    16bc:	82 87       	std	Z+10, r24	; 0x0a
    16be:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    16c2:	8d b7       	in	r24, 0x3d	; 61
    16c4:	9e b7       	in	r25, 0x3e	; 62
    16c6:	0c 96       	adiw	r24, 0x0c	; 12
    16c8:	0f b6       	in	r0, 0x3f	; 63
    16ca:	f8 94       	cli
    16cc:	9e bf       	out	0x3e, r25	; 62
    16ce:	0f be       	out	0x3f, r0	; 63
    16d0:	8d bf       	out	0x3d, r24	; 61
    16d2:	0a c0       	rjmp	.+20     	; 0x16e8 <ProcessUDP+0x13c>
				}
			}
		break;
		 // -----------------
		case SOCK_CLOSED:                                  // CLOSED
			close(Sock);                                       // close the SOCKET
    16d4:	87 2d       	mov	r24, r7
    16d6:	0e 94 07 02 	call	0x40e	; 0x40e <close>
			socket(Sock,Sn_MR_UDP,Port,0);                  // open the SOCKET with UDP mode
    16da:	87 2d       	mov	r24, r7
    16dc:	62 e0       	ldi	r22, 0x02	; 2
    16de:	a8 01       	movw	r20, r16
    16e0:	20 e0       	ldi	r18, 0x00	; 0
    16e2:	30 e0       	ldi	r19, 0x00	; 0
    16e4:	0e 94 13 02 	call	0x426	; 0x426 <socket>
			break;
		
		default:
			break;
		}
	}
    16e8:	c6 54       	subi	r28, 0x46	; 70
    16ea:	da 4f       	sbci	r29, 0xFA	; 250
    16ec:	0f b6       	in	r0, 0x3f	; 63
    16ee:	f8 94       	cli
    16f0:	de bf       	out	0x3e, r29	; 62
    16f2:	0f be       	out	0x3f, r0	; 63
    16f4:	cd bf       	out	0x3d, r28	; 61
    16f6:	cf 91       	pop	r28
    16f8:	df 91       	pop	r29
    16fa:	1f 91       	pop	r17
    16fc:	0f 91       	pop	r16
    16fe:	ff 90       	pop	r15
    1700:	ef 90       	pop	r14
    1702:	df 90       	pop	r13
    1704:	cf 90       	pop	r12
    1706:	bf 90       	pop	r11
    1708:	af 90       	pop	r10
    170a:	9f 90       	pop	r9
    170c:	8f 90       	pop	r8
    170e:	7f 90       	pop	r7
    1710:	08 95       	ret

00001712 <ProcessTCPServer>:



//-----------------------------------------------------------------------------
void ProcessTCPServer(unsigned char Sock, unsigned int Port)
{
    1712:	ff 92       	push	r15
    1714:	0f 93       	push	r16
    1716:	1f 93       	push	r17
    1718:	df 93       	push	r29
    171a:	cf 93       	push	r28
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	c4 5b       	subi	r28, 0xB4	; 180
    1722:	d5 40       	sbci	r29, 0x05	; 5
    1724:	0f b6       	in	r0, 0x3f	; 63
    1726:	f8 94       	cli
    1728:	de bf       	out	0x3e, r29	; 62
    172a:	0f be       	out	0x3f, r0	; 63
    172c:	cd bf       	out	0x3d, r28	; 61
    172e:	f8 2e       	mov	r15, r24
    1730:	8b 01       	movw	r16, r22
	unsigned int len;							

	unsigned char data_buf[MAX_BUF_SIZE];

	
	switch(getSockStatus(Sock))
    1732:	0e 94 8f 07 	call	0xf1e	; 0xf1e <getSn_SSR>
    1736:	83 31       	cpi	r24, 0x13	; 19
    1738:	c9 f1       	breq	.+114    	; 0x17ac <ProcessTCPServer+0x9a>
    173a:	84 31       	cpi	r24, 0x14	; 20
    173c:	18 f4       	brcc	.+6      	; 0x1744 <ProcessTCPServer+0x32>
    173e:	88 23       	and	r24, r24
    1740:	51 f1       	breq	.+84     	; 0x1796 <ProcessTCPServer+0x84>
    1742:	53 c0       	rjmp	.+166    	; 0x17ea <ProcessTCPServer+0xd8>
    1744:	87 31       	cpi	r24, 0x17	; 23
    1746:	21 f0       	breq	.+8      	; 0x1750 <ProcessTCPServer+0x3e>
    1748:	8c 31       	cpi	r24, 0x1C	; 28
    174a:	09 f0       	breq	.+2      	; 0x174e <ProcessTCPServer+0x3c>
    174c:	4e c0       	rjmp	.+156    	; 0x17ea <ProcessTCPServer+0xd8>
    174e:	1f c0       	rjmp	.+62     	; 0x178e <ProcessTCPServer+0x7c>
	{
	case SOCK_ESTABLISHED:
		//check Rx data
		if((len = getRecvSize(Sock)) > 0) 			
    1750:	8f 2d       	mov	r24, r15
    1752:	0e 94 e7 08 	call	0x11ce	; 0x11ce <getSn_RX_RSR>
    1756:	61 15       	cp	r22, r1
    1758:	71 05       	cpc	r23, r1
    175a:	09 f4       	brne	.+2      	; 0x175e <ProcessTCPServer+0x4c>
    175c:	46 c0       	rjmp	.+140    	; 0x17ea <ProcessTCPServer+0xd8>
		{
			//if Rx data size is lager than TX_RX_MAX_BUF_SIZE 
			if (len > MAX_BUF_SIZE) len = MAX_BUF_SIZE;	
			
			//read the received data
			len = recv(Sock, data_buf, len);
    175e:	9b 01       	movw	r18, r22
    1760:	85 e0       	ldi	r24, 0x05	; 5
    1762:	25 3b       	cpi	r18, 0xB5	; 181
    1764:	38 07       	cpc	r19, r24
    1766:	10 f0       	brcs	.+4      	; 0x176c <ProcessTCPServer+0x5a>
    1768:	24 eb       	ldi	r18, 0xB4	; 180
    176a:	35 e0       	ldi	r19, 0x05	; 5
    176c:	40 e0       	ldi	r20, 0x00	; 0
    176e:	50 e0       	ldi	r21, 0x00	; 0
    1770:	8f 2d       	mov	r24, r15
    1772:	8e 01       	movw	r16, r28
    1774:	0f 5f       	subi	r16, 0xFF	; 255
    1776:	1f 4f       	sbci	r17, 0xFF	; 255
    1778:	b8 01       	movw	r22, r16
    177a:	0e 94 5b 03 	call	0x6b6	; 0x6b6 <recv>
			send(Sock, data_buf, len);  // send
    177e:	9b 01       	movw	r18, r22
    1780:	40 e0       	ldi	r20, 0x00	; 0
    1782:	50 e0       	ldi	r21, 0x00	; 0
    1784:	8f 2d       	mov	r24, r15
    1786:	b8 01       	movw	r22, r16
    1788:	0e 94 5f 05 	call	0xabe	; 0xabe <send>
    178c:	2e c0       	rjmp	.+92     	; 0x17ea <ProcessTCPServer+0xd8>
		}		
		break;
		
	case SOCK_CLOSE_WAIT:                           		
		//If the client request to close
		disconnect(Sock);
    178e:	8f 2d       	mov	r24, r15
    1790:	0e 94 9c 01 	call	0x338	; 0x338 <disconnect>
    1794:	2a c0       	rjmp	.+84     	; 0x17ea <ProcessTCPServer+0xd8>
		break;
		
   case SOCK_CLOSED:                   // CLOSED
		close(Sock);                        // close the SOCKET
    1796:	8f 2d       	mov	r24, r15
    1798:	0e 94 07 02 	call	0x40e	; 0x40e <close>
		socket(Sock, Sn_MR_TCP, Port,0);   // open the SOCKET  
    179c:	8f 2d       	mov	r24, r15
    179e:	61 e0       	ldi	r22, 0x01	; 1
    17a0:	a8 01       	movw	r20, r16
    17a2:	20 e0       	ldi	r18, 0x00	; 0
    17a4:	30 e0       	ldi	r19, 0x00	; 0
    17a6:	0e 94 13 02 	call	0x426	; 0x426 <socket>
    17aa:	1f c0       	rjmp	.+62     	; 0x17ea <ProcessTCPServer+0xd8>
		break;
		
   case SOCK_INIT:                     // The SOCKET opened with TCP mode
		//connect(Sock, m_ConfigServerIp, port);
		listen(Sock);
    17ac:	8f 2d       	mov	r24, r15
    17ae:	0e 94 f7 04 	call	0x9ee	; 0x9ee <listen>
		printf("%d : TCP Server(%d) Started.\r\n", Sock, Port);
    17b2:	00 d0       	rcall	.+0      	; 0x17b4 <ProcessTCPServer+0xa2>
    17b4:	00 d0       	rcall	.+0      	; 0x17b6 <ProcessTCPServer+0xa4>
    17b6:	00 d0       	rcall	.+0      	; 0x17b8 <ProcessTCPServer+0xa6>
    17b8:	ed b7       	in	r30, 0x3d	; 61
    17ba:	fe b7       	in	r31, 0x3e	; 62
    17bc:	31 96       	adiw	r30, 0x01	; 1
    17be:	8b ef       	ldi	r24, 0xFB	; 251
    17c0:	91 e0       	ldi	r25, 0x01	; 1
    17c2:	ad b7       	in	r26, 0x3d	; 61
    17c4:	be b7       	in	r27, 0x3e	; 62
    17c6:	12 96       	adiw	r26, 0x02	; 2
    17c8:	9c 93       	st	X, r25
    17ca:	8e 93       	st	-X, r24
    17cc:	11 97       	sbiw	r26, 0x01	; 1
    17ce:	f2 82       	std	Z+2, r15	; 0x02
    17d0:	13 82       	std	Z+3, r1	; 0x03
    17d2:	15 83       	std	Z+5, r17	; 0x05
    17d4:	04 83       	std	Z+4, r16	; 0x04
    17d6:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    17da:	8d b7       	in	r24, 0x3d	; 61
    17dc:	9e b7       	in	r25, 0x3e	; 62
    17de:	06 96       	adiw	r24, 0x06	; 6
    17e0:	0f b6       	in	r0, 0x3f	; 63
    17e2:	f8 94       	cli
    17e4:	9e bf       	out	0x3e, r25	; 62
    17e6:	0f be       	out	0x3f, r0	; 63
    17e8:	8d bf       	out	0x3d, r24	; 61
		break;		
	}
}
    17ea:	cc 54       	subi	r28, 0x4C	; 76
    17ec:	da 4f       	sbci	r29, 0xFA	; 250
    17ee:	0f b6       	in	r0, 0x3f	; 63
    17f0:	f8 94       	cli
    17f2:	de bf       	out	0x3e, r29	; 62
    17f4:	0f be       	out	0x3f, r0	; 63
    17f6:	cd bf       	out	0x3d, r28	; 61
    17f8:	cf 91       	pop	r28
    17fa:	df 91       	pop	r29
    17fc:	1f 91       	pop	r17
    17fe:	0f 91       	pop	r16
    1800:	ff 90       	pop	r15
    1802:	08 95       	ret

00001804 <DisplayBar>:
//-----------------------------------------------------------------------------


void DisplayBar(void)
{
	printf("\r\n================================================\r\n");
    1804:	8a e1       	ldi	r24, 0x1A	; 26
    1806:	92 e0       	ldi	r25, 0x02	; 2
    1808:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
}
    180c:	08 95       	ret

0000180e <DisplayConfig>:

void DisplayConfig(void)
{
    180e:	0f 93       	push	r16
    1810:	1f 93       	push	r17
    1812:	cf 93       	push	r28
    1814:	df 93       	push	r29
//-----------------------------------------------------------------------------


void DisplayBar(void)
{
	printf("\r\n================================================\r\n");
    1816:	8a e1       	ldi	r24, 0x1A	; 26
    1818:	92 e0       	ldi	r25, 0x02	; 2
    181a:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
void DisplayConfig(void)
{

	u_char i = 0;
	DisplayBar();
	printf("       Net Config Information..\r\n");
    181e:	8e e4       	ldi	r24, 0x4E	; 78
    1820:	92 e0       	ldi	r25, 0x02	; 2
    1822:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
//-----------------------------------------------------------------------------


void DisplayBar(void)
{
	printf("\r\n================================================\r\n");
    1826:	8a e1       	ldi	r24, 0x1A	; 26
    1828:	92 e0       	ldi	r25, 0x02	; 2
    182a:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
	u_char i = 0;
	DisplayBar();
	printf("       Net Config Information..\r\n");
	DisplayBar();
	
	printf("MAC ADDRESS      : ");
    182e:	00 d0       	rcall	.+0      	; 0x1830 <DisplayConfig+0x22>
    1830:	8f e6       	ldi	r24, 0x6F	; 111
    1832:	92 e0       	ldi	r25, 0x02	; 2
    1834:	ad b7       	in	r26, 0x3d	; 61
    1836:	be b7       	in	r27, 0x3e	; 62
    1838:	12 96       	adiw	r26, 0x02	; 2
    183a:	9c 93       	st	X, r25
    183c:	8e 93       	st	-X, r24
    183e:	11 97       	sbiw	r26, 0x01	; 1
    1840:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    1844:	c8 e0       	ldi	r28, 0x08	; 8
    1846:	d0 e8       	ldi	r29, 0x80	; 128
    1848:	0f 90       	pop	r0
    184a:	0f 90       	pop	r0
	for(i=0; i<6;i++)printf("0x%02X.",IINCHIP_READ(SHAR0+i));
    184c:	03 e8       	ldi	r16, 0x83	; 131
    184e:	12 e0       	ldi	r17, 0x02	; 2
    1850:	ce 01       	movw	r24, r28
    1852:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    1856:	00 d0       	rcall	.+0      	; 0x1858 <DisplayConfig+0x4a>
    1858:	00 d0       	rcall	.+0      	; 0x185a <DisplayConfig+0x4c>
    185a:	ed b7       	in	r30, 0x3d	; 61
    185c:	fe b7       	in	r31, 0x3e	; 62
    185e:	31 96       	adiw	r30, 0x01	; 1
    1860:	ad b7       	in	r26, 0x3d	; 61
    1862:	be b7       	in	r27, 0x3e	; 62
    1864:	12 96       	adiw	r26, 0x02	; 2
    1866:	1c 93       	st	X, r17
    1868:	0e 93       	st	-X, r16
    186a:	11 97       	sbiw	r26, 0x01	; 1
    186c:	82 83       	std	Z+2, r24	; 0x02
    186e:	13 82       	std	Z+3, r1	; 0x03
    1870:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    1874:	21 96       	adiw	r28, 0x01	; 1
    1876:	0f 90       	pop	r0
    1878:	0f 90       	pop	r0
    187a:	0f 90       	pop	r0
    187c:	0f 90       	pop	r0
    187e:	b0 e8       	ldi	r27, 0x80	; 128
    1880:	ce 30       	cpi	r28, 0x0E	; 14
    1882:	db 07       	cpc	r29, r27
    1884:	29 f7       	brne	.-54     	; 0x1850 <DisplayConfig+0x42>
	

	printf("\r\nSUBNET MASK      : ");
    1886:	00 d0       	rcall	.+0      	; 0x1888 <DisplayConfig+0x7a>
    1888:	8b e8       	ldi	r24, 0x8B	; 139
    188a:	92 e0       	ldi	r25, 0x02	; 2
    188c:	ed b7       	in	r30, 0x3d	; 61
    188e:	fe b7       	in	r31, 0x3e	; 62
    1890:	92 83       	std	Z+2, r25	; 0x02
    1892:	81 83       	std	Z+1, r24	; 0x01
    1894:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
	for(i=0; i < 4; i++)
	{
		printf("%d.", (char)IINCHIP_READ(SUBR0+i));
    1898:	0f 90       	pop	r0
    189a:	0f 90       	pop	r0
    189c:	84 e1       	ldi	r24, 0x14	; 20
    189e:	90 e8       	ldi	r25, 0x80	; 128
    18a0:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    18a4:	00 d0       	rcall	.+0      	; 0x18a6 <DisplayConfig+0x98>
    18a6:	00 d0       	rcall	.+0      	; 0x18a8 <DisplayConfig+0x9a>
    18a8:	ed b7       	in	r30, 0x3d	; 61
    18aa:	fe b7       	in	r31, 0x3e	; 62
    18ac:	31 96       	adiw	r30, 0x01	; 1
    18ae:	01 ea       	ldi	r16, 0xA1	; 161
    18b0:	12 e0       	ldi	r17, 0x02	; 2
    18b2:	ad b7       	in	r26, 0x3d	; 61
    18b4:	be b7       	in	r27, 0x3e	; 62
    18b6:	12 96       	adiw	r26, 0x02	; 2
    18b8:	1c 93       	st	X, r17
    18ba:	0e 93       	st	-X, r16
    18bc:	11 97       	sbiw	r26, 0x01	; 1
    18be:	82 83       	std	Z+2, r24	; 0x02
    18c0:	13 82       	std	Z+3, r1	; 0x03
    18c2:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    18c6:	0f 90       	pop	r0
    18c8:	0f 90       	pop	r0
    18ca:	0f 90       	pop	r0
    18cc:	0f 90       	pop	r0
    18ce:	85 e1       	ldi	r24, 0x15	; 21
    18d0:	90 e8       	ldi	r25, 0x80	; 128
    18d2:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    18d6:	00 d0       	rcall	.+0      	; 0x18d8 <DisplayConfig+0xca>
    18d8:	00 d0       	rcall	.+0      	; 0x18da <DisplayConfig+0xcc>
    18da:	ed b7       	in	r30, 0x3d	; 61
    18dc:	fe b7       	in	r31, 0x3e	; 62
    18de:	31 96       	adiw	r30, 0x01	; 1
    18e0:	ad b7       	in	r26, 0x3d	; 61
    18e2:	be b7       	in	r27, 0x3e	; 62
    18e4:	12 96       	adiw	r26, 0x02	; 2
    18e6:	1c 93       	st	X, r17
    18e8:	0e 93       	st	-X, r16
    18ea:	11 97       	sbiw	r26, 0x01	; 1
    18ec:	82 83       	std	Z+2, r24	; 0x02
    18ee:	13 82       	std	Z+3, r1	; 0x03
    18f0:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    18f4:	0f 90       	pop	r0
    18f6:	0f 90       	pop	r0
    18f8:	0f 90       	pop	r0
    18fa:	0f 90       	pop	r0
    18fc:	86 e1       	ldi	r24, 0x16	; 22
    18fe:	90 e8       	ldi	r25, 0x80	; 128
    1900:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    1904:	00 d0       	rcall	.+0      	; 0x1906 <DisplayConfig+0xf8>
    1906:	00 d0       	rcall	.+0      	; 0x1908 <DisplayConfig+0xfa>
    1908:	ed b7       	in	r30, 0x3d	; 61
    190a:	fe b7       	in	r31, 0x3e	; 62
    190c:	31 96       	adiw	r30, 0x01	; 1
    190e:	ad b7       	in	r26, 0x3d	; 61
    1910:	be b7       	in	r27, 0x3e	; 62
    1912:	12 96       	adiw	r26, 0x02	; 2
    1914:	1c 93       	st	X, r17
    1916:	0e 93       	st	-X, r16
    1918:	11 97       	sbiw	r26, 0x01	; 1
    191a:	82 83       	std	Z+2, r24	; 0x02
    191c:	13 82       	std	Z+3, r1	; 0x03
    191e:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    1922:	0f 90       	pop	r0
    1924:	0f 90       	pop	r0
    1926:	0f 90       	pop	r0
    1928:	0f 90       	pop	r0
    192a:	87 e1       	ldi	r24, 0x17	; 23
    192c:	90 e8       	ldi	r25, 0x80	; 128
    192e:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    1932:	00 d0       	rcall	.+0      	; 0x1934 <DisplayConfig+0x126>
    1934:	00 d0       	rcall	.+0      	; 0x1936 <DisplayConfig+0x128>
    1936:	ed b7       	in	r30, 0x3d	; 61
    1938:	fe b7       	in	r31, 0x3e	; 62
    193a:	31 96       	adiw	r30, 0x01	; 1
    193c:	ad b7       	in	r26, 0x3d	; 61
    193e:	be b7       	in	r27, 0x3e	; 62
    1940:	12 96       	adiw	r26, 0x02	; 2
    1942:	1c 93       	st	X, r17
    1944:	0e 93       	st	-X, r16
    1946:	11 97       	sbiw	r26, 0x01	; 1
    1948:	82 83       	std	Z+2, r24	; 0x02
    194a:	13 82       	std	Z+3, r1	; 0x03
    194c:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
	}


	printf("\r\nG/W IP ADDRESS   : ");
    1950:	0f 90       	pop	r0
    1952:	0f 90       	pop	r0
    1954:	85 ea       	ldi	r24, 0xA5	; 165
    1956:	92 e0       	ldi	r25, 0x02	; 2
    1958:	ed b7       	in	r30, 0x3d	; 61
    195a:	fe b7       	in	r31, 0x3e	; 62
    195c:	92 83       	std	Z+2, r25	; 0x02
    195e:	81 83       	std	Z+1, r24	; 0x01
    1960:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
	for(i=0; i < 4; i++)
	{
		printf("%d.", (char)IINCHIP_READ(GAR0+i));
    1964:	0f 90       	pop	r0
    1966:	0f 90       	pop	r0
    1968:	80 e1       	ldi	r24, 0x10	; 16
    196a:	90 e8       	ldi	r25, 0x80	; 128
    196c:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    1970:	00 d0       	rcall	.+0      	; 0x1972 <DisplayConfig+0x164>
    1972:	00 d0       	rcall	.+0      	; 0x1974 <DisplayConfig+0x166>
    1974:	ed b7       	in	r30, 0x3d	; 61
    1976:	fe b7       	in	r31, 0x3e	; 62
    1978:	31 96       	adiw	r30, 0x01	; 1
    197a:	ad b7       	in	r26, 0x3d	; 61
    197c:	be b7       	in	r27, 0x3e	; 62
    197e:	12 96       	adiw	r26, 0x02	; 2
    1980:	1c 93       	st	X, r17
    1982:	0e 93       	st	-X, r16
    1984:	11 97       	sbiw	r26, 0x01	; 1
    1986:	82 83       	std	Z+2, r24	; 0x02
    1988:	13 82       	std	Z+3, r1	; 0x03
    198a:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    198e:	0f 90       	pop	r0
    1990:	0f 90       	pop	r0
    1992:	0f 90       	pop	r0
    1994:	0f 90       	pop	r0
    1996:	81 e1       	ldi	r24, 0x11	; 17
    1998:	90 e8       	ldi	r25, 0x80	; 128
    199a:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    199e:	00 d0       	rcall	.+0      	; 0x19a0 <DisplayConfig+0x192>
    19a0:	00 d0       	rcall	.+0      	; 0x19a2 <DisplayConfig+0x194>
    19a2:	ed b7       	in	r30, 0x3d	; 61
    19a4:	fe b7       	in	r31, 0x3e	; 62
    19a6:	31 96       	adiw	r30, 0x01	; 1
    19a8:	ad b7       	in	r26, 0x3d	; 61
    19aa:	be b7       	in	r27, 0x3e	; 62
    19ac:	12 96       	adiw	r26, 0x02	; 2
    19ae:	1c 93       	st	X, r17
    19b0:	0e 93       	st	-X, r16
    19b2:	11 97       	sbiw	r26, 0x01	; 1
    19b4:	82 83       	std	Z+2, r24	; 0x02
    19b6:	13 82       	std	Z+3, r1	; 0x03
    19b8:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    19bc:	0f 90       	pop	r0
    19be:	0f 90       	pop	r0
    19c0:	0f 90       	pop	r0
    19c2:	0f 90       	pop	r0
    19c4:	82 e1       	ldi	r24, 0x12	; 18
    19c6:	90 e8       	ldi	r25, 0x80	; 128
    19c8:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    19cc:	00 d0       	rcall	.+0      	; 0x19ce <DisplayConfig+0x1c0>
    19ce:	00 d0       	rcall	.+0      	; 0x19d0 <DisplayConfig+0x1c2>
    19d0:	ed b7       	in	r30, 0x3d	; 61
    19d2:	fe b7       	in	r31, 0x3e	; 62
    19d4:	31 96       	adiw	r30, 0x01	; 1
    19d6:	ad b7       	in	r26, 0x3d	; 61
    19d8:	be b7       	in	r27, 0x3e	; 62
    19da:	12 96       	adiw	r26, 0x02	; 2
    19dc:	1c 93       	st	X, r17
    19de:	0e 93       	st	-X, r16
    19e0:	11 97       	sbiw	r26, 0x01	; 1
    19e2:	82 83       	std	Z+2, r24	; 0x02
    19e4:	13 82       	std	Z+3, r1	; 0x03
    19e6:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    19ea:	0f 90       	pop	r0
    19ec:	0f 90       	pop	r0
    19ee:	0f 90       	pop	r0
    19f0:	0f 90       	pop	r0
    19f2:	83 e1       	ldi	r24, 0x13	; 19
    19f4:	90 e8       	ldi	r25, 0x80	; 128
    19f6:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    19fa:	00 d0       	rcall	.+0      	; 0x19fc <DisplayConfig+0x1ee>
    19fc:	00 d0       	rcall	.+0      	; 0x19fe <DisplayConfig+0x1f0>
    19fe:	ed b7       	in	r30, 0x3d	; 61
    1a00:	fe b7       	in	r31, 0x3e	; 62
    1a02:	31 96       	adiw	r30, 0x01	; 1
    1a04:	ad b7       	in	r26, 0x3d	; 61
    1a06:	be b7       	in	r27, 0x3e	; 62
    1a08:	12 96       	adiw	r26, 0x02	; 2
    1a0a:	1c 93       	st	X, r17
    1a0c:	0e 93       	st	-X, r16
    1a0e:	11 97       	sbiw	r26, 0x01	; 1
    1a10:	82 83       	std	Z+2, r24	; 0x02
    1a12:	13 82       	std	Z+3, r1	; 0x03
    1a14:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
	}

	printf("\r\nLOCAL IP ADDRESS : ");
    1a18:	0f 90       	pop	r0
    1a1a:	0f 90       	pop	r0
    1a1c:	8b eb       	ldi	r24, 0xBB	; 187
    1a1e:	92 e0       	ldi	r25, 0x02	; 2
    1a20:	ed b7       	in	r30, 0x3d	; 61
    1a22:	fe b7       	in	r31, 0x3e	; 62
    1a24:	92 83       	std	Z+2, r25	; 0x02
    1a26:	81 83       	std	Z+1, r24	; 0x01
    1a28:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
	for(i=0; i < 4; i++)
	{
		printf("%d.", (char)IINCHIP_READ(SIPR0+i));
    1a2c:	0f 90       	pop	r0
    1a2e:	0f 90       	pop	r0
    1a30:	88 e1       	ldi	r24, 0x18	; 24
    1a32:	90 e8       	ldi	r25, 0x80	; 128
    1a34:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    1a38:	00 d0       	rcall	.+0      	; 0x1a3a <DisplayConfig+0x22c>
    1a3a:	00 d0       	rcall	.+0      	; 0x1a3c <DisplayConfig+0x22e>
    1a3c:	ed b7       	in	r30, 0x3d	; 61
    1a3e:	fe b7       	in	r31, 0x3e	; 62
    1a40:	31 96       	adiw	r30, 0x01	; 1
    1a42:	ad b7       	in	r26, 0x3d	; 61
    1a44:	be b7       	in	r27, 0x3e	; 62
    1a46:	12 96       	adiw	r26, 0x02	; 2
    1a48:	1c 93       	st	X, r17
    1a4a:	0e 93       	st	-X, r16
    1a4c:	11 97       	sbiw	r26, 0x01	; 1
    1a4e:	82 83       	std	Z+2, r24	; 0x02
    1a50:	13 82       	std	Z+3, r1	; 0x03
    1a52:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    1a56:	0f 90       	pop	r0
    1a58:	0f 90       	pop	r0
    1a5a:	0f 90       	pop	r0
    1a5c:	0f 90       	pop	r0
    1a5e:	89 e1       	ldi	r24, 0x19	; 25
    1a60:	90 e8       	ldi	r25, 0x80	; 128
    1a62:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    1a66:	00 d0       	rcall	.+0      	; 0x1a68 <DisplayConfig+0x25a>
    1a68:	00 d0       	rcall	.+0      	; 0x1a6a <DisplayConfig+0x25c>
    1a6a:	ed b7       	in	r30, 0x3d	; 61
    1a6c:	fe b7       	in	r31, 0x3e	; 62
    1a6e:	31 96       	adiw	r30, 0x01	; 1
    1a70:	ad b7       	in	r26, 0x3d	; 61
    1a72:	be b7       	in	r27, 0x3e	; 62
    1a74:	12 96       	adiw	r26, 0x02	; 2
    1a76:	1c 93       	st	X, r17
    1a78:	0e 93       	st	-X, r16
    1a7a:	11 97       	sbiw	r26, 0x01	; 1
    1a7c:	82 83       	std	Z+2, r24	; 0x02
    1a7e:	13 82       	std	Z+3, r1	; 0x03
    1a80:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    1a84:	0f 90       	pop	r0
    1a86:	0f 90       	pop	r0
    1a88:	0f 90       	pop	r0
    1a8a:	0f 90       	pop	r0
    1a8c:	8a e1       	ldi	r24, 0x1A	; 26
    1a8e:	90 e8       	ldi	r25, 0x80	; 128
    1a90:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    1a94:	00 d0       	rcall	.+0      	; 0x1a96 <DisplayConfig+0x288>
    1a96:	00 d0       	rcall	.+0      	; 0x1a98 <DisplayConfig+0x28a>
    1a98:	ed b7       	in	r30, 0x3d	; 61
    1a9a:	fe b7       	in	r31, 0x3e	; 62
    1a9c:	31 96       	adiw	r30, 0x01	; 1
    1a9e:	ad b7       	in	r26, 0x3d	; 61
    1aa0:	be b7       	in	r27, 0x3e	; 62
    1aa2:	12 96       	adiw	r26, 0x02	; 2
    1aa4:	1c 93       	st	X, r17
    1aa6:	0e 93       	st	-X, r16
    1aa8:	11 97       	sbiw	r26, 0x01	; 1
    1aaa:	82 83       	std	Z+2, r24	; 0x02
    1aac:	13 82       	std	Z+3, r1	; 0x03
    1aae:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
    1ab2:	0f 90       	pop	r0
    1ab4:	0f 90       	pop	r0
    1ab6:	0f 90       	pop	r0
    1ab8:	0f 90       	pop	r0
    1aba:	8b e1       	ldi	r24, 0x1B	; 27
    1abc:	90 e8       	ldi	r25, 0x80	; 128
    1abe:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    1ac2:	00 d0       	rcall	.+0      	; 0x1ac4 <DisplayConfig+0x2b6>
    1ac4:	00 d0       	rcall	.+0      	; 0x1ac6 <DisplayConfig+0x2b8>
    1ac6:	ed b7       	in	r30, 0x3d	; 61
    1ac8:	fe b7       	in	r31, 0x3e	; 62
    1aca:	31 96       	adiw	r30, 0x01	; 1
    1acc:	ad b7       	in	r26, 0x3d	; 61
    1ace:	be b7       	in	r27, 0x3e	; 62
    1ad0:	12 96       	adiw	r26, 0x02	; 2
    1ad2:	1c 93       	st	X, r17
    1ad4:	0e 93       	st	-X, r16
    1ad6:	11 97       	sbiw	r26, 0x01	; 1
    1ad8:	82 83       	std	Z+2, r24	; 0x02
    1ada:	13 82       	std	Z+3, r1	; 0x03
    1adc:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
//-----------------------------------------------------------------------------


void DisplayBar(void)
{
	printf("\r\n================================================\r\n");
    1ae0:	0f 90       	pop	r0
    1ae2:	0f 90       	pop	r0
    1ae4:	0f 90       	pop	r0
    1ae6:	0f 90       	pop	r0
    1ae8:	8a e1       	ldi	r24, 0x1A	; 26
    1aea:	92 e0       	ldi	r25, 0x02	; 2
    1aec:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
	{
		printf("%d.", (char)IINCHIP_READ(SIPR0+i));
	}

	DisplayBar();
}
    1af0:	df 91       	pop	r29
    1af2:	cf 91       	pop	r28
    1af4:	1f 91       	pop	r17
    1af6:	0f 91       	pop	r16
    1af8:	08 95       	ret

00001afa <NetInit>:
void ProcessTCPServer(SOCKET Sock, unsigned int Port);
void ProcessUDP(SOCKET Sock, unsigned int Port);

//-----------------------------------------------------------------------------
void NetInit(void)
{
    1afa:	df 93       	push	r29
    1afc:	cf 93       	push	r28
    1afe:	cd b7       	in	r28, 0x3d	; 61
    1b00:	de b7       	in	r29, 0x3e	; 62
    1b02:	6a 97       	sbiw	r28, 0x1a	; 26
    1b04:	0f b6       	in	r0, 0x3f	; 63
    1b06:	f8 94       	cli
    1b08:	de bf       	out	0x3e, r29	; 62
    1b0a:	0f be       	out	0x3f, r0	; 63
    1b0c:	cd bf       	out	0x3d, r28	; 61
	unsigned long dd = 100000;

	unsigned char mac[6]	= MY_NET_MAC;
    1b0e:	de 01       	movw	r26, r28
    1b10:	1d 96       	adiw	r26, 0x0d	; 13
    1b12:	e2 e1       	ldi	r30, 0x12	; 18
    1b14:	f3 e0       	ldi	r31, 0x03	; 3
    1b16:	86 e0       	ldi	r24, 0x06	; 6
    1b18:	01 90       	ld	r0, Z+
    1b1a:	0d 92       	st	X+, r0
    1b1c:	81 50       	subi	r24, 0x01	; 1
    1b1e:	e1 f7       	brne	.-8      	; 0x1b18 <NetInit+0x1e>
	unsigned char sm[4]	= MY_SUBNET;
    1b20:	8f ef       	ldi	r24, 0xFF	; 255
    1b22:	89 83       	std	Y+1, r24	; 0x01
    1b24:	8a 83       	std	Y+2, r24	; 0x02
    1b26:	8b 83       	std	Y+3, r24	; 0x03
    1b28:	1c 82       	std	Y+4, r1	; 0x04
	unsigned char gwip[4]	= MY_NET_GWIP;
    1b2a:	20 ec       	ldi	r18, 0xC0	; 192
    1b2c:	2d 83       	std	Y+5, r18	; 0x05
    1b2e:	98 ea       	ldi	r25, 0xA8	; 168
    1b30:	9e 83       	std	Y+6, r25	; 0x06
    1b32:	1f 82       	std	Y+7, r1	; 0x07
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	88 87       	std	Y+8, r24	; 0x08
	unsigned char m_sip[4]	= MY_SOURCEIP;
    1b38:	29 87       	std	Y+9, r18	; 0x09
    1b3a:	9a 87       	std	Y+10, r25	; 0x0a
    1b3c:	1b 86       	std	Y+11, r1	; 0x0b
    1b3e:	83 e0       	ldi	r24, 0x03	; 3
    1b40:	8c 87       	std	Y+12, r24	; 0x0c

	unsigned char tx_mem_conf[8] = {8,8,8,8,8,8,8,8};          // for setting TMSR regsiter
    1b42:	de 01       	movw	r26, r28
    1b44:	53 96       	adiw	r26, 0x13	; 19
    1b46:	ea e0       	ldi	r30, 0x0A	; 10
    1b48:	f3 e0       	ldi	r31, 0x03	; 3
    1b4a:	88 e0       	ldi	r24, 0x08	; 8
    1b4c:	01 90       	ld	r0, Z+
    1b4e:	0d 92       	st	X+, r0
    1b50:	81 50       	subi	r24, 0x01	; 1
    1b52:	e1 f7       	brne	.-8      	; 0x1b4c <NetInit+0x52>
//	unsigned char rx_mem_conf[8] = {8,8,8,8,8,8,8,8};          // for setting RMSR regsiter
	
	//W5300 Chip Init
	iinchip_init();
    1b54:	0e 94 ce 0a 	call	0x159c	; 0x159c <iinchip_init>

	while(dd--);

	//Set MAC Address
	setSHAR(mac);
    1b58:	ce 01       	movw	r24, r28
    1b5a:	0d 96       	adiw	r24, 0x0d	; 13
    1b5c:	0e 94 1b 06 	call	0xc36	; 0xc36 <setSHAR>

	//Set Gateway
	setGAR(gwip);
    1b60:	ce 01       	movw	r24, r28
    1b62:	05 96       	adiw	r24, 0x05	; 5
    1b64:	0e 94 33 06 	call	0xc66	; 0xc66 <setGAR>

	//Set Subnet Mask
	setSUBR(sm);
    1b68:	ce 01       	movw	r24, r28
    1b6a:	01 96       	adiw	r24, 0x01	; 1
    1b6c:	0e 94 4f 06 	call	0xc9e	; 0xc9e <setSUBR>

	//Set My IP
	setSIPR(m_sip);
    1b70:	ce 01       	movw	r24, r28
    1b72:	09 96       	adiw	r24, 0x09	; 9
    1b74:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <setSIPR>
#endif
	
	//sysinit(MY_NET_MEMALLOC, MY_NET_MEMALLOC);

   /* allocate internal TX/RX Memory of W5300 */
   if(!sysinit(tx_mem_conf, tx_mem_conf))           
    1b78:	be 01       	movw	r22, r28
    1b7a:	6d 5e       	subi	r22, 0xED	; 237
    1b7c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b7e:	cb 01       	movw	r24, r22
    1b80:	0e 94 c5 09 	call	0x138a	; 0x138a <sysinit>
    1b84:	88 23       	and	r24, r24
    1b86:	09 f4       	brne	.+2      	; 0x1b8a <NetInit+0x90>
    1b88:	ff cf       	rjmp	.-2      	; 0x1b88 <NetInit+0x8e>
   {
  //    printf("MEMORY CONFIG ERR.\r\n");
      while(1);
   }	
}
    1b8a:	6a 96       	adiw	r28, 0x1a	; 26
    1b8c:	0f b6       	in	r0, 0x3f	; 63
    1b8e:	f8 94       	cli
    1b90:	de bf       	out	0x3e, r29	; 62
    1b92:	0f be       	out	0x3f, r0	; 63
    1b94:	cd bf       	out	0x3d, r28	; 61
    1b96:	cf 91       	pop	r28
    1b98:	df 91       	pop	r29
    1b9a:	08 95       	ret

00001b9c <main>:

//-----------------------------------------------------------------------------
int main(void)
{
	//EVB Initialize
	evb_init();
    1b9c:	0e 94 72 01 	call	0x2e4	; 0x2e4 <evb_init>
	
	printf("\r\nWIZ-Embedded WebServer - Simple TCP, UDP Test Program.");
    1ba0:	00 d0       	rcall	.+0      	; 0x1ba2 <main+0x6>
    1ba2:	81 ed       	ldi	r24, 0xD1	; 209
    1ba4:	92 e0       	ldi	r25, 0x02	; 2
    1ba6:	ed b7       	in	r30, 0x3d	; 61
    1ba8:	fe b7       	in	r31, 0x3e	; 62
    1baa:	92 83       	std	Z+2, r25	; 0x02
    1bac:	81 83       	std	Z+1, r24	; 0x01
    1bae:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>

	
	//W5300 Chip Initialize
	//----------------------------
	NetInit();
    1bb2:	0f 90       	pop	r0
    1bb4:	0f 90       	pop	r0
    1bb6:	0e 94 7d 0d 	call	0x1afa	; 0x1afa <NetInit>

	//----------------------------


	//Display Net Configuration..
	DisplayConfig();	
    1bba:	0e 94 07 0c 	call	0x180e	; 0x180e <DisplayConfig>
	

	while (1)
	{
		//TCP Loopback Test
		ProcessTCPServer(0, 5000);
    1bbe:	80 e0       	ldi	r24, 0x00	; 0
    1bc0:	68 e8       	ldi	r22, 0x88	; 136
    1bc2:	73 e1       	ldi	r23, 0x13	; 19
    1bc4:	0e 94 89 0b 	call	0x1712	; 0x1712 <ProcessTCPServer>

		//UDP Loopback Test
		ProcessUDP(1, 3000);
    1bc8:	81 e0       	ldi	r24, 0x01	; 1
    1bca:	68 eb       	ldi	r22, 0xB8	; 184
    1bcc:	7b e0       	ldi	r23, 0x0B	; 11
    1bce:	0e 94 d6 0a 	call	0x15ac	; 0x15ac <ProcessUDP>
    1bd2:	f5 cf       	rjmp	.-22     	; 0x1bbe <main+0x22>

00001bd4 <wait_1us>:
#include "delay.h"


//---- MODIFY_2005_10_31 : PM-A1 V1.1 --> V1.2 (16MHz --> 8MHz)
void wait_1us(u_int cnt)
{
    1bd4:	af 92       	push	r10
    1bd6:	bf 92       	push	r11
    1bd8:	cf 92       	push	r12
    1bda:	df 92       	push	r13
    1bdc:	ef 92       	push	r14
    1bde:	ff 92       	push	r15
    1be0:	0f 93       	push	r16
    1be2:	1f 93       	push	r17
		"nop"				"\n\t"
		:  :"r" (cnt)
	);	
*/
	//+2008/11/20 - jhpark	use WinAVR Lib for winaver 2008 version
	_delay_us(cnt);	
    1be4:	a0 e0       	ldi	r26, 0x00	; 0
    1be6:	b0 e0       	ldi	r27, 0x00	; 0
    1be8:	bc 01       	movw	r22, r24
    1bea:	cd 01       	movw	r24, r26
    1bec:	0e 94 eb 1b 	call	0x37d6	; 0x37d6 <__floatunsisf>
    1bf0:	5b 01       	movw	r10, r22
    1bf2:	6c 01       	movw	r12, r24
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    1bf4:	2b ea       	ldi	r18, 0xAB	; 171
    1bf6:	3a ea       	ldi	r19, 0xAA	; 170
    1bf8:	4a ea       	ldi	r20, 0xAA	; 170
    1bfa:	5e e3       	ldi	r21, 0x3E	; 62
    1bfc:	0e 94 61 19 	call	0x32c2	; 0x32c2 <__mulsf3>
    1c00:	7b 01       	movw	r14, r22
    1c02:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    1c04:	20 e0       	ldi	r18, 0x00	; 0
    1c06:	30 e0       	ldi	r19, 0x00	; 0
    1c08:	40 e8       	ldi	r20, 0x80	; 128
    1c0a:	5f e3       	ldi	r21, 0x3F	; 63
    1c0c:	0e 94 67 1b 	call	0x36ce	; 0x36ce <__ltsf2>
    1c10:	88 23       	and	r24, r24
    1c12:	14 f4       	brge	.+4      	; 0x1c18 <wait_1us+0x44>
    1c14:	61 e0       	ldi	r22, 0x01	; 1
    1c16:	54 c0       	rjmp	.+168    	; 0x1cc0 <wait_1us+0xec>
		__ticks = 1;
	else if (__tmp > 255)
    1c18:	c8 01       	movw	r24, r16
    1c1a:	b7 01       	movw	r22, r14
    1c1c:	20 e0       	ldi	r18, 0x00	; 0
    1c1e:	30 e0       	ldi	r19, 0x00	; 0
    1c20:	4f e7       	ldi	r20, 0x7F	; 127
    1c22:	53 e4       	ldi	r21, 0x43	; 67
    1c24:	0e 94 07 1b 	call	0x360e	; 0x360e <__gtsf2>
    1c28:	18 16       	cp	r1, r24
    1c2a:	0c f0       	brlt	.+2      	; 0x1c2e <wait_1us+0x5a>
    1c2c:	45 c0       	rjmp	.+138    	; 0x1cb8 <wait_1us+0xe4>
	{
		_delay_ms(__us / 1000.0);
    1c2e:	c6 01       	movw	r24, r12
    1c30:	b5 01       	movw	r22, r10
    1c32:	20 e0       	ldi	r18, 0x00	; 0
    1c34:	30 e0       	ldi	r19, 0x00	; 0
    1c36:	4a e7       	ldi	r20, 0x7A	; 122
    1c38:	54 e4       	ldi	r21, 0x44	; 68
    1c3a:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <__divsf3>
    1c3e:	5b 01       	movw	r10, r22
    1c40:	6c 01       	movw	r12, r24
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1c42:	20 e0       	ldi	r18, 0x00	; 0
    1c44:	30 e0       	ldi	r19, 0x00	; 0
    1c46:	4a e7       	ldi	r20, 0x7A	; 122
    1c48:	53 e4       	ldi	r21, 0x43	; 67
    1c4a:	0e 94 61 19 	call	0x32c2	; 0x32c2 <__mulsf3>
    1c4e:	7b 01       	movw	r14, r22
    1c50:	8c 01       	movw	r16, r24
	if (__tmp < 1.0)
    1c52:	20 e0       	ldi	r18, 0x00	; 0
    1c54:	30 e0       	ldi	r19, 0x00	; 0
    1c56:	40 e8       	ldi	r20, 0x80	; 128
    1c58:	5f e3       	ldi	r21, 0x3F	; 63
    1c5a:	0e 94 67 1b 	call	0x36ce	; 0x36ce <__ltsf2>
    1c5e:	88 23       	and	r24, r24
    1c60:	1c f4       	brge	.+6      	; 0x1c68 <wait_1us+0x94>
    1c62:	61 e0       	ldi	r22, 0x01	; 1
    1c64:	70 e0       	ldi	r23, 0x00	; 0
    1c66:	24 c0       	rjmp	.+72     	; 0x1cb0 <wait_1us+0xdc>
		__ticks = 1;
	else if (__tmp > 65535)
    1c68:	c8 01       	movw	r24, r16
    1c6a:	b7 01       	movw	r22, r14
    1c6c:	20 e0       	ldi	r18, 0x00	; 0
    1c6e:	3f ef       	ldi	r19, 0xFF	; 255
    1c70:	4f e7       	ldi	r20, 0x7F	; 127
    1c72:	57 e4       	ldi	r21, 0x47	; 71
    1c74:	0e 94 07 1b 	call	0x360e	; 0x360e <__gtsf2>
    1c78:	18 16       	cp	r1, r24
    1c7a:	b4 f4       	brge	.+44     	; 0x1ca8 <wait_1us+0xd4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1c7c:	c6 01       	movw	r24, r12
    1c7e:	b5 01       	movw	r22, r10
    1c80:	20 e0       	ldi	r18, 0x00	; 0
    1c82:	30 e0       	ldi	r19, 0x00	; 0
    1c84:	40 e2       	ldi	r20, 0x20	; 32
    1c86:	51 e4       	ldi	r21, 0x41	; 65
    1c88:	0e 94 61 19 	call	0x32c2	; 0x32c2 <__mulsf3>
    1c8c:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <__fixunssfsi>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    1c90:	89 e1       	ldi	r24, 0x19	; 25
    1c92:	90 e0       	ldi	r25, 0x00	; 0
    1c94:	05 c0       	rjmp	.+10     	; 0x1ca0 <wait_1us+0xcc>
    1c96:	fc 01       	movw	r30, r24
    1c98:	31 97       	sbiw	r30, 0x01	; 1
    1c9a:	f1 f7       	brne	.-4      	; 0x1c98 <wait_1us+0xc4>
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    1c9c:	61 50       	subi	r22, 0x01	; 1
    1c9e:	70 40       	sbci	r23, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1ca0:	61 15       	cp	r22, r1
    1ca2:	71 05       	cpc	r23, r1
    1ca4:	c1 f7       	brne	.-16     	; 0x1c96 <wait_1us+0xc2>
    1ca6:	0e c0       	rjmp	.+28     	; 0x1cc4 <wait_1us+0xf0>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1ca8:	c8 01       	movw	r24, r16
    1caa:	b7 01       	movw	r22, r14
    1cac:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <__fixunssfsi>
    1cb0:	cb 01       	movw	r24, r22
    1cb2:	01 97       	sbiw	r24, 0x01	; 1
    1cb4:	f1 f7       	brne	.-4      	; 0x1cb2 <wait_1us+0xde>
    1cb6:	06 c0       	rjmp	.+12     	; 0x1cc4 <wait_1us+0xf0>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    1cb8:	c8 01       	movw	r24, r16
    1cba:	b7 01       	movw	r22, r14
    1cbc:	0e 94 8b 17 	call	0x2f16	; 0x2f16 <__fixunssfsi>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    1cc0:	6a 95       	dec	r22
    1cc2:	f1 f7       	brne	.-4      	; 0x1cc0 <wait_1us+0xec>
}
    1cc4:	1f 91       	pop	r17
    1cc6:	0f 91       	pop	r16
    1cc8:	ff 90       	pop	r15
    1cca:	ef 90       	pop	r14
    1ccc:	df 90       	pop	r13
    1cce:	cf 90       	pop	r12
    1cd0:	bf 90       	pop	r11
    1cd2:	af 90       	pop	r10
    1cd4:	08 95       	ret

00001cd6 <wait_1ms>:
* Returns     : None
* Note        : Internal Function
********************************************************************************
*/
void wait_1ms(u_int cnt)
{
    1cd6:	cf 93       	push	r28
    1cd8:	df 93       	push	r29
    1cda:	ec 01       	movw	r28, r24
    1cdc:	05 c0       	rjmp	.+10     	; 0x1ce8 <wait_1ms+0x12>
	for (; cnt; cnt--) wait_1us(1000);
    1cde:	88 ee       	ldi	r24, 0xE8	; 232
    1ce0:	93 e0       	ldi	r25, 0x03	; 3
    1ce2:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <wait_1us>
    1ce6:	21 97       	sbiw	r28, 0x01	; 1
    1ce8:	20 97       	sbiw	r28, 0x00	; 0
    1cea:	c9 f7       	brne	.-14     	; 0x1cde <wait_1ms+0x8>
}
    1cec:	df 91       	pop	r29
    1cee:	cf 91       	pop	r28
    1cf0:	08 95       	ret

00001cf2 <wait_10ms>:
* Returns     : None
* Note        : Internal Function
********************************************************************************
*/
void wait_10ms(u_int cnt)
{
    1cf2:	cf 93       	push	r28
    1cf4:	df 93       	push	r29
    1cf6:	ec 01       	movw	r28, r24
    1cf8:	05 c0       	rjmp	.+10     	; 0x1d04 <wait_10ms+0x12>
	for (; cnt; cnt--) wait_1ms(10);
    1cfa:	8a e0       	ldi	r24, 0x0A	; 10
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	0e 94 6b 0e 	call	0x1cd6	; 0x1cd6 <wait_1ms>
    1d02:	21 97       	sbiw	r28, 0x01	; 1
    1d04:	20 97       	sbiw	r28, 0x00	; 0
    1d06:	c9 f7       	brne	.-14     	; 0x1cfa <wait_10ms+0x8>
}
    1d08:	df 91       	pop	r29
    1d0a:	cf 91       	pop	r28
    1d0c:	08 95       	ret

00001d0e <__vector_18>:
This function is the signal handler for receive complete interrupt.
for UART0 Internal Function

*/   
ISR(USART0_RX_vect)	/* Interrupt Service Routine for AVR GCC ver. 3.4.6*/
{
    1d0e:	1f 92       	push	r1
    1d10:	0f 92       	push	r0
    1d12:	0f b6       	in	r0, 0x3f	; 63
    1d14:	0f 92       	push	r0
    1d16:	0b b6       	in	r0, 0x3b	; 59
    1d18:	0f 92       	push	r0
    1d1a:	11 24       	eor	r1, r1
    1d1c:	2f 93       	push	r18
    1d1e:	3f 93       	push	r19
    1d20:	4f 93       	push	r20
    1d22:	8f 93       	push	r24
    1d24:	9f 93       	push	r25
    1d26:	ef 93       	push	r30
    1d28:	ff 93       	push	r31
	sio_rxd[0][sio_head[0]] = UDR0;        	/* read RX data from UART0 */
    1d2a:	e0 91 aa 05 	lds	r30, 0x05AA
    1d2e:	f0 91 ab 05 	lds	r31, 0x05AB
    1d32:	8c b1       	in	r24, 0x0c	; 12
    1d34:	e6 57       	subi	r30, 0x76	; 118
    1d36:	fa 4f       	sbci	r31, 0xFA	; 250
    1d38:	80 83       	st	Z, r24
	
	if(SIO_FLOW[0])
    1d3a:	40 91 ae 05 	lds	r20, 0x05AE
    1d3e:	44 23       	and	r20, r20
    1d40:	e1 f0       	breq	.+56     	; 0x1d7a <__vector_18+0x6c>
	{
		if(sio_rxd[0][sio_head[0]] == XOFF_CHAR)
    1d42:	e0 91 aa 05 	lds	r30, 0x05AA
    1d46:	f0 91 ab 05 	lds	r31, 0x05AB
    1d4a:	e6 57       	subi	r30, 0x76	; 118
    1d4c:	fa 4f       	sbci	r31, 0xFA	; 250
    1d4e:	80 81       	ld	r24, Z
    1d50:	83 31       	cpi	r24, 0x13	; 19
    1d52:	21 f4       	brne	.+8      	; 0x1d5c <__vector_18+0x4e>
			SET_PEER_XOFF_STATE(0);
    1d54:	80 91 af 05 	lds	r24, 0x05AF
    1d58:	82 60       	ori	r24, 0x02	; 2
    1d5a:	0c c0       	rjmp	.+24     	; 0x1d74 <__vector_18+0x66>
		else if(sio_rxd[0][sio_head[0]] == XON_CHAR)
    1d5c:	e0 91 aa 05 	lds	r30, 0x05AA
    1d60:	f0 91 ab 05 	lds	r31, 0x05AB
    1d64:	e6 57       	subi	r30, 0x76	; 118
    1d66:	fa 4f       	sbci	r31, 0xFA	; 250
    1d68:	80 81       	ld	r24, Z
    1d6a:	81 31       	cpi	r24, 0x11	; 17
    1d6c:	31 f4       	brne	.+12     	; 0x1d7a <__vector_18+0x6c>
			SET_PEER_XON_STATE(0);
    1d6e:	80 91 af 05 	lds	r24, 0x05AF
    1d72:	8d 7f       	andi	r24, 0xFD	; 253
    1d74:	80 93 af 05 	sts	0x05AF, r24
    1d78:	09 c0       	rjmp	.+18     	; 0x1d8c <__vector_18+0x7e>
		else sio_head[0]++;
	}
	else	sio_head[0]++;
    1d7a:	80 91 aa 05 	lds	r24, 0x05AA
    1d7e:	90 91 ab 05 	lds	r25, 0x05AB
    1d82:	01 96       	adiw	r24, 0x01	; 1
    1d84:	90 93 ab 05 	sts	0x05AB, r25
    1d88:	80 93 aa 05 	sts	0x05AA, r24
	
	if (sio_head[0] == sio_tail[0])
    1d8c:	20 91 aa 05 	lds	r18, 0x05AA
    1d90:	30 91 ab 05 	lds	r19, 0x05AB
    1d94:	80 91 ac 05 	lds	r24, 0x05AC
    1d98:	90 91 ad 05 	lds	r25, 0x05AD
    1d9c:	28 17       	cp	r18, r24
    1d9e:	39 07       	cpc	r19, r25
    1da0:	a1 f4       	brne	.+40     	; 0x1dca <__vector_18+0xbc>
	{
		if(SIO_FLOW[0])
    1da2:	44 23       	and	r20, r20
    1da4:	49 f0       	breq	.+18     	; 0x1db8 <__vector_18+0xaa>
		{
			while (!(UCSR0A & 0x20)) ;	
    1da6:	5d 9b       	sbis	0x0b, 5	; 11
    1da8:	fe cf       	rjmp	.-4      	; 0x1da6 <__vector_18+0x98>
			UDR0 = XOFF_CHAR;
    1daa:	83 e1       	ldi	r24, 0x13	; 19
    1dac:	8c b9       	out	0x0c, r24	; 12
			SET_MY_XOFF_STATE(0);
    1dae:	80 91 af 05 	lds	r24, 0x05AF
    1db2:	81 60       	ori	r24, 0x01	; 1
    1db4:	80 93 af 05 	sts	0x05AF, r24
		}
		sio_head[0]--;	/* buffer full. */
    1db8:	80 91 aa 05 	lds	r24, 0x05AA
    1dbc:	90 91 ab 05 	lds	r25, 0x05AB
    1dc0:	01 97       	sbiw	r24, 0x01	; 1
    1dc2:	90 93 ab 05 	sts	0x05AB, r25
    1dc6:	80 93 aa 05 	sts	0x05AA, r24
	}
	if (sio_head[0] >= MAX_SIO_COUNT)		/* for ring buffer */
    1dca:	80 91 aa 05 	lds	r24, 0x05AA
    1dce:	90 91 ab 05 	lds	r25, 0x05AB
    1dd2:	80 97       	sbiw	r24, 0x20	; 32
    1dd4:	ac f0       	brlt	.+42     	; 0x1e00 <__vector_18+0xf2>
	{
		sio_head[0] = 0;
    1dd6:	10 92 ab 05 	sts	0x05AB, r1
    1dda:	10 92 aa 05 	sts	0x05AA, r1
		if (sio_head[0] == sio_tail[0]) sio_head[0] = MAX_SIO_COUNT;
    1dde:	20 91 aa 05 	lds	r18, 0x05AA
    1de2:	30 91 ab 05 	lds	r19, 0x05AB
    1de6:	80 91 ac 05 	lds	r24, 0x05AC
    1dea:	90 91 ad 05 	lds	r25, 0x05AD
    1dee:	28 17       	cp	r18, r24
    1df0:	39 07       	cpc	r19, r25
    1df2:	31 f4       	brne	.+12     	; 0x1e00 <__vector_18+0xf2>
    1df4:	80 e2       	ldi	r24, 0x20	; 32
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	90 93 ab 05 	sts	0x05AB, r25
    1dfc:	80 93 aa 05 	sts	0x05AA, r24
	}
}
    1e00:	ff 91       	pop	r31
    1e02:	ef 91       	pop	r30
    1e04:	9f 91       	pop	r25
    1e06:	8f 91       	pop	r24
    1e08:	4f 91       	pop	r20
    1e0a:	3f 91       	pop	r19
    1e0c:	2f 91       	pop	r18
    1e0e:	0f 90       	pop	r0
    1e10:	0b be       	out	0x3b, r0	; 59
    1e12:	0f 90       	pop	r0
    1e14:	0f be       	out	0x3f, r0	; 63
    1e16:	0f 90       	pop	r0
    1e18:	1f 90       	pop	r1
    1e1a:	18 95       	reti

00001e1c <uart_databit>:
////---- END_MODIFY


void uart_databit(u_char uart, u_char dbit)
{
	if(uart == 0)
    1e1c:	88 23       	and	r24, r24
    1e1e:	91 f4       	brne	.+36     	; 0x1e44 <uart_databit+0x28>
	{
		UCSR0C |= 1 << 3;
    1e20:	80 91 95 00 	lds	r24, 0x0095
    1e24:	88 60       	ori	r24, 0x08	; 8
    1e26:	80 93 95 00 	sts	0x0095, r24
		if(!dbit) UCSR0C &= ~(1<<1);	// 7bit
    1e2a:	66 23       	and	r22, r22
    1e2c:	31 f4       	brne	.+12     	; 0x1e3a <uart_databit+0x1e>
    1e2e:	80 91 95 00 	lds	r24, 0x0095
    1e32:	8d 7f       	andi	r24, 0xFD	; 253
    1e34:	80 93 95 00 	sts	0x0095, r24
    1e38:	08 95       	ret
		else	 UCSR0C |= (1<<1);	// 8bit;
    1e3a:	80 91 95 00 	lds	r24, 0x0095
    1e3e:	82 60       	ori	r24, 0x02	; 2
    1e40:	80 93 95 00 	sts	0x0095, r24
    1e44:	08 95       	ret

00001e46 <uart_stopbit>:
#endif	
}

void uart_stopbit(u_char uart,u_char sbit)
{
	if(uart == 0)
    1e46:	88 23       	and	r24, r24
    1e48:	69 f4       	brne	.+26     	; 0x1e64 <uart_stopbit+0x1e>
	{
		if(!sbit) UCSR0C &= ~(1 << 3);	// 1 BIT
    1e4a:	66 23       	and	r22, r22
    1e4c:	31 f4       	brne	.+12     	; 0x1e5a <uart_stopbit+0x14>
    1e4e:	80 91 95 00 	lds	r24, 0x0095
    1e52:	87 7f       	andi	r24, 0xF7	; 247
    1e54:	80 93 95 00 	sts	0x0095, r24
    1e58:	08 95       	ret
		else      UCSR0C |= (1 << 3);	// 2 BIT
    1e5a:	80 91 95 00 	lds	r24, 0x0095
    1e5e:	88 60       	ori	r24, 0x08	; 8
    1e60:	80 93 95 00 	sts	0x0095, r24
    1e64:	08 95       	ret

00001e66 <uart_paritybit>:
#endif	
}

void uart_paritybit(u_char uart,u_char pbit)
{
	if(uart == 0)
    1e66:	88 23       	and	r24, r24
    1e68:	99 f4       	brne	.+38     	; 0x1e90 <uart_paritybit+0x2a>
	{
		if(!pbit)		UCSR0C &= ~(3 << 4);	// none
    1e6a:	66 23       	and	r22, r22
    1e6c:	21 f4       	brne	.+8      	; 0x1e76 <uart_paritybit+0x10>
    1e6e:	80 91 95 00 	lds	r24, 0x0095
    1e72:	8f 7c       	andi	r24, 0xCF	; 207
    1e74:	05 c0       	rjmp	.+10     	; 0x1e80 <uart_paritybit+0x1a>
		else if (pbit ==1) 	UCSR0C &= ~(1 << 4);	// even
    1e76:	61 30       	cpi	r22, 0x01	; 1
    1e78:	31 f4       	brne	.+12     	; 0x1e86 <uart_paritybit+0x20>
    1e7a:	80 91 95 00 	lds	r24, 0x0095
    1e7e:	8f 7e       	andi	r24, 0xEF	; 239
    1e80:	80 93 95 00 	sts	0x0095, r24
    1e84:	08 95       	ret
		else 			UCSR0C |= (3 << 4);	// odd
    1e86:	80 91 95 00 	lds	r24, 0x0095
    1e8a:	80 63       	ori	r24, 0x30	; 48
    1e8c:	80 93 95 00 	sts	0x0095, r24
    1e90:	08 95       	ret

00001e92 <uart_flowctrl>:
#endif	
}

void uart_flowctrl(u_char uart,u_char flow)
{
	if ( uart < UART_DEVICE_CNT )
    1e92:	88 23       	and	r24, r24
    1e94:	11 f4       	brne	.+4      	; 0x1e9a <uart_flowctrl+0x8>
		SIO_FLOW[uart] = flow;
    1e96:	60 93 ae 05 	sts	0x05AE, r22
    1e9a:	08 95       	ret

00001e9c <uart_keyhit>:
if not, return 0

*/
u_int uart_keyhit(u_char uart)
{
	if ( uart >= UART_DEVICE_CNT )
    1e9c:	88 23       	and	r24, r24
    1e9e:	19 f0       	breq	.+6      	; 0x1ea6 <uart_keyhit+0xa>
    1ea0:	20 e0       	ldi	r18, 0x00	; 0
    1ea2:	30 e0       	ldi	r19, 0x00	; 0
    1ea4:	20 c0       	rjmp	.+64     	; 0x1ee6 <uart_keyhit+0x4a>
		return 0;
		
	if(sio_head[uart] >= sio_tail[uart] ) return (sio_head[uart]-sio_tail[uart]);
    1ea6:	20 91 aa 05 	lds	r18, 0x05AA
    1eaa:	30 91 ab 05 	lds	r19, 0x05AB
    1eae:	80 91 ac 05 	lds	r24, 0x05AC
    1eb2:	90 91 ad 05 	lds	r25, 0x05AD
    1eb6:	28 17       	cp	r18, r24
    1eb8:	39 07       	cpc	r19, r25
    1eba:	4c f0       	brlt	.+18     	; 0x1ece <uart_keyhit+0x32>
    1ebc:	20 91 aa 05 	lds	r18, 0x05AA
    1ec0:	30 91 ab 05 	lds	r19, 0x05AB
    1ec4:	80 91 ac 05 	lds	r24, 0x05AC
    1ec8:	90 91 ad 05 	lds	r25, 0x05AD
    1ecc:	0a c0       	rjmp	.+20     	; 0x1ee2 <uart_keyhit+0x46>
	else return (MAX_SIO_COUNT-(sio_tail[uart]-sio_head[uart]));
    1ece:	20 91 aa 05 	lds	r18, 0x05AA
    1ed2:	30 91 ab 05 	lds	r19, 0x05AB
    1ed6:	80 91 ac 05 	lds	r24, 0x05AC
    1eda:	90 91 ad 05 	lds	r25, 0x05AD
    1ede:	20 5e       	subi	r18, 0xE0	; 224
    1ee0:	3f 4f       	sbci	r19, 0xFF	; 255
    1ee2:	28 1b       	sub	r18, r24
    1ee4:	39 0b       	sbc	r19, r25
}
    1ee6:	c9 01       	movw	r24, r18
    1ee8:	08 95       	ret

00001eea <uart0_putchar>:

This function sends a character through UART0.

*/
void uart0_putchar(char c, FILE *f)
{
    1eea:	98 2f       	mov	r25, r24
	while(SIO_FLOW[0] && (bXONOFF[0] & 0x02));	// If Peer XOFF STATE
    1eec:	80 91 af 05 	lds	r24, 0x05AF
    1ef0:	28 2f       	mov	r18, r24
    1ef2:	30 e0       	ldi	r19, 0x00	; 0
    1ef4:	22 70       	andi	r18, 0x02	; 2
    1ef6:	30 70       	andi	r19, 0x00	; 0
    1ef8:	80 91 ae 05 	lds	r24, 0x05AE
    1efc:	88 23       	and	r24, r24
    1efe:	19 f0       	breq	.+6      	; 0x1f06 <uart0_putchar+0x1c>
    1f00:	21 15       	cp	r18, r1
    1f02:	31 05       	cpc	r19, r1
    1f04:	e9 f7       	brne	.-6      	; 0x1f00 <uart0_putchar+0x16>
	while (!(UCSR0A & 0x20)) ;
    1f06:	5d 9b       	sbis	0x0b, 5	; 11
    1f08:	fe cf       	rjmp	.-4      	; 0x1f06 <uart0_putchar+0x1c>
	UDR0 = c;
    1f0a:	9c b9       	out	0x0c, r25	; 12
}
    1f0c:	08 95       	ret

00001f0e <uart0_getchar>:
This function gets a character from UART0.
*/
char uart0_getchar(FILE *f)
{
	char c;
	while (sio_head[0] == sio_tail[0]);
    1f0e:	20 91 aa 05 	lds	r18, 0x05AA
    1f12:	30 91 ab 05 	lds	r19, 0x05AB
    1f16:	80 91 ac 05 	lds	r24, 0x05AC
    1f1a:	90 91 ad 05 	lds	r25, 0x05AD
    1f1e:	28 17       	cp	r18, r24
    1f20:	39 07       	cpc	r19, r25
    1f22:	a9 f3       	breq	.-22     	; 0x1f0e <uart0_getchar>
	
	c = sio_rxd[0][sio_tail[0]++];
    1f24:	80 91 ac 05 	lds	r24, 0x05AC
    1f28:	90 91 ad 05 	lds	r25, 0x05AD
    1f2c:	fc 01       	movw	r30, r24
    1f2e:	e6 57       	subi	r30, 0x76	; 118
    1f30:	fa 4f       	sbci	r31, 0xFA	; 250
    1f32:	e0 81       	ld	r30, Z
    1f34:	01 96       	adiw	r24, 0x01	; 1
    1f36:	90 93 ad 05 	sts	0x05AD, r25
    1f3a:	80 93 ac 05 	sts	0x05AC, r24
	
	if(SIO_FLOW[0] && (bXONOFF[0] & 0x01))	// IF MY XOFF STATE
    1f3e:	80 91 ae 05 	lds	r24, 0x05AE
    1f42:	88 23       	and	r24, r24
    1f44:	59 f0       	breq	.+22     	; 0x1f5c <uart0_getchar+0x4e>
    1f46:	90 91 af 05 	lds	r25, 0x05AF
    1f4a:	90 ff       	sbrs	r25, 0
    1f4c:	07 c0       	rjmp	.+14     	; 0x1f5c <uart0_getchar+0x4e>
	{
		while (!(UCSR0A & 0x20)) ;
    1f4e:	5d 9b       	sbis	0x0b, 5	; 11
    1f50:	fe cf       	rjmp	.-4      	; 0x1f4e <uart0_getchar+0x40>
		UDR0 = XON_CHAR;		
    1f52:	81 e1       	ldi	r24, 0x11	; 17
    1f54:	8c b9       	out	0x0c, r24	; 12
		SET_MY_XON_STATE(0);
    1f56:	9e 7f       	andi	r25, 0xFE	; 254
    1f58:	90 93 af 05 	sts	0x05AF, r25
	}

	if (sio_tail[0] >= MAX_SIO_COUNT) sio_tail[0] = 0;
    1f5c:	80 91 ac 05 	lds	r24, 0x05AC
    1f60:	90 91 ad 05 	lds	r25, 0x05AD
    1f64:	80 97       	sbiw	r24, 0x20	; 32
    1f66:	24 f0       	brlt	.+8      	; 0x1f70 <uart0_getchar+0x62>
    1f68:	10 92 ad 05 	sts	0x05AD, r1
    1f6c:	10 92 ac 05 	sts	0x05AC, r1

	return c;
}
    1f70:	8e 2f       	mov	r24, r30
    1f72:	08 95       	ret

00001f74 <uart_puts>:

This function sends a string to UART.

*/
void uart_puts(u_char uart, char * str)
{
    1f74:	cf 93       	push	r28
    1f76:	df 93       	push	r29
	int i = 0;

	if ( uart >= UART_DEVICE_CNT )
    1f78:	88 23       	and	r24, r24
    1f7a:	61 f4       	brne	.+24     	; 0x1f94 <uart_puts+0x20>
		return;
    1f7c:	eb 01       	movw	r28, r22
    1f7e:	07 c0       	rjmp	.+14     	; 0x1f8e <uart_puts+0x1a>
	
	while (str[i]) (*uart_handler[uart].uart_put_handler)(str[i++],NULL);
    1f80:	e0 91 b2 05 	lds	r30, 0x05B2
    1f84:	f0 91 b3 05 	lds	r31, 0x05B3
    1f88:	60 e0       	ldi	r22, 0x00	; 0
    1f8a:	70 e0       	ldi	r23, 0x00	; 0
    1f8c:	09 95       	icall
    1f8e:	89 91       	ld	r24, Y+
    1f90:	88 23       	and	r24, r24
    1f92:	b1 f7       	brne	.-20     	; 0x1f80 <uart_puts+0xc>
}
    1f94:	df 91       	pop	r29
    1f96:	cf 91       	pop	r28
    1f98:	08 95       	ret

00001f9a <uart_gets>:

This function gets a string from UART.

*/
int uart_gets(u_char uart, char * str, char bpasswordtype, int max_len)
{
    1f9a:	7f 92       	push	r7
    1f9c:	8f 92       	push	r8
    1f9e:	9f 92       	push	r9
    1fa0:	af 92       	push	r10
    1fa2:	bf 92       	push	r11
    1fa4:	cf 92       	push	r12
    1fa6:	df 92       	push	r13
    1fa8:	ef 92       	push	r14
    1faa:	ff 92       	push	r15
    1fac:	0f 93       	push	r16
    1fae:	1f 93       	push	r17
    1fb0:	cf 93       	push	r28
    1fb2:	df 93       	push	r29
    1fb4:	5b 01       	movw	r10, r22
    1fb6:	74 2e       	mov	r7, r20
    1fb8:	49 01       	movw	r8, r18
	char c;
	char * tsrc = str;
	char IsFirst = 1;
	int len = 0;

	if ( uart >= UART_DEVICE_CNT )
    1fba:	88 23       	and	r24, r24
    1fbc:	19 f0       	breq	.+6      	; 0x1fc4 <uart_gets+0x2a>
    1fbe:	cc 24       	eor	r12, r12
    1fc0:	dd 24       	eor	r13, r13
    1fc2:	98 c0       	rjmp	.+304    	; 0x20f4 <uart_gets+0x15a>
    1fc4:	7b 01       	movw	r14, r22
    1fc6:	01 e0       	ldi	r16, 0x01	; 1
    1fc8:	cc 24       	eor	r12, r12
    1fca:	dd 24       	eor	r13, r13
    1fcc:	81 c0       	rjmp	.+258    	; 0x20d0 <uart_gets+0x136>
		return 0;
	
	while ((c = (*uart_handler[uart].uart_get_handler)(NULL)) != 0x0D)
	{      
		if (IsFirst && c=='!')
    1fce:	00 23       	and	r16, r16
    1fd0:	91 f0       	breq	.+36     	; 0x1ff6 <uart_gets+0x5c>
    1fd2:	11 32       	cpi	r17, 0x21	; 33
    1fd4:	81 f4       	brne	.+32     	; 0x1ff6 <uart_gets+0x5c>
    1fd6:	0a c0       	rjmp	.+20     	; 0x1fec <uart_gets+0x52>
		{
			while(*str != '\0') (*uart_handler[uart].uart_put_handler)(*str++,NULL);
    1fd8:	08 94       	sec
    1fda:	e1 1c       	adc	r14, r1
    1fdc:	f1 1c       	adc	r15, r1
    1fde:	e0 91 b2 05 	lds	r30, 0x05B2
    1fe2:	f0 91 b3 05 	lds	r31, 0x05B3
    1fe6:	60 e0       	ldi	r22, 0x00	; 0
    1fe8:	70 e0       	ldi	r23, 0x00	; 0
    1fea:	09 95       	icall
    1fec:	f7 01       	movw	r30, r14
    1fee:	80 81       	ld	r24, Z
    1ff0:	88 23       	and	r24, r24
    1ff2:	91 f7       	brne	.-28     	; 0x1fd8 <uart_gets+0x3e>
    1ff4:	69 c0       	rjmp	.+210    	; 0x20c8 <uart_gets+0x12e>
			IsFirst = 0;
			len++;
			continue;
		}
		if (c == 0x08 && tsrc != str)
    1ff6:	18 30       	cpi	r17, 0x08	; 8
    1ff8:	19 f5       	brne	.+70     	; 0x2040 <uart_gets+0xa6>
    1ffa:	ae 14       	cp	r10, r14
    1ffc:	bf 04       	cpc	r11, r15
    1ffe:	09 f4       	brne	.+2      	; 0x2002 <uart_gets+0x68>
    2000:	47 c0       	rjmp	.+142    	; 0x2090 <uart_gets+0xf6>
		{
	       	(*uart_handler[uart].uart_put_handler)(0x08,NULL);
    2002:	e0 91 b2 05 	lds	r30, 0x05B2
    2006:	f0 91 b3 05 	lds	r31, 0x05B3
    200a:	88 e0       	ldi	r24, 0x08	; 8
    200c:	60 e0       	ldi	r22, 0x00	; 0
    200e:	70 e0       	ldi	r23, 0x00	; 0
    2010:	09 95       	icall
			(*uart_handler[uart].uart_put_handler)(' ',NULL);
    2012:	e0 91 b2 05 	lds	r30, 0x05B2
    2016:	f0 91 b3 05 	lds	r31, 0x05B3
    201a:	80 e2       	ldi	r24, 0x20	; 32
    201c:	60 e0       	ldi	r22, 0x00	; 0
    201e:	70 e0       	ldi	r23, 0x00	; 0
    2020:	09 95       	icall
			(*uart_handler[uart].uart_put_handler)(0x08,NULL);
    2022:	e0 91 b2 05 	lds	r30, 0x05B2
    2026:	f0 91 b3 05 	lds	r31, 0x05B3
    202a:	88 e0       	ldi	r24, 0x08	; 8
    202c:	60 e0       	ldi	r22, 0x00	; 0
    202e:	70 e0       	ldi	r23, 0x00	; 0
    2030:	09 95       	icall
			str--;
    2032:	08 94       	sec
    2034:	e1 08       	sbc	r14, r1
    2036:	f1 08       	sbc	r15, r1
			len--;
    2038:	08 94       	sec
    203a:	c1 08       	sbc	r12, r1
    203c:	d1 08       	sbc	r13, r1
    203e:	48 c0       	rjmp	.+144    	; 0x20d0 <uart_gets+0x136>
			continue;
		}
		else if (c == 0x1B)
    2040:	1b 31       	cpi	r17, 0x1B	; 27
    2042:	31 f5       	brne	.+76     	; 0x2090 <uart_gets+0xf6>
    2044:	e7 01       	movw	r28, r14
    2046:	19 c0       	rjmp	.+50     	; 0x207a <uart_gets+0xe0>
		{
			while (tsrc != str)
			{
	       		(*uart_handler[uart].uart_put_handler)(0x08,NULL);
    2048:	e0 91 b2 05 	lds	r30, 0x05B2
    204c:	f0 91 b3 05 	lds	r31, 0x05B3
    2050:	88 e0       	ldi	r24, 0x08	; 8
    2052:	60 e0       	ldi	r22, 0x00	; 0
    2054:	70 e0       	ldi	r23, 0x00	; 0
    2056:	09 95       	icall
				(*uart_handler[uart].uart_put_handler)(' ',NULL);
    2058:	e0 91 b2 05 	lds	r30, 0x05B2
    205c:	f0 91 b3 05 	lds	r31, 0x05B3
    2060:	80 e2       	ldi	r24, 0x20	; 32
    2062:	60 e0       	ldi	r22, 0x00	; 0
    2064:	70 e0       	ldi	r23, 0x00	; 0
    2066:	09 95       	icall
				(*uart_handler[uart].uart_put_handler)(0x08,NULL);
    2068:	e0 91 b2 05 	lds	r30, 0x05B2
    206c:	f0 91 b3 05 	lds	r31, 0x05B3
    2070:	88 e0       	ldi	r24, 0x08	; 8
    2072:	60 e0       	ldi	r22, 0x00	; 0
    2074:	70 e0       	ldi	r23, 0x00	; 0
    2076:	09 95       	icall
				str--;
    2078:	21 97       	sbiw	r28, 0x01	; 1
			len--;
			continue;
		}
		else if (c == 0x1B)
		{
			while (tsrc != str)
    207a:	ac 16       	cp	r10, r28
    207c:	bd 06       	cpc	r11, r29
    207e:	21 f7       	brne	.-56     	; 0x2048 <uart_gets+0xae>
    2080:	c5 01       	movw	r24, r10
    2082:	8e 19       	sub	r24, r14
    2084:	9f 09       	sbc	r25, r15
    2086:	c8 0e       	add	r12, r24
    2088:	d9 1e       	adc	r13, r25
    208a:	75 01       	movw	r14, r10
    208c:	01 e0       	ldi	r16, 0x01	; 1
    208e:	20 c0       	rjmp	.+64     	; 0x20d0 <uart_gets+0x136>
				len--;
			}
			IsFirst = 1;
			continue;			
		}
		else if ((c < 32 || c > 126) && c != '\t')	continue; 
    2090:	81 2f       	mov	r24, r17
    2092:	80 52       	subi	r24, 0x20	; 32
    2094:	8f 35       	cpi	r24, 0x5F	; 95
    2096:	10 f0       	brcs	.+4      	; 0x209c <uart_gets+0x102>
    2098:	19 30       	cpi	r17, 0x09	; 9
    209a:	d1 f4       	brne	.+52     	; 0x20d0 <uart_gets+0x136>
		if(len < max_len)
    209c:	c8 14       	cp	r12, r8
    209e:	d9 04       	cpc	r13, r9
    20a0:	bc f4       	brge	.+46     	; 0x20d0 <uart_gets+0x136>
		{
			if(bpasswordtype) (*uart_handler[uart].uart_put_handler)('*',NULL);
    20a2:	77 20       	and	r7, r7
    20a4:	31 f0       	breq	.+12     	; 0x20b2 <uart_gets+0x118>
    20a6:	e0 91 b2 05 	lds	r30, 0x05B2
    20aa:	f0 91 b3 05 	lds	r31, 0x05B3
    20ae:	8a e2       	ldi	r24, 0x2A	; 42
    20b0:	05 c0       	rjmp	.+10     	; 0x20bc <uart_gets+0x122>
			else (*uart_handler[uart].uart_put_handler)(c,NULL);
    20b2:	e0 91 b2 05 	lds	r30, 0x05B2
    20b6:	f0 91 b3 05 	lds	r31, 0x05B3
    20ba:	81 2f       	mov	r24, r17
    20bc:	60 e0       	ldi	r22, 0x00	; 0
    20be:	70 e0       	ldi	r23, 0x00	; 0
    20c0:	09 95       	icall
			*str++ = c;
    20c2:	f7 01       	movw	r30, r14
    20c4:	11 93       	st	Z+, r17
    20c6:	7f 01       	movw	r14, r30
			len++;
    20c8:	08 94       	sec
    20ca:	c1 1c       	adc	r12, r1
    20cc:	d1 1c       	adc	r13, r1
    20ce:	00 e0       	ldi	r16, 0x00	; 0
	int len = 0;

	if ( uart >= UART_DEVICE_CNT )
		return 0;
	
	while ((c = (*uart_handler[uart].uart_get_handler)(NULL)) != 0x0D)
    20d0:	e0 91 b0 05 	lds	r30, 0x05B0
    20d4:	f0 91 b1 05 	lds	r31, 0x05B1
    20d8:	80 e0       	ldi	r24, 0x00	; 0
    20da:	90 e0       	ldi	r25, 0x00	; 0
    20dc:	09 95       	icall
    20de:	18 2f       	mov	r17, r24
    20e0:	8d 30       	cpi	r24, 0x0D	; 13
    20e2:	09 f0       	breq	.+2      	; 0x20e6 <uart_gets+0x14c>
    20e4:	74 cf       	rjmp	.-280    	; 0x1fce <uart_gets+0x34>
			*str++ = c;
			len++;
			IsFirst = 0;
		}
	}
	*str = '\0';
    20e6:	f7 01       	movw	r30, r14
    20e8:	10 82       	st	Z, r1
	uart_puts(uart,"\r\n");
    20ea:	80 e0       	ldi	r24, 0x00	; 0
    20ec:	68 e1       	ldi	r22, 0x18	; 24
    20ee:	73 e0       	ldi	r23, 0x03	; 3
    20f0:	0e 94 ba 0f 	call	0x1f74	; 0x1f74 <uart_puts>
	
	return len;
}
    20f4:	c6 01       	movw	r24, r12
    20f6:	df 91       	pop	r29
    20f8:	cf 91       	pop	r28
    20fa:	1f 91       	pop	r17
    20fc:	0f 91       	pop	r16
    20fe:	ff 90       	pop	r15
    2100:	ef 90       	pop	r14
    2102:	df 90       	pop	r13
    2104:	cf 90       	pop	r12
    2106:	bf 90       	pop	r11
    2108:	af 90       	pop	r10
    210a:	9f 90       	pop	r9
    210c:	8f 90       	pop	r8
    210e:	7f 90       	pop	r7
    2110:	08 95       	ret

00002112 <uart_flush_rx>:
This function flush rx buffer of serial 

*/
void uart_flush_rx(u_char uart)
{
	if ( uart >= UART_DEVICE_CNT )
    2112:	88 23       	and	r24, r24
    2114:	41 f4       	brne	.+16     	; 0x2126 <uart_flush_rx+0x14>
		return;

	sio_head[uart] = sio_tail[uart];
    2116:	80 91 ac 05 	lds	r24, 0x05AC
    211a:	90 91 ad 05 	lds	r25, 0x05AD
    211e:	90 93 ab 05 	sts	0x05AB, r25
    2122:	80 93 aa 05 	sts	0x05AA, r24
    2126:	08 95       	ret

00002128 <uart_init>:
	u_char baud_index	/**< UART BaudRate Index(0:2400,...,11:500000) */
	)
{

	/* enable RxD/TxD and RX INT */
	u_int uart_select_baud = UART_BAUD_SELECT(baud_index);
    2128:	66 23       	and	r22, r22
    212a:	19 f4       	brne	.+6      	; 0x2132 <uart_init+0xa>
    212c:	2f ec       	ldi	r18, 0xCF	; 207
    212e:	30 e0       	ldi	r19, 0x00	; 0
    2130:	33 c0       	rjmp	.+102    	; 0x2198 <uart_init+0x70>
    2132:	61 30       	cpi	r22, 0x01	; 1
    2134:	19 f4       	brne	.+6      	; 0x213c <uart_init+0x14>
    2136:	27 e6       	ldi	r18, 0x67	; 103
    2138:	30 e0       	ldi	r19, 0x00	; 0
    213a:	2e c0       	rjmp	.+92     	; 0x2198 <uart_init+0x70>
    213c:	62 30       	cpi	r22, 0x02	; 2
    213e:	19 f4       	brne	.+6      	; 0x2146 <uart_init+0x1e>
    2140:	23 e3       	ldi	r18, 0x33	; 51
    2142:	30 e0       	ldi	r19, 0x00	; 0
    2144:	29 c0       	rjmp	.+82     	; 0x2198 <uart_init+0x70>
    2146:	63 30       	cpi	r22, 0x03	; 3
    2148:	19 f4       	brne	.+6      	; 0x2150 <uart_init+0x28>
    214a:	22 e2       	ldi	r18, 0x22	; 34
    214c:	30 e0       	ldi	r19, 0x00	; 0
    214e:	24 c0       	rjmp	.+72     	; 0x2198 <uart_init+0x70>
    2150:	64 30       	cpi	r22, 0x04	; 4
    2152:	19 f4       	brne	.+6      	; 0x215a <uart_init+0x32>
    2154:	29 e1       	ldi	r18, 0x19	; 25
    2156:	30 e0       	ldi	r19, 0x00	; 0
    2158:	1f c0       	rjmp	.+62     	; 0x2198 <uart_init+0x70>
    215a:	65 30       	cpi	r22, 0x05	; 5
    215c:	19 f4       	brne	.+6      	; 0x2164 <uart_init+0x3c>
    215e:	20 e1       	ldi	r18, 0x10	; 16
    2160:	30 e0       	ldi	r19, 0x00	; 0
    2162:	1a c0       	rjmp	.+52     	; 0x2198 <uart_init+0x70>
    2164:	66 30       	cpi	r22, 0x06	; 6
    2166:	19 f4       	brne	.+6      	; 0x216e <uart_init+0x46>
    2168:	2c e0       	ldi	r18, 0x0C	; 12
    216a:	30 e0       	ldi	r19, 0x00	; 0
    216c:	15 c0       	rjmp	.+42     	; 0x2198 <uart_init+0x70>
    216e:	67 30       	cpi	r22, 0x07	; 7
    2170:	19 f4       	brne	.+6      	; 0x2178 <uart_init+0x50>
    2172:	28 e0       	ldi	r18, 0x08	; 8
    2174:	30 e0       	ldi	r19, 0x00	; 0
    2176:	10 c0       	rjmp	.+32     	; 0x2198 <uart_init+0x70>
    2178:	68 30       	cpi	r22, 0x08	; 8
    217a:	19 f4       	brne	.+6      	; 0x2182 <uart_init+0x5a>
    217c:	26 e0       	ldi	r18, 0x06	; 6
    217e:	30 e0       	ldi	r19, 0x00	; 0
    2180:	0b c0       	rjmp	.+22     	; 0x2198 <uart_init+0x70>
    2182:	69 30       	cpi	r22, 0x09	; 9
    2184:	19 f4       	brne	.+6      	; 0x218c <uart_init+0x64>
    2186:	23 e0       	ldi	r18, 0x03	; 3
    2188:	30 e0       	ldi	r19, 0x00	; 0
    218a:	06 c0       	rjmp	.+12     	; 0x2198 <uart_init+0x70>
    218c:	20 e0       	ldi	r18, 0x00	; 0
    218e:	30 e0       	ldi	r19, 0x00	; 0
    2190:	6a 30       	cpi	r22, 0x0A	; 10
    2192:	11 f4       	brne	.+4      	; 0x2198 <uart_init+0x70>
    2194:	21 e0       	ldi	r18, 0x01	; 1
    2196:	30 e0       	ldi	r19, 0x00	; 0
	if(uart == 0)		/* uart == 0( first serial ) */
    2198:	88 23       	and	r24, r24
    219a:	21 f5       	brne	.+72     	; 0x21e4 <uart_init+0xbc>
	{
		PORTE |= 3;
    219c:	83 b1       	in	r24, 0x03	; 3
    219e:	83 60       	ori	r24, 0x03	; 3
    21a0:	83 b9       	out	0x03, r24	; 3
		DDRE &= ~(1);
    21a2:	10 98       	cbi	0x02, 0	; 2
		DDRE |= (2);
    21a4:	11 9a       	sbi	0x02, 1	; 2
		
		UCSR0B = (1<<RXCIE)|(1<<RXEN)|(1<<TXEN);
    21a6:	88 e9       	ldi	r24, 0x98	; 152
    21a8:	8a b9       	out	0x0a, r24	; 10

		UBRR0H = (u_char) ((uart_select_baud >> 8) & 0xFF);
    21aa:	10 92 90 00 	sts	0x0090, r1
		UBRR0L = (u_char) (uart_select_baud & 0xFF);
    21ae:	29 b9       	out	0x09, r18	; 9

		uart_handler[0].uart_get_handler = uart0_getchar;
    21b0:	67 e8       	ldi	r22, 0x87	; 135
    21b2:	7f e0       	ldi	r23, 0x0F	; 15
    21b4:	70 93 b1 05 	sts	0x05B1, r23
    21b8:	60 93 b0 05 	sts	0x05B0, r22
		uart_handler[0].uart_put_handler = uart0_putchar;
    21bc:	85 e7       	ldi	r24, 0x75	; 117
    21be:	9f e0       	ldi	r25, 0x0F	; 15
    21c0:	90 93 b3 05 	sts	0x05B3, r25
    21c4:	80 93 b2 05 	sts	0x05B2, r24
		
/* New prototype for avr-libc 1.4 and above. */

		/* fdevopen((void *)uart0_putchar_avrlibv1_4, (void *)uart0_getchar_avrlibv1_4); */
		fdevopen((void *)uart0_putchar, (void *)uart0_getchar);
    21c8:	0e 94 70 1e 	call	0x3ce0	; 0x3ce0 <fdevopen>
#endif	
	else
	{
		return;
	}
	sio_head[uart] = 0;
    21cc:	10 92 ab 05 	sts	0x05AB, r1
    21d0:	10 92 aa 05 	sts	0x05AA, r1
	sio_tail[uart] = 0;
    21d4:	10 92 ad 05 	sts	0x05AD, r1
    21d8:	10 92 ac 05 	sts	0x05AC, r1
	
	SIO_FLOW[uart] = 0;
    21dc:	10 92 ae 05 	sts	0x05AE, r1
	bXONOFF[uart] = 0;
    21e0:	10 92 af 05 	sts	0x05AF, r1
    21e4:	08 95       	ret

000021e6 <D2C>:
*/
u_char D2C(
	char c	/**< is a Hex(0x00~0x0F) to convert to a character */
	)
{
	u_int t = (u_int) c;
    21e6:	28 2f       	mov	r18, r24
    21e8:	30 e0       	ldi	r19, 0x00	; 0
	if (t >= 0 && t <= 9)
    21ea:	2a 30       	cpi	r18, 0x0A	; 10
    21ec:	31 05       	cpc	r19, r1
    21ee:	10 f4       	brcc	.+4      	; 0x21f4 <D2C+0xe>
		return '0' + c;
    21f0:	80 5d       	subi	r24, 0xD0	; 208
    21f2:	08 95       	ret
	if (t >= 10 && t <= 15)
    21f4:	2a 50       	subi	r18, 0x0A	; 10
    21f6:	30 40       	sbci	r19, 0x00	; 0
    21f8:	26 30       	cpi	r18, 0x06	; 6
    21fa:	31 05       	cpc	r19, r1
    21fc:	08 f4       	brcc	.+2      	; 0x2200 <D2C+0x1a>
		return 'A' + c - 10;
    21fe:	89 5c       	subi	r24, 0xC9	; 201

	return c;
}
    2200:	08 95       	ret

00002202 <C2D>:
This function converts HEX(0-F) to a character
*/
char C2D(
	u_char c	/**< is a character('0'-'F') to convert to HEX */
	)
{
    2202:	98 2f       	mov	r25, r24
	if (c >= '0' && c <= '9')
    2204:	80 53       	subi	r24, 0x30	; 48
    2206:	8a 30       	cpi	r24, 0x0A	; 10
    2208:	68 f0       	brcs	.+26     	; 0x2224 <C2D+0x22>
		return c - '0';
	if (c >= 'a' && c <= 'f')
    220a:	81 53       	subi	r24, 0x31	; 49
    220c:	86 30       	cpi	r24, 0x06	; 6
    220e:	10 f4       	brcc	.+4      	; 0x2214 <C2D+0x12>
		return 10 + c -'a';
    2210:	86 5f       	subi	r24, 0xF6	; 246
    2212:	08 95       	ret
	if (c >= 'A' && c <= 'F')
    2214:	89 2f       	mov	r24, r25
    2216:	81 54       	subi	r24, 0x41	; 65
    2218:	86 30       	cpi	r24, 0x06	; 6
    221a:	10 f0       	brcs	.+4      	; 0x2220 <C2D+0x1e>
    221c:	89 2f       	mov	r24, r25
    221e:	08 95       	ret
		return 10 + c -'A';
    2220:	89 2f       	mov	r24, r25
    2222:	87 53       	subi	r24, 0x37	; 55

	return (char)c;
}
    2224:	08 95       	ret

00002226 <ATOI>:
*/
u_int ATOI(
	char* str,	/**< is a pointer to convert */
	u_int base	/**< is a base value (must be in the range 2 - 16) */
	)
{
    2226:	fc 01       	movw	r30, r24
    2228:	40 e0       	ldi	r20, 0x00	; 0
    222a:	50 e0       	ldi	r21, 0x00	; 0
    222c:	1c c0       	rjmp	.+56     	; 0x2266 <ATOI+0x40>
*/
char C2D(
	u_char c	/**< is a character('0'-'F') to convert to HEX */
	)
{
	if (c >= '0' && c <= '9')
    222e:	82 2f       	mov	r24, r18
    2230:	80 53       	subi	r24, 0x30	; 48
    2232:	8a 30       	cpi	r24, 0x0A	; 10
    2234:	10 f4       	brcc	.+4      	; 0x223a <ATOI+0x14>
    2236:	28 2f       	mov	r18, r24
    2238:	0b c0       	rjmp	.+22     	; 0x2250 <ATOI+0x2a>
		return c - '0';
	if (c >= 'a' && c <= 'f')
    223a:	82 2f       	mov	r24, r18
    223c:	81 56       	subi	r24, 0x61	; 97
    223e:	86 30       	cpi	r24, 0x06	; 6
    2240:	10 f4       	brcc	.+4      	; 0x2246 <ATOI+0x20>
		return 10 + c -'a';
    2242:	27 55       	subi	r18, 0x57	; 87
    2244:	05 c0       	rjmp	.+10     	; 0x2250 <ATOI+0x2a>
	if (c >= 'A' && c <= 'F')
    2246:	82 2f       	mov	r24, r18
    2248:	81 54       	subi	r24, 0x41	; 65
    224a:	86 30       	cpi	r24, 0x06	; 6
    224c:	08 f4       	brcc	.+2      	; 0x2250 <ATOI+0x2a>
		return 10 + c -'A';
    224e:	27 53       	subi	r18, 0x37	; 55
	u_int base	/**< is a base value (must be in the range 2 - 16) */
	)
{
        unsigned int num = 0;
        while (*str !=0)
                num = num * base + C2D(*str++);
    2250:	31 96       	adiw	r30, 0x01	; 1
    2252:	ca 01       	movw	r24, r20
    2254:	86 9f       	mul	r24, r22
    2256:	a0 01       	movw	r20, r0
    2258:	87 9f       	mul	r24, r23
    225a:	50 0d       	add	r21, r0
    225c:	96 9f       	mul	r25, r22
    225e:	50 0d       	add	r21, r0
    2260:	11 24       	eor	r1, r1
    2262:	42 0f       	add	r20, r18
    2264:	51 1d       	adc	r21, r1
	char* str,	/**< is a pointer to convert */
	u_int base	/**< is a base value (must be in the range 2 - 16) */
	)
{
        unsigned int num = 0;
        while (*str !=0)
    2266:	20 81       	ld	r18, Z
    2268:	22 23       	and	r18, r18
    226a:	09 f7       	brne	.-62     	; 0x222e <ATOI+0x8>
                num = num * base + C2D(*str++);
	return num;
}
    226c:	ca 01       	movw	r24, r20
    226e:	08 95       	ret

00002270 <ValidATOI>:
int ValidATOI(
	char* str, 	/**< is a pointer to string to be converted */
	int base, 	/**< is a base value (must be in the range 2 - 16) */
	int* ret		/**<  is a integer pointer to return */
	)
{
    2270:	cf 93       	push	r28
    2272:	df 93       	push	r29
    2274:	dc 01       	movw	r26, r24
    2276:	ea 01       	movw	r28, r20
	int c;
	char* tstr = str;
	if(str == 0 || *str == '\0') return 0;
    2278:	00 97       	sbiw	r24, 0x00	; 0
    227a:	31 f1       	breq	.+76     	; 0x22c8 <ValidATOI+0x58>
    227c:	8c 91       	ld	r24, X
    227e:	88 23       	and	r24, r24
    2280:	19 f1       	breq	.+70     	; 0x22c8 <ValidATOI+0x58>
    2282:	fd 01       	movw	r30, r26
    2284:	16 c0       	rjmp	.+44     	; 0x22b2 <ValidATOI+0x42>
*/
char C2D(
	u_char c	/**< is a character('0'-'F') to convert to HEX */
	)
{
	if (c >= '0' && c <= '9')
    2286:	82 2f       	mov	r24, r18
    2288:	80 53       	subi	r24, 0x30	; 48
    228a:	8a 30       	cpi	r24, 0x0A	; 10
    228c:	68 f0       	brcs	.+26     	; 0x22a8 <ValidATOI+0x38>
		return c - '0';
	if (c >= 'a' && c <= 'f')
    228e:	81 53       	subi	r24, 0x31	; 49
    2290:	86 30       	cpi	r24, 0x06	; 6
    2292:	10 f4       	brcc	.+4      	; 0x2298 <ValidATOI+0x28>
		return 10 + c -'a';
    2294:	86 5f       	subi	r24, 0xF6	; 246
    2296:	08 c0       	rjmp	.+16     	; 0x22a8 <ValidATOI+0x38>
	if (c >= 'A' && c <= 'F')
    2298:	82 2f       	mov	r24, r18
    229a:	81 54       	subi	r24, 0x41	; 65
    229c:	86 30       	cpi	r24, 0x06	; 6
    229e:	10 f0       	brcs	.+4      	; 0x22a4 <ValidATOI+0x34>
    22a0:	82 2f       	mov	r24, r18
    22a2:	02 c0       	rjmp	.+4      	; 0x22a8 <ValidATOI+0x38>
		return 10 + c -'A';
    22a4:	82 2f       	mov	r24, r18
    22a6:	87 53       	subi	r24, 0x37	; 55
	char* tstr = str;
	if(str == 0 || *str == '\0') return 0;
	while(*tstr != '\0')
	{
		c = C2D(*tstr);
		if( c >= 0 && c < base) tstr++;
    22a8:	90 e0       	ldi	r25, 0x00	; 0
    22aa:	86 17       	cp	r24, r22
    22ac:	97 07       	cpc	r25, r23
    22ae:	64 f4       	brge	.+24     	; 0x22c8 <ValidATOI+0x58>
    22b0:	31 96       	adiw	r30, 0x01	; 1
	)
{
	int c;
	char* tstr = str;
	if(str == 0 || *str == '\0') return 0;
	while(*tstr != '\0')
    22b2:	20 81       	ld	r18, Z
    22b4:	22 23       	and	r18, r18
    22b6:	39 f7       	brne	.-50     	; 0x2286 <ValidATOI+0x16>
		c = C2D(*tstr);
		if( c >= 0 && c < base) tstr++;
		else    return 0;
	}
	
	*ret = ATOI(str,base);
    22b8:	cd 01       	movw	r24, r26
    22ba:	0e 94 13 11 	call	0x2226	; 0x2226 <ATOI>
    22be:	99 83       	std	Y+1, r25	; 0x01
    22c0:	88 83       	st	Y, r24
    22c2:	21 e0       	ldi	r18, 0x01	; 1
    22c4:	30 e0       	ldi	r19, 0x00	; 0
    22c6:	02 c0       	rjmp	.+4      	; 0x22cc <ValidATOI+0x5c>
	return 1;
    22c8:	20 e0       	ldi	r18, 0x00	; 0
    22ca:	30 e0       	ldi	r19, 0x00	; 0
}
    22cc:	c9 01       	movw	r24, r18
    22ce:	df 91       	pop	r29
    22d0:	cf 91       	pop	r28
    22d2:	08 95       	ret

000022d4 <strspn>:
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
			if (*p == *a)
    22d4:	1f 93       	push	r17
    22d6:	16 2f       	mov	r17, r22
    22d8:	dc 01       	movw	r26, r24
    22da:	40 e0       	ldi	r20, 0x00	; 0
    22dc:	50 e0       	ldi	r21, 0x00	; 0
    22de:	0a c0       	rjmp	.+20     	; 0x22f4 <strspn+0x20>
    22e0:	68 17       	cp	r22, r24
    22e2:	29 f0       	breq	.+10     	; 0x22ee <strspn+0x1a>
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
    22e4:	31 96       	adiw	r30, 0x01	; 1
    22e6:	80 81       	ld	r24, Z
    22e8:	88 23       	and	r24, r24
    22ea:	d1 f7       	brne	.-12     	; 0x22e0 <strspn+0xc>
    22ec:	0b c0       	rjmp	.+22     	; 0x2304 <strspn+0x30>
			if (*p == *a)
				break;
		}
		if (*a == '\0')
			return count;
		++count;
    22ee:	4f 5f       	subi	r20, 0xFF	; 255
    22f0:	5f 4f       	sbci	r21, 0xFF	; 255
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
    22f2:	11 96       	adiw	r26, 0x01	; 1
    22f4:	6c 91       	ld	r22, X
    22f6:	66 23       	and	r22, r22
    22f8:	29 f0       	breq	.+10     	; 0x2304 <strspn+0x30>
    22fa:	81 2f       	mov	r24, r17
    22fc:	97 2f       	mov	r25, r23
    22fe:	9c 01       	movw	r18, r24
    2300:	f9 01       	movw	r30, r18
    2302:	f1 cf       	rjmp	.-30     	; 0x22e6 <strspn+0x12>
			return count;
		++count;
	}

	return count;
}
    2304:	ca 01       	movw	r24, r20
    2306:	1f 91       	pop	r17
    2308:	08 95       	ret

0000230a <strpbrk>:
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
    230a:	dc 01       	movw	r26, r24
    230c:	09 c0       	rjmp	.+18     	; 0x2320 <strpbrk+0x16>
    230e:	48 17       	cp	r20, r24
    2310:	11 f4       	brne	.+4      	; 0x2316 <strpbrk+0xc>
				return (char *) sc1;
    2312:	9d 01       	movw	r18, r26
    2314:	0c c0       	rjmp	.+24     	; 0x232e <strpbrk+0x24>
	)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
    2316:	31 96       	adiw	r30, 0x01	; 1
    2318:	80 81       	ld	r24, Z
    231a:	88 23       	and	r24, r24
    231c:	c1 f7       	brne	.-16     	; 0x230e <strpbrk+0x4>
	const char * ct	/**< The characters to search for */
	)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
    231e:	11 96       	adiw	r26, 0x01	; 1
    2320:	4c 91       	ld	r20, X
    2322:	44 23       	and	r20, r20
    2324:	11 f0       	breq	.+4      	; 0x232a <strpbrk+0x20>
    2326:	fb 01       	movw	r30, r22
    2328:	f7 cf       	rjmp	.-18     	; 0x2318 <strpbrk+0xe>
    232a:	20 e0       	ldi	r18, 0x00	; 0
    232c:	30 e0       	ldi	r19, 0x00	; 0
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
}
    232e:	c9 01       	movw	r24, r18
    2330:	08 95       	ret

00002332 <strtok>:
*/ 
char * strtok(
	char * s,			/**< The string to be searched */
	const char * ct	/**< The characters to search for */
	)
{
    2332:	1f 93       	push	r17
    2334:	cf 93       	push	r28
    2336:	df 93       	push	r29
    2338:	16 2f       	mov	r17, r22
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
    233a:	00 97       	sbiw	r24, 0x00	; 0
    233c:	11 f0       	breq	.+4      	; 0x2342 <strtok+0x10>
    233e:	dc 01       	movw	r26, r24
    2340:	07 c0       	rjmp	.+14     	; 0x2350 <strtok+0x1e>
    2342:	a0 91 d4 05 	lds	r26, 0x05D4
    2346:	b0 91 d5 05 	lds	r27, 0x05D5
	if (!sbegin) {
    234a:	10 97       	sbiw	r26, 0x00	; 0
    234c:	09 f4       	brne	.+2      	; 0x2350 <strtok+0x1e>
    234e:	41 c0       	rjmp	.+130    	; 0x23d2 <strtok+0xa0>
    2350:	ed 01       	movw	r28, r26
    2352:	40 e0       	ldi	r20, 0x00	; 0
    2354:	50 e0       	ldi	r21, 0x00	; 0
    2356:	0a c0       	rjmp	.+20     	; 0x236c <strtok+0x3a>
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
			if (*p == *a)
    2358:	68 17       	cp	r22, r24
    235a:	29 f0       	breq	.+10     	; 0x2366 <strtok+0x34>
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
    235c:	31 96       	adiw	r30, 0x01	; 1
    235e:	80 81       	ld	r24, Z
    2360:	88 23       	and	r24, r24
    2362:	d1 f7       	brne	.-12     	; 0x2358 <strtok+0x26>
    2364:	0b c0       	rjmp	.+22     	; 0x237c <strtok+0x4a>
			if (*p == *a)
				break;
		}
		if (*a == '\0')
			return count;
		++count;
    2366:	4f 5f       	subi	r20, 0xFF	; 255
    2368:	5f 4f       	sbci	r21, 0xFF	; 255
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
    236a:	21 96       	adiw	r28, 0x01	; 1
    236c:	68 81       	ld	r22, Y
    236e:	66 23       	and	r22, r22
    2370:	29 f0       	breq	.+10     	; 0x237c <strtok+0x4a>
    2372:	81 2f       	mov	r24, r17
    2374:	97 2f       	mov	r25, r23
    2376:	9c 01       	movw	r18, r24
    2378:	f9 01       	movw	r30, r18
    237a:	f1 cf       	rjmp	.-30     	; 0x235e <strtok+0x2c>

	sbegin  = s ? s : ___strtok;
	if (!sbegin) {
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
    237c:	a4 0f       	add	r26, r20
    237e:	b5 1f       	adc	r27, r21
	if (*sbegin == '\0') {
    2380:	8c 91       	ld	r24, X
    2382:	88 23       	and	r24, r24
    2384:	11 f0       	breq	.+4      	; 0x238a <strtok+0x58>
    2386:	ed 01       	movw	r28, r26
    2388:	12 c0       	rjmp	.+36     	; 0x23ae <strtok+0x7c>
		___strtok = NULL;
    238a:	10 92 d5 05 	sts	0x05D5, r1
    238e:	10 92 d4 05 	sts	0x05D4, r1
    2392:	a0 e0       	ldi	r26, 0x00	; 0
    2394:	b0 e0       	ldi	r27, 0x00	; 0
    2396:	1d c0       	rjmp	.+58     	; 0x23d2 <strtok+0xa0>
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
    2398:	48 17       	cp	r20, r24
    239a:	21 f4       	brne	.+8      	; 0x23a4 <strtok+0x72>
				return (char *) sc1;
    239c:	fe 01       	movw	r30, r28
	if (*sbegin == '\0') {
		___strtok = NULL;
		return( NULL );
	}
	send = strpbrk( sbegin, ct);
	if (send && *send != '\0')
    239e:	20 97       	sbiw	r28, 0x00	; 0
    23a0:	89 f4       	brne	.+34     	; 0x23c4 <strtok+0x92>
    23a2:	13 c0       	rjmp	.+38     	; 0x23ca <strtok+0x98>
	)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
    23a4:	31 96       	adiw	r30, 0x01	; 1
    23a6:	80 81       	ld	r24, Z
    23a8:	88 23       	and	r24, r24
    23aa:	b1 f7       	brne	.-20     	; 0x2398 <strtok+0x66>
	const char * ct	/**< The characters to search for */
	)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
    23ac:	21 96       	adiw	r28, 0x01	; 1
    23ae:	48 81       	ld	r20, Y
    23b0:	44 23       	and	r20, r20
    23b2:	19 f4       	brne	.+6      	; 0x23ba <strtok+0x88>
    23b4:	e0 e0       	ldi	r30, 0x00	; 0
    23b6:	f0 e0       	ldi	r31, 0x00	; 0
    23b8:	08 c0       	rjmp	.+16     	; 0x23ca <strtok+0x98>
    23ba:	81 2f       	mov	r24, r17
    23bc:	97 2f       	mov	r25, r23
    23be:	9c 01       	movw	r18, r24
    23c0:	f9 01       	movw	r30, r18
    23c2:	f1 cf       	rjmp	.-30     	; 0x23a6 <strtok+0x74>
	if (*sbegin == '\0') {
		___strtok = NULL;
		return( NULL );
	}
	send = strpbrk( sbegin, ct);
	if (send && *send != '\0')
    23c4:	88 81       	ld	r24, Y
    23c6:	81 11       	cpse	r24, r1
		*send++ = '\0';
    23c8:	11 92       	st	Z+, r1
	___strtok = send;
    23ca:	f0 93 d5 05 	sts	0x05D5, r31
    23ce:	e0 93 d4 05 	sts	0x05D4, r30
	return (sbegin);
}
    23d2:	cd 01       	movw	r24, r26
    23d4:	df 91       	pop	r29
    23d6:	cf 91       	pop	r28
    23d8:	1f 91       	pop	r17
    23da:	08 95       	ret

000023dc <replacetochar>:
void replacetochar(
	char * str, 		/**< pointer to be replaced */
	char oldchar, 	/**< old character */
	char newchar	/**< new character */
	)
{
    23dc:	fc 01       	movw	r30, r24
    23de:	04 c0       	rjmp	.+8      	; 0x23e8 <replacetochar+0xc>
	int x;
	for (x = 0; str[x]; x++) 
		if (str[x] == oldchar) str[x] = newchar;	
    23e0:	86 17       	cp	r24, r22
    23e2:	09 f4       	brne	.+2      	; 0x23e6 <replacetochar+0xa>
    23e4:	40 83       	st	Z, r20
    23e6:	31 96       	adiw	r30, 0x01	; 1
	char oldchar, 	/**< old character */
	char newchar	/**< new character */
	)
{
	int x;
	for (x = 0; str[x]; x++) 
    23e8:	80 81       	ld	r24, Z
    23ea:	88 23       	and	r24, r24
    23ec:	c9 f7       	brne	.-14     	; 0x23e0 <replacetochar+0x4>
		if (str[x] == oldchar) str[x] = newchar;	
}
    23ee:	08 95       	ret

000023f0 <swaps>:


u_short swaps(u_int i)
{
	u_short ret=0;
	ret = (i & 0xFF) << 8;
    23f0:	58 2f       	mov	r21, r24
    23f2:	40 e0       	ldi	r20, 0x00	; 0
    23f4:	29 2f       	mov	r18, r25
    23f6:	30 e0       	ldi	r19, 0x00	; 0
    23f8:	24 2b       	or	r18, r20
    23fa:	35 2b       	or	r19, r21
	ret |= ((i >> 8)& 0xFF);
	return ret;	
}
    23fc:	c9 01       	movw	r24, r18
    23fe:	08 95       	ret

00002400 <swapl>:
#endif
#include "../util/sockutil.h"


u_long swapl(u_long l)
{
    2400:	ef 92       	push	r14
    2402:	ff 92       	push	r15
    2404:	0f 93       	push	r16
    2406:	1f 93       	push	r17
	u_long ret=0;
	ret = (l & 0xFF) << 24;
    2408:	56 2f       	mov	r21, r22
    240a:	44 27       	eor	r20, r20
    240c:	33 27       	eor	r19, r19
    240e:	22 27       	eor	r18, r18
	ret |= ((l >> 8) & 0xFF) << 16;
    2410:	e9 2e       	mov	r14, r25
    2412:	ff 24       	eor	r15, r15
    2414:	00 27       	eor	r16, r16
    2416:	11 27       	eor	r17, r17
    2418:	e2 2a       	or	r14, r18
    241a:	f3 2a       	or	r15, r19
    241c:	04 2b       	or	r16, r20
    241e:	15 2b       	or	r17, r21
	ret |= ((l >> 16) & 0xFF) << 8;
    2420:	27 2f       	mov	r18, r23
    2422:	30 e0       	ldi	r19, 0x00	; 0
    2424:	40 e0       	ldi	r20, 0x00	; 0
    2426:	50 e0       	ldi	r21, 0x00	; 0
    2428:	a9 01       	movw	r20, r18
    242a:	33 27       	eor	r19, r19
    242c:	22 27       	eor	r18, r18
    242e:	e2 2a       	or	r14, r18
    2430:	f3 2a       	or	r15, r19
    2432:	04 2b       	or	r16, r20
    2434:	15 2b       	or	r17, r21
    2436:	67 2f       	mov	r22, r23
    2438:	78 2f       	mov	r23, r24
    243a:	89 2f       	mov	r24, r25
    243c:	99 27       	eor	r25, r25
    243e:	60 70       	andi	r22, 0x00	; 0
    2440:	80 70       	andi	r24, 0x00	; 0
    2442:	90 70       	andi	r25, 0x00	; 0
    2444:	e6 2a       	or	r14, r22
    2446:	f7 2a       	or	r15, r23
    2448:	08 2b       	or	r16, r24
    244a:	19 2b       	or	r17, r25
	ret |= ((l >> 24) & 0xFF);
	return ret;
}
    244c:	b7 01       	movw	r22, r14
    244e:	c8 01       	movw	r24, r16
    2450:	1f 91       	pop	r17
    2452:	0f 91       	pop	r16
    2454:	ff 90       	pop	r15
    2456:	ef 90       	pop	r14
    2458:	08 95       	ret

0000245a <htonl>:


unsigned long htonl(unsigned long hostlong)
{
    245a:	ef 92       	push	r14
    245c:	ff 92       	push	r15
    245e:	0f 93       	push	r16
    2460:	1f 93       	push	r17


u_long swapl(u_long l)
{
	u_long ret=0;
	ret = (l & 0xFF) << 24;
    2462:	56 2f       	mov	r21, r22
    2464:	44 27       	eor	r20, r20
    2466:	33 27       	eor	r19, r19
    2468:	22 27       	eor	r18, r18
	ret |= ((l >> 8) & 0xFF) << 16;
    246a:	e9 2e       	mov	r14, r25
    246c:	ff 24       	eor	r15, r15
    246e:	00 27       	eor	r16, r16
    2470:	11 27       	eor	r17, r17
    2472:	e2 2a       	or	r14, r18
    2474:	f3 2a       	or	r15, r19
    2476:	04 2b       	or	r16, r20
    2478:	15 2b       	or	r17, r21
	ret |= ((l >> 16) & 0xFF) << 8;
    247a:	27 2f       	mov	r18, r23
    247c:	30 e0       	ldi	r19, 0x00	; 0
    247e:	40 e0       	ldi	r20, 0x00	; 0
    2480:	50 e0       	ldi	r21, 0x00	; 0
    2482:	a9 01       	movw	r20, r18
    2484:	33 27       	eor	r19, r19
    2486:	22 27       	eor	r18, r18
    2488:	e2 2a       	or	r14, r18
    248a:	f3 2a       	or	r15, r19
    248c:	04 2b       	or	r16, r20
    248e:	15 2b       	or	r17, r21
    2490:	67 2f       	mov	r22, r23
    2492:	78 2f       	mov	r23, r24
    2494:	89 2f       	mov	r24, r25
    2496:	99 27       	eor	r25, r25
    2498:	60 70       	andi	r22, 0x00	; 0
    249a:	80 70       	andi	r24, 0x00	; 0
    249c:	90 70       	andi	r25, 0x00	; 0
    249e:	e6 2a       	or	r14, r22
    24a0:	f7 2a       	or	r15, r23
    24a2:	08 2b       	or	r16, r24
    24a4:	19 2b       	or	r17, r25
#if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )
	return swapl(hostlong);
#else
	return hostlong;
#endif	
}
    24a6:	b7 01       	movw	r22, r14
    24a8:	c8 01       	movw	r24, r16
    24aa:	1f 91       	pop	r17
    24ac:	0f 91       	pop	r16
    24ae:	ff 90       	pop	r15
    24b0:	ef 90       	pop	r14
    24b2:	08 95       	ret

000024b4 <htons>:


u_short swaps(u_int i)
{
	u_short ret=0;
	ret = (i & 0xFF) << 8;
    24b4:	58 2f       	mov	r21, r24
    24b6:	40 e0       	ldi	r20, 0x00	; 0
    24b8:	29 2f       	mov	r18, r25
    24ba:	30 e0       	ldi	r19, 0x00	; 0
    24bc:	24 2b       	or	r18, r20
    24be:	35 2b       	or	r19, r21
#if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )
	return swaps(hostshort);
#else
	return hostshort;
#endif		
}
    24c0:	c9 01       	movw	r24, r18
    24c2:	08 95       	ret

000024c4 <ntohs>:
    24c4:	78 2f       	mov	r23, r24
    24c6:	60 e0       	ldi	r22, 0x00	; 0
    24c8:	29 2f       	mov	r18, r25
    24ca:	30 e0       	ldi	r19, 0x00	; 0
    24cc:	26 2b       	or	r18, r22
    24ce:	37 2b       	or	r19, r23
#if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )	
	return htons(netshort);
#else
	return netshort;
#endif		
}
    24d0:	b9 01       	movw	r22, r18
    24d2:	80 e0       	ldi	r24, 0x00	; 0
    24d4:	90 e0       	ldi	r25, 0x00	; 0
    24d6:	08 95       	ret

000024d8 <ntohl>:
/**
@brief	converts a unsigned long from TCP/IP network byte order to host byte order (which is little-endian on Intel processors).
@return 	a 16-bit number in host byte order
*/ 
unsigned long ntohl(unsigned long netlong)
{
    24d8:	ef 92       	push	r14
    24da:	ff 92       	push	r15
    24dc:	0f 93       	push	r16
    24de:	1f 93       	push	r17


u_long swapl(u_long l)
{
	u_long ret=0;
	ret = (l & 0xFF) << 24;
    24e0:	56 2f       	mov	r21, r22
    24e2:	44 27       	eor	r20, r20
    24e4:	33 27       	eor	r19, r19
    24e6:	22 27       	eor	r18, r18
	ret |= ((l >> 8) & 0xFF) << 16;
    24e8:	e9 2e       	mov	r14, r25
    24ea:	ff 24       	eor	r15, r15
    24ec:	00 27       	eor	r16, r16
    24ee:	11 27       	eor	r17, r17
    24f0:	e2 2a       	or	r14, r18
    24f2:	f3 2a       	or	r15, r19
    24f4:	04 2b       	or	r16, r20
    24f6:	15 2b       	or	r17, r21
	ret |= ((l >> 16) & 0xFF) << 8;
    24f8:	27 2f       	mov	r18, r23
    24fa:	30 e0       	ldi	r19, 0x00	; 0
    24fc:	40 e0       	ldi	r20, 0x00	; 0
    24fe:	50 e0       	ldi	r21, 0x00	; 0
    2500:	a9 01       	movw	r20, r18
    2502:	33 27       	eor	r19, r19
    2504:	22 27       	eor	r18, r18
    2506:	e2 2a       	or	r14, r18
    2508:	f3 2a       	or	r15, r19
    250a:	04 2b       	or	r16, r20
    250c:	15 2b       	or	r17, r21
    250e:	67 2f       	mov	r22, r23
    2510:	78 2f       	mov	r23, r24
    2512:	89 2f       	mov	r24, r25
    2514:	99 27       	eor	r25, r25
    2516:	60 70       	andi	r22, 0x00	; 0
    2518:	80 70       	andi	r24, 0x00	; 0
    251a:	90 70       	andi	r25, 0x00	; 0
    251c:	e6 2a       	or	r14, r22
    251e:	f7 2a       	or	r15, r23
    2520:	08 2b       	or	r16, r24
    2522:	19 2b       	or	r17, r25
#if ( SYSTEM_ENDIAN == _ENDIAN_LITTLE_ )
	return htonl(netlong);
#else
	return netlong;
#endif		
}
    2524:	b7 01       	movw	r22, r14
    2526:	c8 01       	movw	r24, r16
    2528:	1f 91       	pop	r17
    252a:	0f 91       	pop	r16
    252c:	ff 90       	pop	r15
    252e:	ef 90       	pop	r14
    2530:	08 95       	ret

00002532 <checksum>:
*/ 
unsigned short checksum(
	unsigned char * src, 	/**< pointer to stream  */
	unsigned int len		/**< size of stream */
	)
{
    2532:	cf 92       	push	r12
    2534:	df 92       	push	r13
    2536:	ef 92       	push	r14
    2538:	ff 92       	push	r15
    253a:	0f 93       	push	r16
    253c:	1f 93       	push	r17
    253e:	cf 93       	push	r28
    2540:	df 93       	push	r29
    2542:	6c 01       	movw	r12, r24
	u_int sum, tsum, i, j;
	u_long lsum;

	j = len >> 1;
    2544:	eb 01       	movw	r28, r22
    2546:	d6 95       	lsr	r29
    2548:	c7 95       	ror	r28
    254a:	f6 01       	movw	r30, r12
    254c:	40 e0       	ldi	r20, 0x00	; 0
    254e:	50 e0       	ldi	r21, 0x00	; 0
    2550:	ee 24       	eor	r14, r14
    2552:	ff 24       	eor	r15, r15
    2554:	87 01       	movw	r16, r14
    2556:	10 c0       	rjmp	.+32     	; 0x2578 <checksum+0x46>
	lsum = 0;

	for (i = 0; i < j; i++) 
	{
		tsum = src[i * 2];
		tsum = tsum << 8;
    2558:	30 81       	ld	r19, Z
    255a:	20 e0       	ldi	r18, 0x00	; 0
		tsum += src[i * 2 + 1];
		lsum += tsum;
    255c:	81 81       	ldd	r24, Z+1	; 0x01
    255e:	d9 01       	movw	r26, r18
    2560:	a8 0f       	add	r26, r24
    2562:	b1 1d       	adc	r27, r1
    2564:	cd 01       	movw	r24, r26
    2566:	a0 e0       	ldi	r26, 0x00	; 0
    2568:	b0 e0       	ldi	r27, 0x00	; 0
    256a:	e8 0e       	add	r14, r24
    256c:	f9 1e       	adc	r15, r25
    256e:	0a 1f       	adc	r16, r26
    2570:	1b 1f       	adc	r17, r27

	j = len >> 1;

	lsum = 0;

	for (i = 0; i < j; i++) 
    2572:	4f 5f       	subi	r20, 0xFF	; 255
    2574:	5f 4f       	sbci	r21, 0xFF	; 255
    2576:	32 96       	adiw	r30, 0x02	; 2
    2578:	4c 17       	cp	r20, r28
    257a:	5d 07       	cpc	r21, r29
    257c:	68 f3       	brcs	.-38     	; 0x2558 <checksum+0x26>
		tsum = tsum << 8;
		tsum += src[i * 2 + 1];
		lsum += tsum;
	}

	if (len % 2) 
    257e:	60 ff       	sbrs	r22, 0
    2580:	0c c0       	rjmp	.+24     	; 0x259a <checksum+0x68>
	{
		tsum = src[i * 2];
		lsum += (tsum << 8);
    2582:	cc 0f       	add	r28, r28
    2584:	dd 1f       	adc	r29, r29
    2586:	cc 0d       	add	r28, r12
    2588:	dd 1d       	adc	r29, r13
    258a:	98 81       	ld	r25, Y
    258c:	80 e0       	ldi	r24, 0x00	; 0
    258e:	a0 e0       	ldi	r26, 0x00	; 0
    2590:	b0 e0       	ldi	r27, 0x00	; 0
    2592:	e8 0e       	add	r14, r24
    2594:	f9 1e       	adc	r15, r25
    2596:	0a 1f       	adc	r16, r26
    2598:	1b 1f       	adc	r17, r27
	}


	sum = lsum;
	sum = ~(sum + (lsum >> 16));
    259a:	98 01       	movw	r18, r16
    259c:	44 27       	eor	r20, r20
    259e:	55 27       	eor	r21, r21
    25a0:	2e 0d       	add	r18, r14
    25a2:	3f 1d       	adc	r19, r15
    25a4:	20 95       	com	r18
    25a6:	30 95       	com	r19
	return (u_short) sum;	
}
    25a8:	c9 01       	movw	r24, r18
    25aa:	df 91       	pop	r29
    25ac:	cf 91       	pop	r28
    25ae:	1f 91       	pop	r17
    25b0:	0f 91       	pop	r16
    25b2:	ff 90       	pop	r15
    25b4:	ef 90       	pop	r14
    25b6:	df 90       	pop	r13
    25b8:	cf 90       	pop	r12
    25ba:	08 95       	ret

000025bc <GetDestMacAddr>:
	int i = 0;
	for(i=0; i<6;i++)*mac++ = IINCHIP_READ(SHAR0+i);
}

void GetDestMacAddr(SOCKET s, u_char* mac)
{
    25bc:	ef 92       	push	r14
    25be:	ff 92       	push	r15
    25c0:	0f 93       	push	r16
    25c2:	1f 93       	push	r17
    25c4:	cf 93       	push	r28
    25c6:	df 93       	push	r29
    25c8:	7b 01       	movw	r14, r22
	int i = 0;
	for(i=0; i<6;i++)*mac++ = IINCHIP_READ(Sn_DHAR0(s)+i);
    25ca:	90 e0       	ldi	r25, 0x00	; 0
    25cc:	88 5f       	subi	r24, 0xF8	; 248
    25ce:	9d 4f       	sbci	r25, 0xFD	; 253
    25d0:	26 e0       	ldi	r18, 0x06	; 6
    25d2:	88 0f       	add	r24, r24
    25d4:	99 1f       	adc	r25, r25
    25d6:	2a 95       	dec	r18
    25d8:	e1 f7       	brne	.-8      	; 0x25d2 <GetDestMacAddr+0x16>
    25da:	ec 01       	movw	r28, r24
    25dc:	2c 96       	adiw	r28, 0x0c	; 12
    25de:	8c 01       	movw	r16, r24
    25e0:	0e 5e       	subi	r16, 0xEE	; 238
    25e2:	1f 4f       	sbci	r17, 0xFF	; 255
    25e4:	ce 01       	movw	r24, r28
    25e6:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    25ea:	f7 01       	movw	r30, r14
    25ec:	81 93       	st	Z+, r24
    25ee:	7f 01       	movw	r14, r30
    25f0:	21 96       	adiw	r28, 0x01	; 1
    25f2:	c0 17       	cp	r28, r16
    25f4:	d1 07       	cpc	r29, r17
    25f6:	b1 f7       	brne	.-20     	; 0x25e4 <GetDestMacAddr+0x28>
}
    25f8:	df 91       	pop	r29
    25fa:	cf 91       	pop	r28
    25fc:	1f 91       	pop	r17
    25fe:	0f 91       	pop	r16
    2600:	ff 90       	pop	r15
    2602:	ef 90       	pop	r14
    2604:	08 95       	ret

00002606 <GetMacAddress>:
@return 	Subnet Mask(32bit Address-Host Ordering)
*/ 
void GetMacAddress(
	unsigned char* mac	/**< Pointer to store Mac Address(48bit Address)(INPUT, OUTPUT) */
	)
{
    2606:	0f 93       	push	r16
    2608:	1f 93       	push	r17
    260a:	cf 93       	push	r28
    260c:	df 93       	push	r29
    260e:	8c 01       	movw	r16, r24
    2610:	c8 e0       	ldi	r28, 0x08	; 8
    2612:	d0 e8       	ldi	r29, 0x80	; 128
	int i = 0;
	for(i=0; i<6;i++)*mac++ = IINCHIP_READ(SHAR0+i);
    2614:	ce 01       	movw	r24, r28
    2616:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    261a:	f8 01       	movw	r30, r16
    261c:	81 93       	st	Z+, r24
    261e:	8f 01       	movw	r16, r30
    2620:	21 96       	adiw	r28, 0x01	; 1
    2622:	f0 e8       	ldi	r31, 0x80	; 128
    2624:	ce 30       	cpi	r28, 0x0E	; 14
    2626:	df 07       	cpc	r29, r31
    2628:	a9 f7       	brne	.-22     	; 0x2614 <GetMacAddress+0xe>
}
    262a:	df 91       	pop	r29
    262c:	cf 91       	pop	r28
    262e:	1f 91       	pop	r17
    2630:	0f 91       	pop	r16
    2632:	08 95       	ret

00002634 <GetSubMask>:
/**
@brief	Get Subnet mask of iinChip.
@return 	Subnet Mask(32bit Address-Host Ordering)
*/ 
u_long GetSubMask(void)
{
    2634:	ef 92       	push	r14
    2636:	ff 92       	push	r15
    2638:	0f 93       	push	r16
    263a:	1f 93       	push	r17
    263c:	cf 93       	push	r28
    263e:	df 93       	push	r29
    2640:	20 e0       	ldi	r18, 0x00	; 0
    2642:	30 e0       	ldi	r19, 0x00	; 0
    2644:	40 e0       	ldi	r20, 0x00	; 0
    2646:	50 e0       	ldi	r21, 0x00	; 0
    2648:	c4 e1       	ldi	r28, 0x14	; 20
    264a:	d0 e8       	ldi	r29, 0x80	; 128
	u_long ip=0;
	int i;
	for(i=0; i < 4; i++)
	{
		ip <<= 8;
    264c:	ee 24       	eor	r14, r14
    264e:	f2 2e       	mov	r15, r18
    2650:	03 2f       	mov	r16, r19
    2652:	14 2f       	mov	r17, r20
		ip += (unsigned char)IINCHIP_READ(SUBR0+i);
    2654:	ce 01       	movw	r24, r28
    2656:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    265a:	a8 01       	movw	r20, r16
    265c:	97 01       	movw	r18, r14
    265e:	28 0f       	add	r18, r24
    2660:	31 1d       	adc	r19, r1
    2662:	41 1d       	adc	r20, r1
    2664:	51 1d       	adc	r21, r1
    2666:	21 96       	adiw	r28, 0x01	; 1
*/ 
u_long GetSubMask(void)
{
	u_long ip=0;
	int i;
	for(i=0; i < 4; i++)
    2668:	80 e8       	ldi	r24, 0x80	; 128
    266a:	c8 31       	cpi	r28, 0x18	; 24
    266c:	d8 07       	cpc	r29, r24
    266e:	71 f7       	brne	.-36     	; 0x264c <GetSubMask+0x18>
	{
		ip <<= 8;
		ip += (unsigned char)IINCHIP_READ(SUBR0+i);
	}
	return ip;	
}
    2670:	b9 01       	movw	r22, r18
    2672:	ca 01       	movw	r24, r20
    2674:	df 91       	pop	r29
    2676:	cf 91       	pop	r28
    2678:	1f 91       	pop	r17
    267a:	0f 91       	pop	r16
    267c:	ff 90       	pop	r15
    267e:	ef 90       	pop	r14
    2680:	08 95       	ret

00002682 <GetGWAddress>:
/**
@brief	Get Gateway IP Address of iinChip.
@return 	Gateway IP Address(32bit Address-Host Ordering)
*/ 
u_long GetGWAddress(void)
{
    2682:	ef 92       	push	r14
    2684:	ff 92       	push	r15
    2686:	0f 93       	push	r16
    2688:	1f 93       	push	r17
    268a:	cf 93       	push	r28
    268c:	df 93       	push	r29
    268e:	20 e0       	ldi	r18, 0x00	; 0
    2690:	30 e0       	ldi	r19, 0x00	; 0
    2692:	40 e0       	ldi	r20, 0x00	; 0
    2694:	50 e0       	ldi	r21, 0x00	; 0
    2696:	c0 e1       	ldi	r28, 0x10	; 16
    2698:	d0 e8       	ldi	r29, 0x80	; 128
	u_long ip=0;
	int i;
	for(i=0; i < 4; i++)
	{
		ip <<= 8;
    269a:	ee 24       	eor	r14, r14
    269c:	f2 2e       	mov	r15, r18
    269e:	03 2f       	mov	r16, r19
    26a0:	14 2f       	mov	r17, r20
		ip += (char)IINCHIP_READ(GAR0+i);
    26a2:	ce 01       	movw	r24, r28
    26a4:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    26a8:	a8 01       	movw	r20, r16
    26aa:	97 01       	movw	r18, r14
    26ac:	28 0f       	add	r18, r24
    26ae:	31 1d       	adc	r19, r1
    26b0:	41 1d       	adc	r20, r1
    26b2:	51 1d       	adc	r21, r1
    26b4:	21 96       	adiw	r28, 0x01	; 1
*/ 
u_long GetGWAddress(void)
{
	u_long ip=0;
	int i;
	for(i=0; i < 4; i++)
    26b6:	80 e8       	ldi	r24, 0x80	; 128
    26b8:	c4 31       	cpi	r28, 0x14	; 20
    26ba:	d8 07       	cpc	r29, r24
    26bc:	71 f7       	brne	.-36     	; 0x269a <GetGWAddress+0x18>
	{
		ip <<= 8;
		ip += (char)IINCHIP_READ(GAR0+i);
	}
	return ip;	
}
    26be:	b9 01       	movw	r22, r18
    26c0:	ca 01       	movw	r24, r20
    26c2:	df 91       	pop	r29
    26c4:	cf 91       	pop	r28
    26c6:	1f 91       	pop	r17
    26c8:	0f 91       	pop	r16
    26ca:	ff 90       	pop	r15
    26cc:	ef 90       	pop	r14
    26ce:	08 95       	ret

000026d0 <GetIPAddress>:
/**
@brief	Get Source IP Address of iinChip.
@return 	Source IP Address(32bit Address-Host Ordering)
*/ 
u_long GetIPAddress(void)
{
    26d0:	ef 92       	push	r14
    26d2:	ff 92       	push	r15
    26d4:	0f 93       	push	r16
    26d6:	1f 93       	push	r17
    26d8:	cf 93       	push	r28
    26da:	df 93       	push	r29
    26dc:	20 e0       	ldi	r18, 0x00	; 0
    26de:	30 e0       	ldi	r19, 0x00	; 0
    26e0:	40 e0       	ldi	r20, 0x00	; 0
    26e2:	50 e0       	ldi	r21, 0x00	; 0
    26e4:	c8 e1       	ldi	r28, 0x18	; 24
    26e6:	d0 e8       	ldi	r29, 0x80	; 128
	u_long ip=0;
	int i;
	for(i=0; i < 4; i++)
	{
		ip <<= 8;
    26e8:	ee 24       	eor	r14, r14
    26ea:	f2 2e       	mov	r15, r18
    26ec:	03 2f       	mov	r16, r19
    26ee:	14 2f       	mov	r17, r20
		ip += (char)IINCHIP_READ(SIPR0+i);
    26f0:	ce 01       	movw	r24, r28
    26f2:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    26f6:	a8 01       	movw	r20, r16
    26f8:	97 01       	movw	r18, r14
    26fa:	28 0f       	add	r18, r24
    26fc:	31 1d       	adc	r19, r1
    26fe:	41 1d       	adc	r20, r1
    2700:	51 1d       	adc	r21, r1
    2702:	21 96       	adiw	r28, 0x01	; 1
*/ 
u_long GetIPAddress(void)
{
	u_long ip=0;
	int i;
	for(i=0; i < 4; i++)
    2704:	80 e8       	ldi	r24, 0x80	; 128
    2706:	cc 31       	cpi	r28, 0x1C	; 28
    2708:	d8 07       	cpc	r29, r24
    270a:	71 f7       	brne	.-36     	; 0x26e8 <GetIPAddress+0x18>
	{
		ip <<= 8;
		ip += (char)IINCHIP_READ(SIPR0+i);
	}
	return ip;
}
    270c:	b9 01       	movw	r22, r18
    270e:	ca 01       	movw	r24, r20
    2710:	df 91       	pop	r29
    2712:	cf 91       	pop	r28
    2714:	1f 91       	pop	r17
    2716:	0f 91       	pop	r16
    2718:	ff 90       	pop	r15
    271a:	ef 90       	pop	r14
    271c:	08 95       	ret

0000271e <CheckDestInLocal>:
#endif		
}

// destip : BigEndian
u_char CheckDestInLocal(u_long destip)
{
    271e:	af 92       	push	r10
    2720:	bf 92       	push	r11
    2722:	cf 92       	push	r12
    2724:	df 92       	push	r13
    2726:	ef 92       	push	r14
    2728:	ff 92       	push	r15
    272a:	0f 93       	push	r16
    272c:	1f 93       	push	r17
    272e:	df 93       	push	r29
    2730:	cf 93       	push	r28
    2732:	00 d0       	rcall	.+0      	; 0x2734 <CheckDestInLocal+0x16>
    2734:	00 d0       	rcall	.+0      	; 0x2736 <CheckDestInLocal+0x18>
    2736:	cd b7       	in	r28, 0x3d	; 61
    2738:	de b7       	in	r29, 0x3e	; 62
    273a:	69 83       	std	Y+1, r22	; 0x01
    273c:	7a 83       	std	Y+2, r23	; 0x02
    273e:	8b 83       	std	Y+3, r24	; 0x03
    2740:	9c 83       	std	Y+4, r25	; 0x04
    2742:	6e 01       	movw	r12, r28
    2744:	08 94       	sec
    2746:	c1 1c       	adc	r12, r1
    2748:	d1 1c       	adc	r13, r1
    274a:	a4 e1       	ldi	r26, 0x14	; 20
    274c:	ea 2e       	mov	r14, r26
    274e:	a0 e8       	ldi	r26, 0x80	; 128
    2750:	fa 2e       	mov	r15, r26
	int i = 0;
	u_char * pdestip = (u_char*)&destip;
	for(i =0; i < 4; i++)
    2752:	f5 e0       	ldi	r31, 0x05	; 5
    2754:	af 2e       	mov	r10, r31
    2756:	b1 2c       	mov	r11, r1
    2758:	ac 0e       	add	r10, r28
    275a:	bd 1e       	adc	r11, r29
	{
		if((pdestip[i] & IINCHIP_READ(SUBR0+i)) != (IINCHIP_READ(SIPR0+i) & IINCHIP_READ(SUBR0+i)))
    275c:	c7 01       	movw	r24, r14
    275e:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    2762:	08 2f       	mov	r16, r24
    2764:	c7 01       	movw	r24, r14
    2766:	04 96       	adiw	r24, 0x04	; 4
    2768:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    276c:	18 2f       	mov	r17, r24
    276e:	c7 01       	movw	r24, r14
    2770:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    2774:	f6 01       	movw	r30, r12
    2776:	90 81       	ld	r25, Z
    2778:	90 23       	and	r25, r16
    277a:	18 23       	and	r17, r24
    277c:	91 17       	cp	r25, r17
    277e:	11 f0       	breq	.+4      	; 0x2784 <CheckDestInLocal+0x66>
    2780:	81 e0       	ldi	r24, 0x01	; 1
    2782:	0a c0       	rjmp	.+20     	; 0x2798 <CheckDestInLocal+0x7a>
    2784:	08 94       	sec
    2786:	c1 1c       	adc	r12, r1
    2788:	d1 1c       	adc	r13, r1
    278a:	08 94       	sec
    278c:	e1 1c       	adc	r14, r1
    278e:	f1 1c       	adc	r15, r1
// destip : BigEndian
u_char CheckDestInLocal(u_long destip)
{
	int i = 0;
	u_char * pdestip = (u_char*)&destip;
	for(i =0; i < 4; i++)
    2790:	ca 14       	cp	r12, r10
    2792:	db 04       	cpc	r13, r11
    2794:	19 f7       	brne	.-58     	; 0x275c <CheckDestInLocal+0x3e>
    2796:	80 e0       	ldi	r24, 0x00	; 0
	{
		if((pdestip[i] & IINCHIP_READ(SUBR0+i)) != (IINCHIP_READ(SIPR0+i) & IINCHIP_READ(SUBR0+i)))
			return 1;	// Remote
	}
	return 0;
}
    2798:	0f 90       	pop	r0
    279a:	0f 90       	pop	r0
    279c:	0f 90       	pop	r0
    279e:	0f 90       	pop	r0
    27a0:	cf 91       	pop	r28
    27a2:	df 91       	pop	r29
    27a4:	1f 91       	pop	r17
    27a6:	0f 91       	pop	r16
    27a8:	ff 90       	pop	r15
    27aa:	ef 90       	pop	r14
    27ac:	df 90       	pop	r13
    27ae:	cf 90       	pop	r12
    27b0:	bf 90       	pop	r11
    27b2:	af 90       	pop	r10
    27b4:	08 95       	ret

000027b6 <GetDestPort>:
@return 	16bit destination port number
*/ 
unsigned int GetDestPort(
	SOCKET s	/**< Channel number which try to get destination port */
	)
{
    27b6:	ef 92       	push	r14
    27b8:	ff 92       	push	r15
    27ba:	0f 93       	push	r16
    27bc:	1f 93       	push	r17
	u_int port;
	port = ((u_int) IINCHIP_READ(Sn_DPORT0(s))) & 0x00FF;
    27be:	e8 2e       	mov	r14, r24
    27c0:	ff 24       	eor	r15, r15
    27c2:	88 e0       	ldi	r24, 0x08	; 8
    27c4:	92 e0       	ldi	r25, 0x02	; 2
    27c6:	e8 0e       	add	r14, r24
    27c8:	f9 1e       	adc	r15, r25
    27ca:	b6 e0       	ldi	r27, 0x06	; 6
    27cc:	ee 0c       	add	r14, r14
    27ce:	ff 1c       	adc	r15, r15
    27d0:	ba 95       	dec	r27
    27d2:	e1 f7       	brne	.-8      	; 0x27cc <GetDestPort+0x16>
    27d4:	c7 01       	movw	r24, r14
    27d6:	42 96       	adiw	r24, 0x12	; 18
    27d8:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
	port <<= 8;
    27dc:	18 2f       	mov	r17, r24
    27de:	00 e0       	ldi	r16, 0x00	; 0
	port += ((u_int) IINCHIP_READ(Sn_DPORT0(s)+1)) & 0x00FF;
    27e0:	c7 01       	movw	r24, r14
    27e2:	43 96       	adiw	r24, 0x13	; 19
    27e4:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    27e8:	08 0f       	add	r16, r24
    27ea:	11 1d       	adc	r17, r1
	return port;
}
    27ec:	c8 01       	movw	r24, r16
    27ee:	1f 91       	pop	r17
    27f0:	0f 91       	pop	r16
    27f2:	ff 90       	pop	r15
    27f4:	ef 90       	pop	r14
    27f6:	08 95       	ret

000027f8 <GetDestAddr>:
@return 	32bit destination address (Host Ordering)
*/ 
unsigned long GetDestAddr(
	SOCKET s	/**< Channel number which try to get destination IP Address */
	)
{
    27f8:	cf 92       	push	r12
    27fa:	df 92       	push	r13
    27fc:	ef 92       	push	r14
    27fe:	ff 92       	push	r15
    2800:	0f 93       	push	r16
    2802:	1f 93       	push	r17
    2804:	cf 93       	push	r28
    2806:	df 93       	push	r29
	u_long addr=0;
	int i = 0;
	for(i=0; i < 4; i++)
	{
		addr <<=8;
		addr += IINCHIP_READ(Sn_DIPR0(s)+i);
    2808:	90 e0       	ldi	r25, 0x00	; 0
    280a:	88 5f       	subi	r24, 0xF8	; 248
    280c:	9d 4f       	sbci	r25, 0xFD	; 253
    280e:	26 e0       	ldi	r18, 0x06	; 6
    2810:	88 0f       	add	r24, r24
    2812:	99 1f       	adc	r25, r25
    2814:	2a 95       	dec	r18
    2816:	e1 f7       	brne	.-8      	; 0x2810 <GetDestAddr+0x18>
    2818:	ec 01       	movw	r28, r24
    281a:	64 96       	adiw	r28, 0x14	; 20
    281c:	20 e0       	ldi	r18, 0x00	; 0
    281e:	30 e0       	ldi	r19, 0x00	; 0
    2820:	40 e0       	ldi	r20, 0x00	; 0
    2822:	50 e0       	ldi	r21, 0x00	; 0
	SOCKET s	/**< Channel number which try to get destination IP Address */
	)
{
	u_long addr=0;
	int i = 0;
	for(i=0; i < 4; i++)
    2824:	08 e1       	ldi	r16, 0x18	; 24
    2826:	c0 2e       	mov	r12, r16
    2828:	d1 2c       	mov	r13, r1
    282a:	c8 0e       	add	r12, r24
    282c:	d9 1e       	adc	r13, r25
	{
		addr <<=8;
    282e:	ee 24       	eor	r14, r14
    2830:	f2 2e       	mov	r15, r18
    2832:	03 2f       	mov	r16, r19
    2834:	14 2f       	mov	r17, r20
		addr += IINCHIP_READ(Sn_DIPR0(s)+i);
    2836:	ce 01       	movw	r24, r28
    2838:	0e 94 d3 05 	call	0xba6	; 0xba6 <IINCHIP_READ>
    283c:	a8 01       	movw	r20, r16
    283e:	97 01       	movw	r18, r14
    2840:	28 0f       	add	r18, r24
    2842:	31 1d       	adc	r19, r1
    2844:	41 1d       	adc	r20, r1
    2846:	51 1d       	adc	r21, r1
    2848:	21 96       	adiw	r28, 0x01	; 1
	SOCKET s	/**< Channel number which try to get destination IP Address */
	)
{
	u_long addr=0;
	int i = 0;
	for(i=0; i < 4; i++)
    284a:	cc 15       	cp	r28, r12
    284c:	dd 05       	cpc	r29, r13
    284e:	79 f7       	brne	.-34     	; 0x282e <GetDestAddr+0x36>
	{
		addr <<=8;
		addr += IINCHIP_READ(Sn_DIPR0(s)+i);
	}
	return addr;
}
    2850:	b9 01       	movw	r22, r18
    2852:	ca 01       	movw	r24, r20
    2854:	df 91       	pop	r29
    2856:	cf 91       	pop	r28
    2858:	1f 91       	pop	r17
    285a:	0f 91       	pop	r16
    285c:	ff 90       	pop	r15
    285e:	ef 90       	pop	r14
    2860:	df 90       	pop	r13
    2862:	cf 90       	pop	r12
    2864:	08 95       	ret

00002866 <getSocket>:
*/ 
SOCKET getSocket(
	unsigned char status, 	/**< socket's status to be found */
	SOCKET start			/**< base of socket to be found */
	)
{
    2866:	0f 93       	push	r16
    2868:	1f 93       	push	r17
    286a:	08 2f       	mov	r16, r24
	SOCKET i;
	if(start > 3) start = 0;
    286c:	64 30       	cpi	r22, 0x04	; 4
    286e:	10 f0       	brcs	.+4      	; 0x2874 <getSocket+0xe>
    2870:	10 e0       	ldi	r17, 0x00	; 0
    2872:	01 c0       	rjmp	.+2      	; 0x2876 <getSocket+0x10>
    2874:	16 2f       	mov	r17, r22

	for(i = start; i < MAX_SOCK_NUM ; i++) if( getSn_SR(i)==status ) return i;
    2876:	81 2f       	mov	r24, r17
    2878:	0e 94 8f 07 	call	0xf1e	; 0xf1e <getSn_SSR>
    287c:	80 17       	cp	r24, r16
    287e:	21 f0       	breq	.+8      	; 0x2888 <getSocket+0x22>
    2880:	1f 5f       	subi	r17, 0xFF	; 255
    2882:	18 30       	cpi	r17, 0x08	; 8
    2884:	c0 f3       	brcs	.-16     	; 0x2876 <getSocket+0x10>
    2886:	18 e0       	ldi	r17, 0x08	; 8
	return MAX_SOCK_NUM;	
}
    2888:	81 2f       	mov	r24, r17
    288a:	1f 91       	pop	r17
    288c:	0f 91       	pop	r16
    288e:	08 95       	ret

00002890 <VerifyIPAddress>:
@return 	success - 1, fail - 0
*/ 
char VerifyIPAddress(
	char* src	/**< pointer to IP address string */
	)
{
    2890:	ef 92       	push	r14
    2892:	ff 92       	push	r15
    2894:	0f 93       	push	r16
    2896:	1f 93       	push	r17
    2898:	df 93       	push	r29
    289a:	cf 93       	push	r28
    289c:	cd b7       	in	r28, 0x3d	; 61
    289e:	de b7       	in	r29, 0x3e	; 62
    28a0:	e4 97       	sbiw	r28, 0x34	; 52
    28a2:	0f b6       	in	r0, 0x3f	; 63
    28a4:	f8 94       	cli
    28a6:	de bf       	out	0x3e, r29	; 62
    28a8:	0f be       	out	0x3f, r0	; 63
    28aa:	cd bf       	out	0x3d, r28	; 61
    28ac:	bc 01       	movw	r22, r24
	int i;
	int tnum;
	char tsrc[50];
	char* tok = tsrc;
	
	strcpy(tsrc,src);
    28ae:	8e 01       	movw	r16, r28
    28b0:	0d 5f       	subi	r16, 0xFD	; 253
    28b2:	1f 4f       	sbci	r17, 0xFF	; 255
    28b4:	c8 01       	movw	r24, r16
    28b6:	0e 94 69 1e 	call	0x3cd2	; 0x3cd2 <strcpy>
    28ba:	ee 24       	eor	r14, r14
    28bc:	ff 24       	eor	r15, r15
    28be:	c8 01       	movw	r24, r16
		if ( !tok ) return 0;
		if(tok[0] == '0' && tok[1] == 'x')
		{
			if(!ValidATOI(tok+2,0x10,&tnum)) return 0;
		}
		else if(!ValidATOI(tok,10,&tnum)) return 0;
    28c0:	8e 01       	movw	r16, r28
    28c2:	0f 5f       	subi	r16, 0xFF	; 255
    28c4:	1f 4f       	sbci	r17, 0xFF	; 255
	
	strcpy(tsrc,src);
	
	for(i = 0; i < 4; i++)
	{
		tok = strtok(tok,".");
    28c6:	6b e1       	ldi	r22, 0x1B	; 27
    28c8:	73 e0       	ldi	r23, 0x03	; 3
    28ca:	0e 94 99 11 	call	0x2332	; 0x2332 <strtok>
    28ce:	fc 01       	movw	r30, r24
		if ( !tok ) return 0;
    28d0:	00 97       	sbiw	r24, 0x00	; 0
    28d2:	21 f1       	breq	.+72     	; 0x291c <VerifyIPAddress+0x8c>
		if(tok[0] == '0' && tok[1] == 'x')
    28d4:	80 81       	ld	r24, Z
    28d6:	80 33       	cpi	r24, 0x30	; 48
    28d8:	41 f4       	brne	.+16     	; 0x28ea <VerifyIPAddress+0x5a>
    28da:	81 81       	ldd	r24, Z+1	; 0x01
    28dc:	88 37       	cpi	r24, 0x78	; 120
    28de:	29 f4       	brne	.+10     	; 0x28ea <VerifyIPAddress+0x5a>
		{
			if(!ValidATOI(tok+2,0x10,&tnum)) return 0;
    28e0:	cf 01       	movw	r24, r30
    28e2:	02 96       	adiw	r24, 0x02	; 2
    28e4:	60 e1       	ldi	r22, 0x10	; 16
    28e6:	70 e0       	ldi	r23, 0x00	; 0
    28e8:	03 c0       	rjmp	.+6      	; 0x28f0 <VerifyIPAddress+0x60>
		}
		else if(!ValidATOI(tok,10,&tnum)) return 0;
    28ea:	cf 01       	movw	r24, r30
    28ec:	6a e0       	ldi	r22, 0x0A	; 10
    28ee:	70 e0       	ldi	r23, 0x00	; 0
    28f0:	a8 01       	movw	r20, r16
    28f2:	0e 94 38 11 	call	0x2270	; 0x2270 <ValidATOI>
    28f6:	89 2b       	or	r24, r25
    28f8:	89 f0       	breq	.+34     	; 0x291c <VerifyIPAddress+0x8c>
		
		if(tnum < 0 || tnum > 255) return 0;
    28fa:	89 81       	ldd	r24, Y+1	; 0x01
    28fc:	9a 81       	ldd	r25, Y+2	; 0x02
    28fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2900:	91 05       	cpc	r25, r1
    2902:	09 f0       	breq	.+2      	; 0x2906 <VerifyIPAddress+0x76>
    2904:	58 f4       	brcc	.+22     	; 0x291c <VerifyIPAddress+0x8c>
	char tsrc[50];
	char* tok = tsrc;
	
	strcpy(tsrc,src);
	
	for(i = 0; i < 4; i++)
    2906:	08 94       	sec
    2908:	e1 1c       	adc	r14, r1
    290a:	f1 1c       	adc	r15, r1
    290c:	80 e0       	ldi	r24, 0x00	; 0
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	24 e0       	ldi	r18, 0x04	; 4
    2912:	e2 16       	cp	r14, r18
    2914:	f1 04       	cpc	r15, r1
    2916:	b9 f6       	brne	.-82     	; 0x28c6 <VerifyIPAddress+0x36>
    2918:	81 e0       	ldi	r24, 0x01	; 1
    291a:	01 c0       	rjmp	.+2      	; 0x291e <VerifyIPAddress+0x8e>
    291c:	80 e0       	ldi	r24, 0x00	; 0
		
		if(tnum < 0 || tnum > 255) return 0;
		tok = NULL;
	}
	return 1;	
}
    291e:	e4 96       	adiw	r28, 0x34	; 52
    2920:	0f b6       	in	r0, 0x3f	; 63
    2922:	f8 94       	cli
    2924:	de bf       	out	0x3e, r29	; 62
    2926:	0f be       	out	0x3f, r0	; 63
    2928:	cd bf       	out	0x3d, r28	; 61
    292a:	cf 91       	pop	r28
    292c:	df 91       	pop	r29
    292e:	1f 91       	pop	r17
    2930:	0f 91       	pop	r16
    2932:	ff 90       	pop	r15
    2934:	ef 90       	pop	r14
    2936:	08 95       	ret

00002938 <inet_addr_>:
	}
	return inetaddr;
}*/	

void inet_addr_(unsigned char* addr,unsigned char *ip)
{
    2938:	ef 92       	push	r14
    293a:	ff 92       	push	r15
    293c:	0f 93       	push	r16
    293e:	1f 93       	push	r17
    2940:	df 93       	push	r29
    2942:	cf 93       	push	r28
    2944:	cd b7       	in	r28, 0x3d	; 61
    2946:	de b7       	in	r29, 0x3e	; 62
    2948:	6e 97       	sbiw	r28, 0x1e	; 30
    294a:	0f b6       	in	r0, 0x3f	; 63
    294c:	f8 94       	cli
    294e:	de bf       	out	0x3e, r29	; 62
    2950:	0f be       	out	0x3f, r0	; 63
    2952:	cd bf       	out	0x3d, r28	; 61
    2954:	9c 01       	movw	r18, r24
    2956:	7b 01       	movw	r14, r22
	char i;
	u_long inetaddr = 0;
	char taddr[30];
	char * nexttok;
	int num;
	strcpy(taddr,addr);
    2958:	8e 01       	movw	r16, r28
    295a:	0f 5f       	subi	r16, 0xFF	; 255
    295c:	1f 4f       	sbci	r17, 0xFF	; 255
    295e:	c8 01       	movw	r24, r16
    2960:	b9 01       	movw	r22, r18
    2962:	0e 94 69 1e 	call	0x3cd2	; 0x3cd2 <strcpy>
    2966:	c8 01       	movw	r24, r16
    2968:	00 e0       	ldi	r16, 0x00	; 0
    296a:	10 e0       	ldi	r17, 0x00	; 0
	
	nexttok = taddr;
	for(i = 0; i < 4 ; i++)
	{
		nexttok = strtok(nexttok,".");
    296c:	6b e1       	ldi	r22, 0x1B	; 27
    296e:	73 e0       	ldi	r23, 0x03	; 3
    2970:	0e 94 99 11 	call	0x2332	; 0x2332 <strtok>
    2974:	fc 01       	movw	r30, r24
		if(nexttok[0] == '0' && nexttok[1] == 'x') num = ATOI(nexttok+2,0x10);
    2976:	80 81       	ld	r24, Z
    2978:	80 33       	cpi	r24, 0x30	; 48
    297a:	41 f4       	brne	.+16     	; 0x298c <inet_addr_+0x54>
    297c:	81 81       	ldd	r24, Z+1	; 0x01
    297e:	88 37       	cpi	r24, 0x78	; 120
    2980:	29 f4       	brne	.+10     	; 0x298c <inet_addr_+0x54>
    2982:	cf 01       	movw	r24, r30
    2984:	02 96       	adiw	r24, 0x02	; 2
    2986:	60 e1       	ldi	r22, 0x10	; 16
    2988:	70 e0       	ldi	r23, 0x00	; 0
    298a:	03 c0       	rjmp	.+6      	; 0x2992 <inet_addr_+0x5a>
		else num = ATOI(nexttok,10);
    298c:	cf 01       	movw	r24, r30
    298e:	6a e0       	ldi	r22, 0x0A	; 10
    2990:	70 e0       	ldi	r23, 0x00	; 0
    2992:	0e 94 13 11 	call	0x2226	; 0x2226 <ATOI>
		
		ip[i] = num;
    2996:	f7 01       	movw	r30, r14
    2998:	e0 0f       	add	r30, r16
    299a:	f1 1f       	adc	r31, r17
    299c:	80 83       	st	Z, r24
    299e:	0f 5f       	subi	r16, 0xFF	; 255
    29a0:	1f 4f       	sbci	r17, 0xFF	; 255
    29a2:	80 e0       	ldi	r24, 0x00	; 0
    29a4:	90 e0       	ldi	r25, 0x00	; 0
	char * nexttok;
	int num;
	strcpy(taddr,addr);
	
	nexttok = taddr;
	for(i = 0; i < 4 ; i++)
    29a6:	04 30       	cpi	r16, 0x04	; 4
    29a8:	11 05       	cpc	r17, r1
    29aa:	01 f7       	brne	.-64     	; 0x296c <inet_addr_+0x34>
		else num = ATOI(nexttok,10);
		
		ip[i] = num;
		nexttok = NULL;
	}
}	
    29ac:	6e 96       	adiw	r28, 0x1e	; 30
    29ae:	0f b6       	in	r0, 0x3f	; 63
    29b0:	f8 94       	cli
    29b2:	de bf       	out	0x3e, r29	; 62
    29b4:	0f be       	out	0x3f, r0	; 63
    29b6:	cd bf       	out	0x3d, r28	; 61
    29b8:	cf 91       	pop	r28
    29ba:	df 91       	pop	r29
    29bc:	1f 91       	pop	r17
    29be:	0f 91       	pop	r16
    29c0:	ff 90       	pop	r15
    29c2:	ef 90       	pop	r14
    29c4:	08 95       	ret

000029c6 <inet_ntoa_pad>:
	sprintf(addr_str,"%d.%d.%d.%d",(int)(addr>>24 & 0xFF),(int)(addr>>16 & 0xFF),(int)(addr>>8 & 0xFF),(int)(addr & 0xFF));
	return addr_str;
}

char* inet_ntoa_pad(unsigned long addr)
{
    29c6:	0f 93       	push	r16
    29c8:	1f 93       	push	r17
	static char addr_str[16];
	memset(addr_str,0,16);
    29ca:	04 eb       	ldi	r16, 0xB4	; 180
    29cc:	15 e0       	ldi	r17, 0x05	; 5
    29ce:	20 e1       	ldi	r18, 0x10	; 16
    29d0:	d8 01       	movw	r26, r16
    29d2:	1d 92       	st	X+, r1
    29d4:	2a 95       	dec	r18
    29d6:	e9 f7       	brne	.-6      	; 0x29d2 <inet_ntoa_pad+0xc>
	sprintf(addr_str,"%03d.%03d.%03d.%03d",(int)(addr>>24 & 0xFF),(int)(addr>>16 & 0xFF),(int)(addr>>8 & 0xFF),(int)(addr & 0xFF));
    29d8:	ed b7       	in	r30, 0x3d	; 61
    29da:	fe b7       	in	r31, 0x3e	; 62
    29dc:	3c 97       	sbiw	r30, 0x0c	; 12
    29de:	0f b6       	in	r0, 0x3f	; 63
    29e0:	f8 94       	cli
    29e2:	fe bf       	out	0x3e, r31	; 62
    29e4:	0f be       	out	0x3f, r0	; 63
    29e6:	ed bf       	out	0x3d, r30	; 61
    29e8:	31 96       	adiw	r30, 0x01	; 1
    29ea:	ad b7       	in	r26, 0x3d	; 61
    29ec:	be b7       	in	r27, 0x3e	; 62
    29ee:	12 96       	adiw	r26, 0x02	; 2
    29f0:	1c 93       	st	X, r17
    29f2:	0e 93       	st	-X, r16
    29f4:	11 97       	sbiw	r26, 0x01	; 1
    29f6:	2d e1       	ldi	r18, 0x1D	; 29
    29f8:	33 e0       	ldi	r19, 0x03	; 3
    29fa:	33 83       	std	Z+3, r19	; 0x03
    29fc:	22 83       	std	Z+2, r18	; 0x02
    29fe:	29 2f       	mov	r18, r25
    2a00:	33 27       	eor	r19, r19
    2a02:	44 27       	eor	r20, r20
    2a04:	55 27       	eor	r21, r21
    2a06:	35 83       	std	Z+5, r19	; 0x05
    2a08:	24 83       	std	Z+4, r18	; 0x04
    2a0a:	9c 01       	movw	r18, r24
    2a0c:	44 27       	eor	r20, r20
    2a0e:	55 27       	eor	r21, r21
    2a10:	30 70       	andi	r19, 0x00	; 0
    2a12:	37 83       	std	Z+7, r19	; 0x07
    2a14:	26 83       	std	Z+6, r18	; 0x06
    2a16:	27 2f       	mov	r18, r23
    2a18:	38 2f       	mov	r19, r24
    2a1a:	49 2f       	mov	r20, r25
    2a1c:	55 27       	eor	r21, r21
    2a1e:	30 70       	andi	r19, 0x00	; 0
    2a20:	31 87       	std	Z+9, r19	; 0x09
    2a22:	20 87       	std	Z+8, r18	; 0x08
    2a24:	70 70       	andi	r23, 0x00	; 0
    2a26:	73 87       	std	Z+11, r23	; 0x0b
    2a28:	62 87       	std	Z+10, r22	; 0x0a
    2a2a:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <sprintf>
    2a2e:	ed b7       	in	r30, 0x3d	; 61
    2a30:	fe b7       	in	r31, 0x3e	; 62
    2a32:	3c 96       	adiw	r30, 0x0c	; 12
    2a34:	0f b6       	in	r0, 0x3f	; 63
    2a36:	f8 94       	cli
    2a38:	fe bf       	out	0x3e, r31	; 62
    2a3a:	0f be       	out	0x3f, r0	; 63
    2a3c:	ed bf       	out	0x3d, r30	; 61
	return addr_str;
}
    2a3e:	c8 01       	movw	r24, r16
    2a40:	1f 91       	pop	r17
    2a42:	0f 91       	pop	r16
    2a44:	08 95       	ret

00002a46 <inet_ntoa>:
@return 	a char pointer to a static buffer containing the text address in standard ".'' notation. Otherwise, it returns NULL. 
*/  
char* inet_ntoa(
	unsigned long addr	/**< Pointer variable to store converted value(INPUT) */
	)
{
    2a46:	0f 93       	push	r16
    2a48:	1f 93       	push	r17
	static char addr_str[16];
	memset(addr_str,0,16);
    2a4a:	04 ec       	ldi	r16, 0xC4	; 196
    2a4c:	15 e0       	ldi	r17, 0x05	; 5
    2a4e:	20 e1       	ldi	r18, 0x10	; 16
    2a50:	d8 01       	movw	r26, r16
    2a52:	1d 92       	st	X+, r1
    2a54:	2a 95       	dec	r18
    2a56:	e9 f7       	brne	.-6      	; 0x2a52 <inet_ntoa+0xc>
	sprintf(addr_str,"%d.%d.%d.%d",(int)(addr>>24 & 0xFF),(int)(addr>>16 & 0xFF),(int)(addr>>8 & 0xFF),(int)(addr & 0xFF));
    2a58:	ed b7       	in	r30, 0x3d	; 61
    2a5a:	fe b7       	in	r31, 0x3e	; 62
    2a5c:	3c 97       	sbiw	r30, 0x0c	; 12
    2a5e:	0f b6       	in	r0, 0x3f	; 63
    2a60:	f8 94       	cli
    2a62:	fe bf       	out	0x3e, r31	; 62
    2a64:	0f be       	out	0x3f, r0	; 63
    2a66:	ed bf       	out	0x3d, r30	; 61
    2a68:	31 96       	adiw	r30, 0x01	; 1
    2a6a:	ad b7       	in	r26, 0x3d	; 61
    2a6c:	be b7       	in	r27, 0x3e	; 62
    2a6e:	12 96       	adiw	r26, 0x02	; 2
    2a70:	1c 93       	st	X, r17
    2a72:	0e 93       	st	-X, r16
    2a74:	11 97       	sbiw	r26, 0x01	; 1
    2a76:	21 e3       	ldi	r18, 0x31	; 49
    2a78:	33 e0       	ldi	r19, 0x03	; 3
    2a7a:	33 83       	std	Z+3, r19	; 0x03
    2a7c:	22 83       	std	Z+2, r18	; 0x02
    2a7e:	29 2f       	mov	r18, r25
    2a80:	33 27       	eor	r19, r19
    2a82:	44 27       	eor	r20, r20
    2a84:	55 27       	eor	r21, r21
    2a86:	35 83       	std	Z+5, r19	; 0x05
    2a88:	24 83       	std	Z+4, r18	; 0x04
    2a8a:	9c 01       	movw	r18, r24
    2a8c:	44 27       	eor	r20, r20
    2a8e:	55 27       	eor	r21, r21
    2a90:	30 70       	andi	r19, 0x00	; 0
    2a92:	37 83       	std	Z+7, r19	; 0x07
    2a94:	26 83       	std	Z+6, r18	; 0x06
    2a96:	27 2f       	mov	r18, r23
    2a98:	38 2f       	mov	r19, r24
    2a9a:	49 2f       	mov	r20, r25
    2a9c:	55 27       	eor	r21, r21
    2a9e:	30 70       	andi	r19, 0x00	; 0
    2aa0:	31 87       	std	Z+9, r19	; 0x09
    2aa2:	20 87       	std	Z+8, r18	; 0x08
    2aa4:	70 70       	andi	r23, 0x00	; 0
    2aa6:	73 87       	std	Z+11, r23	; 0x0b
    2aa8:	62 87       	std	Z+10, r22	; 0x0a
    2aaa:	0e 94 06 1f 	call	0x3e0c	; 0x3e0c <sprintf>
    2aae:	ed b7       	in	r30, 0x3d	; 61
    2ab0:	fe b7       	in	r31, 0x3e	; 62
    2ab2:	3c 96       	adiw	r30, 0x0c	; 12
    2ab4:	0f b6       	in	r0, 0x3f	; 63
    2ab6:	f8 94       	cli
    2ab8:	fe bf       	out	0x3e, r31	; 62
    2aba:	0f be       	out	0x3f, r0	; 63
    2abc:	ed bf       	out	0x3d, r30	; 61
	return addr_str;
}
    2abe:	c8 01       	movw	r24, r16
    2ac0:	1f 91       	pop	r17
    2ac2:	0f 91       	pop	r16
    2ac4:	08 95       	ret

00002ac6 <GetNetConfig>:
/**
@brief	Read established network information(G/W, IP, S/N, Mac) of iinChip and Output that through Serial.
		Mac Address is output into format of Dotted HexaDecimal.Others are output into format of Dotted Decimal Format.
*/ 
void GetNetConfig(void)
{
    2ac6:	0f 93       	push	r16
    2ac8:	1f 93       	push	r17
    2aca:	df 93       	push	r29
    2acc:	cf 93       	push	r28
    2ace:	00 d0       	rcall	.+0      	; 0x2ad0 <GetNetConfig+0xa>
    2ad0:	00 d0       	rcall	.+0      	; 0x2ad2 <GetNetConfig+0xc>
    2ad2:	00 d0       	rcall	.+0      	; 0x2ad4 <GetNetConfig+0xe>
    2ad4:	cd b7       	in	r28, 0x3d	; 61
    2ad6:	de b7       	in	r29, 0x3e	; 62
	u_char addr[6];
	u_long iaddr;
	printf("\r\n================================================\r\n");
    2ad8:	8d e3       	ldi	r24, 0x3D	; 61
    2ada:	93 e0       	ldi	r25, 0x03	; 3
    2adc:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
	printf("       Net Config Information\r\n");
    2ae0:	81 e7       	ldi	r24, 0x71	; 113
    2ae2:	93 e0       	ldi	r25, 0x03	; 3
    2ae4:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
	printf("================================================\r\n");
    2ae8:	00 e9       	ldi	r16, 0x90	; 144
    2aea:	13 e0       	ldi	r17, 0x03	; 3
    2aec:	c8 01       	movw	r24, r16
    2aee:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
	GetMacAddress(addr);
    2af2:	ce 01       	movw	r24, r28
    2af4:	01 96       	adiw	r24, 0x01	; 1
    2af6:	0e 94 03 13 	call	0x2606	; 0x2606 <GetMacAddress>
	printf("MAC ADDRESS      : 0x%02X.0x%02X.0x%02X.0x%02X.0x%02X.0x%02X\r\n",addr[0],addr[1],addr[2],addr[3],addr[4],addr[5]);
    2afa:	8d b7       	in	r24, 0x3d	; 61
    2afc:	9e b7       	in	r25, 0x3e	; 62
    2afe:	0e 97       	sbiw	r24, 0x0e	; 14
    2b00:	0f b6       	in	r0, 0x3f	; 63
    2b02:	f8 94       	cli
    2b04:	9e bf       	out	0x3e, r25	; 62
    2b06:	0f be       	out	0x3f, r0	; 63
    2b08:	8d bf       	out	0x3d, r24	; 61
    2b0a:	ed b7       	in	r30, 0x3d	; 61
    2b0c:	fe b7       	in	r31, 0x3e	; 62
    2b0e:	31 96       	adiw	r30, 0x01	; 1
    2b10:	82 ec       	ldi	r24, 0xC2	; 194
    2b12:	93 e0       	ldi	r25, 0x03	; 3
    2b14:	ad b7       	in	r26, 0x3d	; 61
    2b16:	be b7       	in	r27, 0x3e	; 62
    2b18:	12 96       	adiw	r26, 0x02	; 2
    2b1a:	9c 93       	st	X, r25
    2b1c:	8e 93       	st	-X, r24
    2b1e:	11 97       	sbiw	r26, 0x01	; 1
    2b20:	89 81       	ldd	r24, Y+1	; 0x01
    2b22:	82 83       	std	Z+2, r24	; 0x02
    2b24:	13 82       	std	Z+3, r1	; 0x03
    2b26:	8a 81       	ldd	r24, Y+2	; 0x02
    2b28:	84 83       	std	Z+4, r24	; 0x04
    2b2a:	15 82       	std	Z+5, r1	; 0x05
    2b2c:	8b 81       	ldd	r24, Y+3	; 0x03
    2b2e:	86 83       	std	Z+6, r24	; 0x06
    2b30:	17 82       	std	Z+7, r1	; 0x07
    2b32:	8c 81       	ldd	r24, Y+4	; 0x04
    2b34:	80 87       	std	Z+8, r24	; 0x08
    2b36:	11 86       	std	Z+9, r1	; 0x09
    2b38:	8d 81       	ldd	r24, Y+5	; 0x05
    2b3a:	82 87       	std	Z+10, r24	; 0x0a
    2b3c:	13 86       	std	Z+11, r1	; 0x0b
    2b3e:	8e 81       	ldd	r24, Y+6	; 0x06
    2b40:	84 87       	std	Z+12, r24	; 0x0c
    2b42:	15 86       	std	Z+13, r1	; 0x0d
    2b44:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
	
	iaddr = GetSubMask();
    2b48:	ed b7       	in	r30, 0x3d	; 61
    2b4a:	fe b7       	in	r31, 0x3e	; 62
    2b4c:	3e 96       	adiw	r30, 0x0e	; 14
    2b4e:	0f b6       	in	r0, 0x3f	; 63
    2b50:	f8 94       	cli
    2b52:	fe bf       	out	0x3e, r31	; 62
    2b54:	0f be       	out	0x3f, r0	; 63
    2b56:	ed bf       	out	0x3d, r30	; 61
    2b58:	0e 94 1a 13 	call	0x2634	; 0x2634 <GetSubMask>
	
	printf("SUBNET MASK      : %s\r\n",inet_ntoa(iaddr));
    2b5c:	0e 94 23 15 	call	0x2a46	; 0x2a46 <inet_ntoa>
    2b60:	00 d0       	rcall	.+0      	; 0x2b62 <GetNetConfig+0x9c>
    2b62:	00 d0       	rcall	.+0      	; 0x2b64 <GetNetConfig+0x9e>
    2b64:	21 e0       	ldi	r18, 0x01	; 1
    2b66:	34 e0       	ldi	r19, 0x04	; 4
    2b68:	ad b7       	in	r26, 0x3d	; 61
    2b6a:	be b7       	in	r27, 0x3e	; 62
    2b6c:	12 96       	adiw	r26, 0x02	; 2
    2b6e:	3c 93       	st	X, r19
    2b70:	2e 93       	st	-X, r18
    2b72:	11 97       	sbiw	r26, 0x01	; 1
    2b74:	14 96       	adiw	r26, 0x04	; 4
    2b76:	9c 93       	st	X, r25
    2b78:	8e 93       	st	-X, r24
    2b7a:	13 97       	sbiw	r26, 0x03	; 3
    2b7c:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>

	iaddr = GetGWAddress();
    2b80:	0f 90       	pop	r0
    2b82:	0f 90       	pop	r0
    2b84:	0f 90       	pop	r0
    2b86:	0f 90       	pop	r0
    2b88:	0e 94 41 13 	call	0x2682	; 0x2682 <GetGWAddress>
	printf("G/W IP ADDRESS   : %s\r\n",inet_ntoa(iaddr));
    2b8c:	0e 94 23 15 	call	0x2a46	; 0x2a46 <inet_ntoa>
    2b90:	00 d0       	rcall	.+0      	; 0x2b92 <GetNetConfig+0xcc>
    2b92:	00 d0       	rcall	.+0      	; 0x2b94 <GetNetConfig+0xce>
    2b94:	29 e1       	ldi	r18, 0x19	; 25
    2b96:	34 e0       	ldi	r19, 0x04	; 4
    2b98:	ed b7       	in	r30, 0x3d	; 61
    2b9a:	fe b7       	in	r31, 0x3e	; 62
    2b9c:	32 83       	std	Z+2, r19	; 0x02
    2b9e:	21 83       	std	Z+1, r18	; 0x01
    2ba0:	94 83       	std	Z+4, r25	; 0x04
    2ba2:	83 83       	std	Z+3, r24	; 0x03
    2ba4:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>

	iaddr = GetIPAddress();
    2ba8:	0f 90       	pop	r0
    2baa:	0f 90       	pop	r0
    2bac:	0f 90       	pop	r0
    2bae:	0f 90       	pop	r0
    2bb0:	0e 94 68 13 	call	0x26d0	; 0x26d0 <GetIPAddress>
	printf("LOCAL IP ADDRESS : %s\r\n",inet_ntoa(iaddr)); 
    2bb4:	0e 94 23 15 	call	0x2a46	; 0x2a46 <inet_ntoa>
    2bb8:	00 d0       	rcall	.+0      	; 0x2bba <GetNetConfig+0xf4>
    2bba:	00 d0       	rcall	.+0      	; 0x2bbc <GetNetConfig+0xf6>
    2bbc:	21 e3       	ldi	r18, 0x31	; 49
    2bbe:	34 e0       	ldi	r19, 0x04	; 4
    2bc0:	ad b7       	in	r26, 0x3d	; 61
    2bc2:	be b7       	in	r27, 0x3e	; 62
    2bc4:	12 96       	adiw	r26, 0x02	; 2
    2bc6:	3c 93       	st	X, r19
    2bc8:	2e 93       	st	-X, r18
    2bca:	11 97       	sbiw	r26, 0x01	; 1
    2bcc:	14 96       	adiw	r26, 0x04	; 4
    2bce:	9c 93       	st	X, r25
    2bd0:	8e 93       	st	-X, r24
    2bd2:	13 97       	sbiw	r26, 0x03	; 3
    2bd4:	0e 94 bc 1e 	call	0x3d78	; 0x3d78 <printf>
	printf("================================================\r\n");		
    2bd8:	0f 90       	pop	r0
    2bda:	0f 90       	pop	r0
    2bdc:	0f 90       	pop	r0
    2bde:	0f 90       	pop	r0
    2be0:	c8 01       	movw	r24, r16
    2be2:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <puts>
}
    2be6:	26 96       	adiw	r28, 0x06	; 6
    2be8:	0f b6       	in	r0, 0x3f	; 63
    2bea:	f8 94       	cli
    2bec:	de bf       	out	0x3e, r29	; 62
    2bee:	0f be       	out	0x3f, r0	; 63
    2bf0:	cd bf       	out	0x3d, r28	; 61
    2bf2:	cf 91       	pop	r28
    2bf4:	df 91       	pop	r29
    2bf6:	1f 91       	pop	r17
    2bf8:	0f 91       	pop	r16
    2bfa:	08 95       	ret

00002bfc <lcd_ready>:
/**
@brief	Check to be ready LCD.
@return 	If it's ready ,then '1',else then '-1'. If LCD Device is not insert actually,then return '-1'.
*/
char lcd_ready(void)
{
    2bfc:	df 93       	push	r29
    2bfe:	cf 93       	push	r28
    2c00:	00 d0       	rcall	.+0      	; 0x2c02 <lcd_ready+0x6>
    2c02:	00 d0       	rcall	.+0      	; 0x2c04 <lcd_ready+0x8>
    2c04:	00 d0       	rcall	.+0      	; 0x2c06 <lcd_ready+0xa>
    2c06:	cd b7       	in	r28, 0x3d	; 61
    2c08:	de b7       	in	r29, 0x3e	; 62
    volatile unsigned int i, j, time;
	time = LCD_DELAY;
    2c0a:	88 e7       	ldi	r24, 0x78	; 120
    2c0c:	90 e0       	ldi	r25, 0x00	; 0
    2c0e:	1b c0       	rjmp	.+54     	; 0x2c46 <lcd_ready+0x4a>

	while(time)
    {
	    for(i=0;i<3;i++)
    2c10:	1a 82       	std	Y+2, r1	; 0x02
    2c12:	19 82       	std	Y+1, r1	; 0x01
    2c14:	11 c0       	rjmp	.+34     	; 0x2c38 <lcd_ready+0x3c>
	    	for(j=0;j<1;j++);
    2c16:	1c 82       	std	Y+4, r1	; 0x04
    2c18:	1b 82       	std	Y+3, r1	; 0x03
    2c1a:	05 c0       	rjmp	.+10     	; 0x2c26 <lcd_ready+0x2a>
    2c1c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c1e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c20:	01 96       	adiw	r24, 0x01	; 1
    2c22:	9c 83       	std	Y+4, r25	; 0x04
    2c24:	8b 83       	std	Y+3, r24	; 0x03
    2c26:	8b 81       	ldd	r24, Y+3	; 0x03
    2c28:	9c 81       	ldd	r25, Y+4	; 0x04
    2c2a:	89 2b       	or	r24, r25
    2c2c:	b9 f3       	breq	.-18     	; 0x2c1c <lcd_ready+0x20>
    volatile unsigned int i, j, time;
	time = LCD_DELAY;

	while(time)
    {
	    for(i=0;i<3;i++)
    2c2e:	89 81       	ldd	r24, Y+1	; 0x01
    2c30:	9a 81       	ldd	r25, Y+2	; 0x02
    2c32:	01 96       	adiw	r24, 0x01	; 1
    2c34:	9a 83       	std	Y+2, r25	; 0x02
    2c36:	89 83       	std	Y+1, r24	; 0x01
    2c38:	89 81       	ldd	r24, Y+1	; 0x01
    2c3a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c3c:	03 97       	sbiw	r24, 0x03	; 3
    2c3e:	58 f3       	brcs	.-42     	; 0x2c16 <lcd_ready+0x1a>
	    	for(j=0;j<1;j++);
	        	time--;
    2c40:	8d 81       	ldd	r24, Y+5	; 0x05
    2c42:	9e 81       	ldd	r25, Y+6	; 0x06
    2c44:	01 97       	sbiw	r24, 0x01	; 1
    2c46:	9e 83       	std	Y+6, r25	; 0x06
    2c48:	8d 83       	std	Y+5, r24	; 0x05
char lcd_ready(void)
{
    volatile unsigned int i, j, time;
	time = LCD_DELAY;

	while(time)
    2c4a:	8d 81       	ldd	r24, Y+5	; 0x05
    2c4c:	9e 81       	ldd	r25, Y+6	; 0x06
    2c4e:	89 2b       	or	r24, r25
    2c50:	f9 f6       	brne	.-66     	; 0x2c10 <lcd_ready+0x14>
	    for(i=0;i<3;i++)
	    	for(j=0;j<1;j++);
	        	time--;
    }
	return 1;
}
    2c52:	81 e0       	ldi	r24, 0x01	; 1
    2c54:	26 96       	adiw	r28, 0x06	; 6
    2c56:	0f b6       	in	r0, 0x3f	; 63
    2c58:	f8 94       	cli
    2c5a:	de bf       	out	0x3e, r29	; 62
    2c5c:	0f be       	out	0x3f, r0	; 63
    2c5e:	cd bf       	out	0x3d, r28	; 61
    2c60:	cf 91       	pop	r28
    2c62:	df 91       	pop	r29
    2c64:	08 95       	ret

00002c66 <lcd_delay>:
	lcd_ready();
	lcd_command(0x01);
}

void lcd_delay(unsigned int time)
{
    2c66:	df 93       	push	r29
    2c68:	cf 93       	push	r28
    2c6a:	00 d0       	rcall	.+0      	; 0x2c6c <lcd_delay+0x6>
    2c6c:	00 d0       	rcall	.+0      	; 0x2c6e <lcd_delay+0x8>
    2c6e:	cd b7       	in	r28, 0x3d	; 61
    2c70:	de b7       	in	r29, 0x3e	; 62
    2c72:	9c 01       	movw	r18, r24
    2c74:	1a c0       	rjmp	.+52     	; 0x2caa <lcd_delay+0x44>
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2c76:	1a 82       	std	Y+2, r1	; 0x02
    2c78:	19 82       	std	Y+1, r1	; 0x01
    2c7a:	11 c0       	rjmp	.+34     	; 0x2c9e <lcd_delay+0x38>
	    	for(j=0;j<1;j++);
    2c7c:	1c 82       	std	Y+4, r1	; 0x04
    2c7e:	1b 82       	std	Y+3, r1	; 0x03
    2c80:	05 c0       	rjmp	.+10     	; 0x2c8c <lcd_delay+0x26>
    2c82:	8b 81       	ldd	r24, Y+3	; 0x03
    2c84:	9c 81       	ldd	r25, Y+4	; 0x04
    2c86:	01 96       	adiw	r24, 0x01	; 1
    2c88:	9c 83       	std	Y+4, r25	; 0x04
    2c8a:	8b 83       	std	Y+3, r24	; 0x03
    2c8c:	8b 81       	ldd	r24, Y+3	; 0x03
    2c8e:	9c 81       	ldd	r25, Y+4	; 0x04
    2c90:	89 2b       	or	r24, r25
    2c92:	b9 f3       	breq	.-18     	; 0x2c82 <lcd_delay+0x1c>
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2c94:	89 81       	ldd	r24, Y+1	; 0x01
    2c96:	9a 81       	ldd	r25, Y+2	; 0x02
    2c98:	01 96       	adiw	r24, 0x01	; 1
    2c9a:	9a 83       	std	Y+2, r25	; 0x02
    2c9c:	89 83       	std	Y+1, r24	; 0x01
    2c9e:	89 81       	ldd	r24, Y+1	; 0x01
    2ca0:	9a 81       	ldd	r25, Y+2	; 0x02
    2ca2:	03 97       	sbiw	r24, 0x03	; 3
    2ca4:	58 f3       	brcs	.-42     	; 0x2c7c <lcd_delay+0x16>
	    	for(j=0;j<1;j++);
	        	time--;
    2ca6:	21 50       	subi	r18, 0x01	; 1
    2ca8:	30 40       	sbci	r19, 0x00	; 0
}

void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    2caa:	21 15       	cp	r18, r1
    2cac:	31 05       	cpc	r19, r1
    2cae:	19 f7       	brne	.-58     	; 0x2c76 <lcd_delay+0x10>
    {
	    for(i=0;i<3;i++)
	    	for(j=0;j<1;j++);
	        	time--;
    }
}
    2cb0:	0f 90       	pop	r0
    2cb2:	0f 90       	pop	r0
    2cb4:	0f 90       	pop	r0
    2cb6:	0f 90       	pop	r0
    2cb8:	cf 91       	pop	r28
    2cba:	df 91       	pop	r29
    2cbc:	08 95       	ret

00002cbe <lcd_command>:

void lcd_command(unsigned char Value)
{
    2cbe:	df 93       	push	r29
    2cc0:	cf 93       	push	r28
    2cc2:	00 d0       	rcall	.+0      	; 0x2cc4 <lcd_command+0x6>
    2cc4:	00 d0       	rcall	.+0      	; 0x2cc6 <lcd_command+0x8>
    2cc6:	cd b7       	in	r28, 0x3d	; 61
    2cc8:	de b7       	in	r29, 0x3e	; 62
    2cca:	48 2f       	mov	r20, r24
    2ccc:	28 e7       	ldi	r18, 0x78	; 120
    2cce:	30 e0       	ldi	r19, 0x00	; 0
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2cd0:	1a 82       	std	Y+2, r1	; 0x02
    2cd2:	19 82       	std	Y+1, r1	; 0x01
    2cd4:	11 c0       	rjmp	.+34     	; 0x2cf8 <lcd_command+0x3a>
	    	for(j=0;j<1;j++);
    2cd6:	1c 82       	std	Y+4, r1	; 0x04
    2cd8:	1b 82       	std	Y+3, r1	; 0x03
    2cda:	05 c0       	rjmp	.+10     	; 0x2ce6 <lcd_command+0x28>
    2cdc:	8b 81       	ldd	r24, Y+3	; 0x03
    2cde:	9c 81       	ldd	r25, Y+4	; 0x04
    2ce0:	01 96       	adiw	r24, 0x01	; 1
    2ce2:	9c 83       	std	Y+4, r25	; 0x04
    2ce4:	8b 83       	std	Y+3, r24	; 0x03
    2ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    2ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    2cea:	89 2b       	or	r24, r25
    2cec:	b9 f3       	breq	.-18     	; 0x2cdc <lcd_command+0x1e>
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2cee:	89 81       	ldd	r24, Y+1	; 0x01
    2cf0:	9a 81       	ldd	r25, Y+2	; 0x02
    2cf2:	01 96       	adiw	r24, 0x01	; 1
    2cf4:	9a 83       	std	Y+2, r25	; 0x02
    2cf6:	89 83       	std	Y+1, r24	; 0x01
    2cf8:	89 81       	ldd	r24, Y+1	; 0x01
    2cfa:	9a 81       	ldd	r25, Y+2	; 0x02
    2cfc:	03 97       	sbiw	r24, 0x03	; 3
    2cfe:	58 f3       	brcs	.-42     	; 0x2cd6 <lcd_command+0x18>
	    	for(j=0;j<1;j++);
	        	time--;
    2d00:	21 50       	subi	r18, 0x01	; 1
    2d02:	30 40       	sbci	r19, 0x00	; 0
}

void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    2d04:	29 f7       	brne	.-54     	; 0x2cd0 <lcd_command+0x12>
}

void lcd_command(unsigned char Value)
{
	lcd_delay(LCD_DELAY);	//busy check		
	LCD_RSOFF();	
    2d06:	1a 98       	cbi	0x03, 2	; 3
	LCD_RWOFF();
    2d08:	1b 98       	cbi	0x03, 3	; 3

	LCD_DATA(Value);
    2d0a:	82 b3       	in	r24, 0x12	; 18
    2d0c:	94 2f       	mov	r25, r20
    2d0e:	90 7f       	andi	r25, 0xF0	; 240
    2d10:	8f 70       	andi	r24, 0x0F	; 15
    2d12:	98 2b       	or	r25, r24
    2d14:	92 bb       	out	0x12, r25	; 18
    2d16:	1f 9a       	sbi	0x03, 7	; 3
    2d18:	1f 98       	cbi	0x03, 7	; 3
    2d1a:	82 b3       	in	r24, 0x12	; 18
    2d1c:	42 95       	swap	r20
    2d1e:	40 7f       	andi	r20, 0xF0	; 240
    2d20:	8f 70       	andi	r24, 0x0F	; 15
    2d22:	84 2b       	or	r24, r20
    2d24:	82 bb       	out	0x12, r24	; 18
	
	LCD_ENABLE();	
    2d26:	1f 9a       	sbi	0x03, 7	; 3
	LCD_DISABLE();
    2d28:	1f 98       	cbi	0x03, 7	; 3
}
    2d2a:	0f 90       	pop	r0
    2d2c:	0f 90       	pop	r0
    2d2e:	0f 90       	pop	r0
    2d30:	0f 90       	pop	r0
    2d32:	cf 91       	pop	r28
    2d34:	df 91       	pop	r29
    2d36:	08 95       	ret

00002d38 <lcd_clrscr>:
/**
 @brief		Clear LCD. 
*/
void lcd_clrscr(void)       
{
	lcd_ready();
    2d38:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <lcd_ready>
	lcd_command(0x01);
    2d3c:	81 e0       	ldi	r24, 0x01	; 1
    2d3e:	90 e0       	ldi	r25, 0x00	; 0
    2d40:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <lcd_command>
}
    2d44:	08 95       	ret

00002d46 <lcd_data>:
	LCD_ENABLE();	
	LCD_DISABLE();
}

void lcd_data(unsigned char ch)
{
    2d46:	df 93       	push	r29
    2d48:	cf 93       	push	r28
    2d4a:	00 d0       	rcall	.+0      	; 0x2d4c <lcd_data+0x6>
    2d4c:	00 d0       	rcall	.+0      	; 0x2d4e <lcd_data+0x8>
    2d4e:	cd b7       	in	r28, 0x3d	; 61
    2d50:	de b7       	in	r29, 0x3e	; 62
    2d52:	48 2f       	mov	r20, r24
    2d54:	28 e7       	ldi	r18, 0x78	; 120
    2d56:	30 e0       	ldi	r19, 0x00	; 0
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2d58:	1a 82       	std	Y+2, r1	; 0x02
    2d5a:	19 82       	std	Y+1, r1	; 0x01
    2d5c:	11 c0       	rjmp	.+34     	; 0x2d80 <lcd_data+0x3a>
	    	for(j=0;j<1;j++);
    2d5e:	1c 82       	std	Y+4, r1	; 0x04
    2d60:	1b 82       	std	Y+3, r1	; 0x03
    2d62:	05 c0       	rjmp	.+10     	; 0x2d6e <lcd_data+0x28>
    2d64:	8b 81       	ldd	r24, Y+3	; 0x03
    2d66:	9c 81       	ldd	r25, Y+4	; 0x04
    2d68:	01 96       	adiw	r24, 0x01	; 1
    2d6a:	9c 83       	std	Y+4, r25	; 0x04
    2d6c:	8b 83       	std	Y+3, r24	; 0x03
    2d6e:	8b 81       	ldd	r24, Y+3	; 0x03
    2d70:	9c 81       	ldd	r25, Y+4	; 0x04
    2d72:	89 2b       	or	r24, r25
    2d74:	b9 f3       	breq	.-18     	; 0x2d64 <lcd_data+0x1e>
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2d76:	89 81       	ldd	r24, Y+1	; 0x01
    2d78:	9a 81       	ldd	r25, Y+2	; 0x02
    2d7a:	01 96       	adiw	r24, 0x01	; 1
    2d7c:	9a 83       	std	Y+2, r25	; 0x02
    2d7e:	89 83       	std	Y+1, r24	; 0x01
    2d80:	89 81       	ldd	r24, Y+1	; 0x01
    2d82:	9a 81       	ldd	r25, Y+2	; 0x02
    2d84:	03 97       	sbiw	r24, 0x03	; 3
    2d86:	58 f3       	brcs	.-42     	; 0x2d5e <lcd_data+0x18>
	    	for(j=0;j<1;j++);
	        	time--;
    2d88:	21 50       	subi	r18, 0x01	; 1
    2d8a:	30 40       	sbci	r19, 0x00	; 0
}

void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    2d8c:	29 f7       	brne	.-54     	; 0x2d58 <lcd_data+0x12>
}

void lcd_data(unsigned char ch)
{
	lcd_delay(LCD_DELAY);	//busy check		
	LCD_RSON();							//RS On
    2d8e:	1a 9a       	sbi	0x03, 2	; 3
	LCD_RWOFF();	
    2d90:	1b 98       	cbi	0x03, 3	; 3

	LCD_DATA(ch);
    2d92:	82 b3       	in	r24, 0x12	; 18
    2d94:	94 2f       	mov	r25, r20
    2d96:	90 7f       	andi	r25, 0xF0	; 240
    2d98:	8f 70       	andi	r24, 0x0F	; 15
    2d9a:	98 2b       	or	r25, r24
    2d9c:	92 bb       	out	0x12, r25	; 18
    2d9e:	1f 9a       	sbi	0x03, 7	; 3
    2da0:	1f 98       	cbi	0x03, 7	; 3
    2da2:	82 b3       	in	r24, 0x12	; 18
    2da4:	42 95       	swap	r20
    2da6:	40 7f       	andi	r20, 0xF0	; 240
    2da8:	8f 70       	andi	r24, 0x0F	; 15
    2daa:	84 2b       	or	r24, r20
    2dac:	82 bb       	out	0x12, r24	; 18

	LCD_ENABLE();	
    2dae:	1f 9a       	sbi	0x03, 7	; 3
	LCD_DISABLE();
    2db0:	1f 98       	cbi	0x03, 7	; 3
}
    2db2:	0f 90       	pop	r0
    2db4:	0f 90       	pop	r0
    2db6:	0f 90       	pop	r0
    2db8:	0f 90       	pop	r0
    2dba:	cf 91       	pop	r28
    2dbc:	df 91       	pop	r29
    2dbe:	08 95       	ret

00002dc0 <lcd_gotoxy>:
*/
void lcd_gotoxy(
	u_char x, 	/**< x - Column to move(INPUT) */
	u_char y		/**< y - Row to move(INPUT) */
	)
{
    2dc0:	0f 93       	push	r16
    2dc2:	1f 93       	push	r17
    2dc4:	08 2f       	mov	r16, r24
    2dc6:	16 2f       	mov	r17, r22
    lcd_ready();
    2dc8:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <lcd_ready>
    switch(y)
    2dcc:	11 30       	cpi	r17, 0x01	; 1
    2dce:	51 f0       	breq	.+20     	; 0x2de4 <lcd_gotoxy+0x24>
    2dd0:	11 30       	cpi	r17, 0x01	; 1
    2dd2:	28 f0       	brcs	.+10     	; 0x2dde <lcd_gotoxy+0x1e>
    2dd4:	12 30       	cpi	r17, 0x02	; 2
    2dd6:	49 f0       	breq	.+18     	; 0x2dea <lcd_gotoxy+0x2a>
    2dd8:	13 30       	cpi	r17, 0x03	; 3
    2dda:	71 f4       	brne	.+28     	; 0x2df8 <lcd_gotoxy+0x38>
    2ddc:	09 c0       	rjmp	.+18     	; 0x2df0 <lcd_gotoxy+0x30>
    {
        case 0 : lcd_command(0x80 + x); break;
    2dde:	80 2f       	mov	r24, r16
    2de0:	80 58       	subi	r24, 0x80	; 128
    2de2:	08 c0       	rjmp	.+16     	; 0x2df4 <lcd_gotoxy+0x34>
        case 1 : lcd_command(0xC0 + x); break;
    2de4:	80 2f       	mov	r24, r16
    2de6:	80 54       	subi	r24, 0x40	; 64
    2de8:	05 c0       	rjmp	.+10     	; 0x2df4 <lcd_gotoxy+0x34>
        case 2 : lcd_command(0x94 + x); break;
    2dea:	80 2f       	mov	r24, r16
    2dec:	8c 56       	subi	r24, 0x6C	; 108
    2dee:	02 c0       	rjmp	.+4      	; 0x2df4 <lcd_gotoxy+0x34>
        case 3 : lcd_command(0xD4 + x); break;
    2df0:	80 2f       	mov	r24, r16
    2df2:	8c 52       	subi	r24, 0x2C	; 44
    2df4:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <lcd_command>
    }
}
    2df8:	1f 91       	pop	r17
    2dfa:	0f 91       	pop	r16
    2dfc:	08 95       	ret

00002dfe <lcd_init>:
/**
 @brief	Initialize LCD.
 @return 	If initialization is O.K, then return '1', else then return '0'. 
*/
char lcd_init(void)
{
    2dfe:	df 93       	push	r29
    2e00:	cf 93       	push	r28
    2e02:	00 d0       	rcall	.+0      	; 0x2e04 <lcd_init+0x6>
    2e04:	00 d0       	rcall	.+0      	; 0x2e06 <lcd_init+0x8>
    2e06:	cd b7       	in	r28, 0x3d	; 61
    2e08:	de b7       	in	r29, 0x3e	; 62
	LCD_RW_INIT();
    2e0a:	13 9a       	sbi	0x02, 3	; 2
	LCD_RS_INIT();
    2e0c:	12 9a       	sbi	0x02, 2	; 2
	LCD_EN_INIT();
    2e0e:	17 9a       	sbi	0x02, 7	; 2
	LCD_DATA_DDR |= 0xF0;	
    2e10:	81 b3       	in	r24, 0x11	; 17
    2e12:	80 6f       	ori	r24, 0xF0	; 240
    2e14:	81 bb       	out	0x11, r24	; 17
	
	LCD_DISABLE();
    2e16:	1f 98       	cbi	0x03, 7	; 3
	LCD_RSOFF();	
    2e18:	1a 98       	cbi	0x03, 2	; 3
	LCD_RWOFF();
    2e1a:	1b 98       	cbi	0x03, 3	; 3
    2e1c:	2c e6       	ldi	r18, 0x6C	; 108
    2e1e:	32 e0       	ldi	r19, 0x02	; 2
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2e20:	1c 82       	std	Y+4, r1	; 0x04
    2e22:	1b 82       	std	Y+3, r1	; 0x03
    2e24:	11 c0       	rjmp	.+34     	; 0x2e48 <lcd_init+0x4a>
	    	for(j=0;j<1;j++);
    2e26:	1a 82       	std	Y+2, r1	; 0x02
    2e28:	19 82       	std	Y+1, r1	; 0x01
    2e2a:	05 c0       	rjmp	.+10     	; 0x2e36 <lcd_init+0x38>
    2e2c:	89 81       	ldd	r24, Y+1	; 0x01
    2e2e:	9a 81       	ldd	r25, Y+2	; 0x02
    2e30:	01 96       	adiw	r24, 0x01	; 1
    2e32:	9a 83       	std	Y+2, r25	; 0x02
    2e34:	89 83       	std	Y+1, r24	; 0x01
    2e36:	89 81       	ldd	r24, Y+1	; 0x01
    2e38:	9a 81       	ldd	r25, Y+2	; 0x02
    2e3a:	89 2b       	or	r24, r25
    2e3c:	b9 f3       	breq	.-18     	; 0x2e2c <lcd_init+0x2e>
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2e3e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e40:	9c 81       	ldd	r25, Y+4	; 0x04
    2e42:	01 96       	adiw	r24, 0x01	; 1
    2e44:	9c 83       	std	Y+4, r25	; 0x04
    2e46:	8b 83       	std	Y+3, r24	; 0x03
    2e48:	8b 81       	ldd	r24, Y+3	; 0x03
    2e4a:	9c 81       	ldd	r25, Y+4	; 0x04
    2e4c:	03 97       	sbiw	r24, 0x03	; 3
    2e4e:	58 f3       	brcs	.-42     	; 0x2e26 <lcd_init+0x28>
	    	for(j=0;j<1;j++);
	        	time--;
    2e50:	21 50       	subi	r18, 0x01	; 1
    2e52:	30 40       	sbci	r19, 0x00	; 0
}

void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    2e54:	29 f7       	brne	.-54     	; 0x2e20 <lcd_init+0x22>
	LCD_RSOFF();	
	LCD_RWOFF();

	lcd_delay(LCD_DELAY+500);
	
    lcd_command(LCD_SET_SYSTEM | LCD_SYS_4BIT | LCD_SYS_2LINE);
    2e56:	88 e2       	ldi	r24, 0x28	; 40
    2e58:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <lcd_command>
    lcd_command(LCD_SET_CUR_SHIFT | LCD_DISPLAY_SHIFT | LCD_SURSOR_SHIFT_RIGHT);
    2e5c:	8c e1       	ldi	r24, 0x1C	; 28
    2e5e:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <lcd_command>
    lcd_command(LCD_SET_DISPLAY | LCD_DISP_DISPLAY_ON);//| LCD_DISP_CURSOR_ON | LCD_DISP_CURSOR_FLASH);
    2e62:	8c e0       	ldi	r24, 0x0C	; 12
    2e64:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <lcd_command>
	lcd_command(0x01);   
    2e68:	81 e0       	ldi	r24, 0x01	; 1
    2e6a:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <lcd_command>
	lcd_command(LCD_CURSOR_HOME);
    2e6e:	82 e0       	ldi	r24, 0x02	; 2
    2e70:	0e 94 5f 16 	call	0x2cbe	; 0x2cbe <lcd_command>
    2e74:	28 e1       	ldi	r18, 0x18	; 24
    2e76:	30 e1       	ldi	r19, 0x10	; 16
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2e78:	1a 82       	std	Y+2, r1	; 0x02
    2e7a:	19 82       	std	Y+1, r1	; 0x01
    2e7c:	11 c0       	rjmp	.+34     	; 0x2ea0 <lcd_init+0xa2>
	    	for(j=0;j<1;j++);
    2e7e:	1c 82       	std	Y+4, r1	; 0x04
    2e80:	1b 82       	std	Y+3, r1	; 0x03
    2e82:	05 c0       	rjmp	.+10     	; 0x2e8e <lcd_init+0x90>
    2e84:	8b 81       	ldd	r24, Y+3	; 0x03
    2e86:	9c 81       	ldd	r25, Y+4	; 0x04
    2e88:	01 96       	adiw	r24, 0x01	; 1
    2e8a:	9c 83       	std	Y+4, r25	; 0x04
    2e8c:	8b 83       	std	Y+3, r24	; 0x03
    2e8e:	8b 81       	ldd	r24, Y+3	; 0x03
    2e90:	9c 81       	ldd	r25, Y+4	; 0x04
    2e92:	89 2b       	or	r24, r25
    2e94:	b9 f3       	breq	.-18     	; 0x2e84 <lcd_init+0x86>
void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    {
	    for(i=0;i<3;i++)
    2e96:	89 81       	ldd	r24, Y+1	; 0x01
    2e98:	9a 81       	ldd	r25, Y+2	; 0x02
    2e9a:	01 96       	adiw	r24, 0x01	; 1
    2e9c:	9a 83       	std	Y+2, r25	; 0x02
    2e9e:	89 83       	std	Y+1, r24	; 0x01
    2ea0:	89 81       	ldd	r24, Y+1	; 0x01
    2ea2:	9a 81       	ldd	r25, Y+2	; 0x02
    2ea4:	03 97       	sbiw	r24, 0x03	; 3
    2ea6:	58 f3       	brcs	.-42     	; 0x2e7e <lcd_init+0x80>
	    	for(j=0;j<1;j++);
	        	time--;
    2ea8:	21 50       	subi	r18, 0x01	; 1
    2eaa:	30 40       	sbci	r19, 0x00	; 0
}

void lcd_delay(unsigned int time)
{
    volatile unsigned int i, j;
    while(time)
    2eac:	29 f7       	brne	.-54     	; 0x2e78 <lcd_init+0x7a>
	lcd_command(0x01);   
	lcd_command(LCD_CURSOR_HOME);
	
	lcd_delay(LCD_DELAY+4000);
	
	lcd_clrscr();
    2eae:	0e 94 9c 16 	call	0x2d38	; 0x2d38 <lcd_clrscr>
	lcd_gotoxy(0,0);
    2eb2:	80 e0       	ldi	r24, 0x00	; 0
    2eb4:	60 e0       	ldi	r22, 0x00	; 0
    2eb6:	0e 94 e0 16 	call	0x2dc0	; 0x2dc0 <lcd_gotoxy>
	return 1;
}
    2eba:	81 e0       	ldi	r24, 0x01	; 1
    2ebc:	0f 90       	pop	r0
    2ebe:	0f 90       	pop	r0
    2ec0:	0f 90       	pop	r0
    2ec2:	0f 90       	pop	r0
    2ec4:	cf 91       	pop	r28
    2ec6:	df 91       	pop	r29
    2ec8:	08 95       	ret

00002eca <lcd_puts>:
 @return 	Character string's Pointer to be output 
*/
char * lcd_puts(
	char* str		/**< str - Character to be output in LCD. (INPUT) */
	)
{
    2eca:	ff 92       	push	r15
    2ecc:	0f 93       	push	r16
    2ece:	1f 93       	push	r17
    2ed0:	cf 93       	push	r28
    2ed2:	df 93       	push	r29
    2ed4:	ec 01       	movw	r28, r24
    2ed6:	ff 24       	eor	r15, r15
    2ed8:	07 c0       	rjmp	.+14     	; 0x2ee8 <lcd_puts+0x1e>
	unsigned char i;

	for (i=0; str[i] != '\0'; i++){
		lcd_ready();
    2eda:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <lcd_ready>
		lcd_data(str[i]);
    2ede:	f8 01       	movw	r30, r16
    2ee0:	80 81       	ld	r24, Z
    2ee2:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <lcd_data>
	char* str		/**< str - Character to be output in LCD. (INPUT) */
	)
{
	unsigned char i;

	for (i=0; str[i] != '\0'; i++){
    2ee6:	f3 94       	inc	r15
    2ee8:	8e 01       	movw	r16, r28
    2eea:	0f 0d       	add	r16, r15
    2eec:	11 1d       	adc	r17, r1
    2eee:	f8 01       	movw	r30, r16
    2ef0:	80 81       	ld	r24, Z
    2ef2:	88 23       	and	r24, r24
    2ef4:	91 f7       	brne	.-28     	; 0x2eda <lcd_puts+0x10>
		lcd_ready();
		lcd_data(str[i]);
	}
	return str;
}
    2ef6:	ce 01       	movw	r24, r28
    2ef8:	df 91       	pop	r29
    2efa:	cf 91       	pop	r28
    2efc:	1f 91       	pop	r17
    2efe:	0f 91       	pop	r16
    2f00:	ff 90       	pop	r15
    2f02:	08 95       	ret

00002f04 <lcd_putch>:
 @return 	Character string's Pointer to be output 
*/
void lcd_putch(
	char ch	/**< str - Character to be output in LCD. (INPUT) */
	)
{
    2f04:	1f 93       	push	r17
    2f06:	18 2f       	mov	r17, r24
	lcd_ready();
    2f08:	0e 94 fe 15 	call	0x2bfc	; 0x2bfc <lcd_ready>
	lcd_data(ch);
    2f0c:	81 2f       	mov	r24, r17
    2f0e:	0e 94 a3 16 	call	0x2d46	; 0x2d46 <lcd_data>
}
    2f12:	1f 91       	pop	r17
    2f14:	08 95       	ret

00002f16 <__fixunssfsi>:
    2f16:	ef 92       	push	r14
    2f18:	ff 92       	push	r15
    2f1a:	0f 93       	push	r16
    2f1c:	1f 93       	push	r17
    2f1e:	7b 01       	movw	r14, r22
    2f20:	8c 01       	movw	r16, r24
    2f22:	20 e0       	ldi	r18, 0x00	; 0
    2f24:	30 e0       	ldi	r19, 0x00	; 0
    2f26:	40 e0       	ldi	r20, 0x00	; 0
    2f28:	5f e4       	ldi	r21, 0x4F	; 79
    2f2a:	0e 94 37 1b 	call	0x366e	; 0x366e <__gesf2>
    2f2e:	88 23       	and	r24, r24
    2f30:	8c f0       	brlt	.+34     	; 0x2f54 <__fixunssfsi+0x3e>
    2f32:	c8 01       	movw	r24, r16
    2f34:	b7 01       	movw	r22, r14
    2f36:	20 e0       	ldi	r18, 0x00	; 0
    2f38:	30 e0       	ldi	r19, 0x00	; 0
    2f3a:	40 e0       	ldi	r20, 0x00	; 0
    2f3c:	5f e4       	ldi	r21, 0x4F	; 79
    2f3e:	0e 94 03 19 	call	0x3206	; 0x3206 <__subsf3>
    2f42:	0e 94 97 1b 	call	0x372e	; 0x372e <__fixsfsi>
    2f46:	9b 01       	movw	r18, r22
    2f48:	ac 01       	movw	r20, r24
    2f4a:	20 50       	subi	r18, 0x00	; 0
    2f4c:	30 40       	sbci	r19, 0x00	; 0
    2f4e:	40 40       	sbci	r20, 0x00	; 0
    2f50:	50 48       	sbci	r21, 0x80	; 128
    2f52:	06 c0       	rjmp	.+12     	; 0x2f60 <__fixunssfsi+0x4a>
    2f54:	c8 01       	movw	r24, r16
    2f56:	b7 01       	movw	r22, r14
    2f58:	0e 94 97 1b 	call	0x372e	; 0x372e <__fixsfsi>
    2f5c:	9b 01       	movw	r18, r22
    2f5e:	ac 01       	movw	r20, r24
    2f60:	b9 01       	movw	r22, r18
    2f62:	ca 01       	movw	r24, r20
    2f64:	1f 91       	pop	r17
    2f66:	0f 91       	pop	r16
    2f68:	ff 90       	pop	r15
    2f6a:	ef 90       	pop	r14
    2f6c:	08 95       	ret

00002f6e <_fpadd_parts>:
    2f6e:	a0 e0       	ldi	r26, 0x00	; 0
    2f70:	b0 e0       	ldi	r27, 0x00	; 0
    2f72:	ed eb       	ldi	r30, 0xBD	; 189
    2f74:	f7 e1       	ldi	r31, 0x17	; 23
    2f76:	0c 94 c5 22 	jmp	0x458a	; 0x458a <__prologue_saves__>
    2f7a:	dc 01       	movw	r26, r24
    2f7c:	2b 01       	movw	r4, r22
    2f7e:	fa 01       	movw	r30, r20
    2f80:	9c 91       	ld	r25, X
    2f82:	92 30       	cpi	r25, 0x02	; 2
    2f84:	08 f4       	brcc	.+2      	; 0x2f88 <_fpadd_parts+0x1a>
    2f86:	39 c1       	rjmp	.+626    	; 0x31fa <_fpadd_parts+0x28c>
    2f88:	eb 01       	movw	r28, r22
    2f8a:	88 81       	ld	r24, Y
    2f8c:	82 30       	cpi	r24, 0x02	; 2
    2f8e:	08 f4       	brcc	.+2      	; 0x2f92 <_fpadd_parts+0x24>
    2f90:	33 c1       	rjmp	.+614    	; 0x31f8 <_fpadd_parts+0x28a>
    2f92:	94 30       	cpi	r25, 0x04	; 4
    2f94:	69 f4       	brne	.+26     	; 0x2fb0 <_fpadd_parts+0x42>
    2f96:	84 30       	cpi	r24, 0x04	; 4
    2f98:	09 f0       	breq	.+2      	; 0x2f9c <_fpadd_parts+0x2e>
    2f9a:	2f c1       	rjmp	.+606    	; 0x31fa <_fpadd_parts+0x28c>
    2f9c:	11 96       	adiw	r26, 0x01	; 1
    2f9e:	9c 91       	ld	r25, X
    2fa0:	11 97       	sbiw	r26, 0x01	; 1
    2fa2:	89 81       	ldd	r24, Y+1	; 0x01
    2fa4:	98 17       	cp	r25, r24
    2fa6:	09 f4       	brne	.+2      	; 0x2faa <_fpadd_parts+0x3c>
    2fa8:	28 c1       	rjmp	.+592    	; 0x31fa <_fpadd_parts+0x28c>
    2faa:	a9 e4       	ldi	r26, 0x49	; 73
    2fac:	b4 e0       	ldi	r27, 0x04	; 4
    2fae:	25 c1       	rjmp	.+586    	; 0x31fa <_fpadd_parts+0x28c>
    2fb0:	84 30       	cpi	r24, 0x04	; 4
    2fb2:	09 f4       	brne	.+2      	; 0x2fb6 <_fpadd_parts+0x48>
    2fb4:	21 c1       	rjmp	.+578    	; 0x31f8 <_fpadd_parts+0x28a>
    2fb6:	82 30       	cpi	r24, 0x02	; 2
    2fb8:	a9 f4       	brne	.+42     	; 0x2fe4 <_fpadd_parts+0x76>
    2fba:	92 30       	cpi	r25, 0x02	; 2
    2fbc:	09 f0       	breq	.+2      	; 0x2fc0 <_fpadd_parts+0x52>
    2fbe:	1d c1       	rjmp	.+570    	; 0x31fa <_fpadd_parts+0x28c>
    2fc0:	9a 01       	movw	r18, r20
    2fc2:	ad 01       	movw	r20, r26
    2fc4:	88 e0       	ldi	r24, 0x08	; 8
    2fc6:	ea 01       	movw	r28, r20
    2fc8:	09 90       	ld	r0, Y+
    2fca:	ae 01       	movw	r20, r28
    2fcc:	e9 01       	movw	r28, r18
    2fce:	09 92       	st	Y+, r0
    2fd0:	9e 01       	movw	r18, r28
    2fd2:	81 50       	subi	r24, 0x01	; 1
    2fd4:	c1 f7       	brne	.-16     	; 0x2fc6 <_fpadd_parts+0x58>
    2fd6:	e2 01       	movw	r28, r4
    2fd8:	89 81       	ldd	r24, Y+1	; 0x01
    2fda:	11 96       	adiw	r26, 0x01	; 1
    2fdc:	9c 91       	ld	r25, X
    2fde:	89 23       	and	r24, r25
    2fe0:	81 83       	std	Z+1, r24	; 0x01
    2fe2:	08 c1       	rjmp	.+528    	; 0x31f4 <_fpadd_parts+0x286>
    2fe4:	92 30       	cpi	r25, 0x02	; 2
    2fe6:	09 f4       	brne	.+2      	; 0x2fea <_fpadd_parts+0x7c>
    2fe8:	07 c1       	rjmp	.+526    	; 0x31f8 <_fpadd_parts+0x28a>
    2fea:	12 96       	adiw	r26, 0x02	; 2
    2fec:	2d 90       	ld	r2, X+
    2fee:	3c 90       	ld	r3, X
    2ff0:	13 97       	sbiw	r26, 0x03	; 3
    2ff2:	eb 01       	movw	r28, r22
    2ff4:	8a 81       	ldd	r24, Y+2	; 0x02
    2ff6:	9b 81       	ldd	r25, Y+3	; 0x03
    2ff8:	14 96       	adiw	r26, 0x04	; 4
    2ffa:	ad 90       	ld	r10, X+
    2ffc:	bd 90       	ld	r11, X+
    2ffe:	cd 90       	ld	r12, X+
    3000:	dc 90       	ld	r13, X
    3002:	17 97       	sbiw	r26, 0x07	; 7
    3004:	ec 80       	ldd	r14, Y+4	; 0x04
    3006:	fd 80       	ldd	r15, Y+5	; 0x05
    3008:	0e 81       	ldd	r16, Y+6	; 0x06
    300a:	1f 81       	ldd	r17, Y+7	; 0x07
    300c:	91 01       	movw	r18, r2
    300e:	28 1b       	sub	r18, r24
    3010:	39 0b       	sbc	r19, r25
    3012:	b9 01       	movw	r22, r18
    3014:	37 ff       	sbrs	r19, 7
    3016:	04 c0       	rjmp	.+8      	; 0x3020 <_fpadd_parts+0xb2>
    3018:	66 27       	eor	r22, r22
    301a:	77 27       	eor	r23, r23
    301c:	62 1b       	sub	r22, r18
    301e:	73 0b       	sbc	r23, r19
    3020:	60 32       	cpi	r22, 0x20	; 32
    3022:	71 05       	cpc	r23, r1
    3024:	0c f0       	brlt	.+2      	; 0x3028 <_fpadd_parts+0xba>
    3026:	61 c0       	rjmp	.+194    	; 0x30ea <_fpadd_parts+0x17c>
    3028:	12 16       	cp	r1, r18
    302a:	13 06       	cpc	r1, r19
    302c:	6c f5       	brge	.+90     	; 0x3088 <_fpadd_parts+0x11a>
    302e:	37 01       	movw	r6, r14
    3030:	48 01       	movw	r8, r16
    3032:	06 2e       	mov	r0, r22
    3034:	04 c0       	rjmp	.+8      	; 0x303e <_fpadd_parts+0xd0>
    3036:	96 94       	lsr	r9
    3038:	87 94       	ror	r8
    303a:	77 94       	ror	r7
    303c:	67 94       	ror	r6
    303e:	0a 94       	dec	r0
    3040:	d2 f7       	brpl	.-12     	; 0x3036 <_fpadd_parts+0xc8>
    3042:	21 e0       	ldi	r18, 0x01	; 1
    3044:	30 e0       	ldi	r19, 0x00	; 0
    3046:	40 e0       	ldi	r20, 0x00	; 0
    3048:	50 e0       	ldi	r21, 0x00	; 0
    304a:	04 c0       	rjmp	.+8      	; 0x3054 <_fpadd_parts+0xe6>
    304c:	22 0f       	add	r18, r18
    304e:	33 1f       	adc	r19, r19
    3050:	44 1f       	adc	r20, r20
    3052:	55 1f       	adc	r21, r21
    3054:	6a 95       	dec	r22
    3056:	d2 f7       	brpl	.-12     	; 0x304c <_fpadd_parts+0xde>
    3058:	21 50       	subi	r18, 0x01	; 1
    305a:	30 40       	sbci	r19, 0x00	; 0
    305c:	40 40       	sbci	r20, 0x00	; 0
    305e:	50 40       	sbci	r21, 0x00	; 0
    3060:	2e 21       	and	r18, r14
    3062:	3f 21       	and	r19, r15
    3064:	40 23       	and	r20, r16
    3066:	51 23       	and	r21, r17
    3068:	21 15       	cp	r18, r1
    306a:	31 05       	cpc	r19, r1
    306c:	41 05       	cpc	r20, r1
    306e:	51 05       	cpc	r21, r1
    3070:	21 f0       	breq	.+8      	; 0x307a <_fpadd_parts+0x10c>
    3072:	21 e0       	ldi	r18, 0x01	; 1
    3074:	30 e0       	ldi	r19, 0x00	; 0
    3076:	40 e0       	ldi	r20, 0x00	; 0
    3078:	50 e0       	ldi	r21, 0x00	; 0
    307a:	79 01       	movw	r14, r18
    307c:	8a 01       	movw	r16, r20
    307e:	e6 28       	or	r14, r6
    3080:	f7 28       	or	r15, r7
    3082:	08 29       	or	r16, r8
    3084:	19 29       	or	r17, r9
    3086:	3c c0       	rjmp	.+120    	; 0x3100 <_fpadd_parts+0x192>
    3088:	23 2b       	or	r18, r19
    308a:	d1 f1       	breq	.+116    	; 0x3100 <_fpadd_parts+0x192>
    308c:	26 0e       	add	r2, r22
    308e:	37 1e       	adc	r3, r23
    3090:	35 01       	movw	r6, r10
    3092:	46 01       	movw	r8, r12
    3094:	06 2e       	mov	r0, r22
    3096:	04 c0       	rjmp	.+8      	; 0x30a0 <_fpadd_parts+0x132>
    3098:	96 94       	lsr	r9
    309a:	87 94       	ror	r8
    309c:	77 94       	ror	r7
    309e:	67 94       	ror	r6
    30a0:	0a 94       	dec	r0
    30a2:	d2 f7       	brpl	.-12     	; 0x3098 <_fpadd_parts+0x12a>
    30a4:	21 e0       	ldi	r18, 0x01	; 1
    30a6:	30 e0       	ldi	r19, 0x00	; 0
    30a8:	40 e0       	ldi	r20, 0x00	; 0
    30aa:	50 e0       	ldi	r21, 0x00	; 0
    30ac:	04 c0       	rjmp	.+8      	; 0x30b6 <_fpadd_parts+0x148>
    30ae:	22 0f       	add	r18, r18
    30b0:	33 1f       	adc	r19, r19
    30b2:	44 1f       	adc	r20, r20
    30b4:	55 1f       	adc	r21, r21
    30b6:	6a 95       	dec	r22
    30b8:	d2 f7       	brpl	.-12     	; 0x30ae <_fpadd_parts+0x140>
    30ba:	21 50       	subi	r18, 0x01	; 1
    30bc:	30 40       	sbci	r19, 0x00	; 0
    30be:	40 40       	sbci	r20, 0x00	; 0
    30c0:	50 40       	sbci	r21, 0x00	; 0
    30c2:	2a 21       	and	r18, r10
    30c4:	3b 21       	and	r19, r11
    30c6:	4c 21       	and	r20, r12
    30c8:	5d 21       	and	r21, r13
    30ca:	21 15       	cp	r18, r1
    30cc:	31 05       	cpc	r19, r1
    30ce:	41 05       	cpc	r20, r1
    30d0:	51 05       	cpc	r21, r1
    30d2:	21 f0       	breq	.+8      	; 0x30dc <_fpadd_parts+0x16e>
    30d4:	21 e0       	ldi	r18, 0x01	; 1
    30d6:	30 e0       	ldi	r19, 0x00	; 0
    30d8:	40 e0       	ldi	r20, 0x00	; 0
    30da:	50 e0       	ldi	r21, 0x00	; 0
    30dc:	59 01       	movw	r10, r18
    30de:	6a 01       	movw	r12, r20
    30e0:	a6 28       	or	r10, r6
    30e2:	b7 28       	or	r11, r7
    30e4:	c8 28       	or	r12, r8
    30e6:	d9 28       	or	r13, r9
    30e8:	0b c0       	rjmp	.+22     	; 0x3100 <_fpadd_parts+0x192>
    30ea:	82 15       	cp	r24, r2
    30ec:	93 05       	cpc	r25, r3
    30ee:	2c f0       	brlt	.+10     	; 0x30fa <_fpadd_parts+0x18c>
    30f0:	1c 01       	movw	r2, r24
    30f2:	aa 24       	eor	r10, r10
    30f4:	bb 24       	eor	r11, r11
    30f6:	65 01       	movw	r12, r10
    30f8:	03 c0       	rjmp	.+6      	; 0x3100 <_fpadd_parts+0x192>
    30fa:	ee 24       	eor	r14, r14
    30fc:	ff 24       	eor	r15, r15
    30fe:	87 01       	movw	r16, r14
    3100:	11 96       	adiw	r26, 0x01	; 1
    3102:	9c 91       	ld	r25, X
    3104:	d2 01       	movw	r26, r4
    3106:	11 96       	adiw	r26, 0x01	; 1
    3108:	8c 91       	ld	r24, X
    310a:	98 17       	cp	r25, r24
    310c:	09 f4       	brne	.+2      	; 0x3110 <_fpadd_parts+0x1a2>
    310e:	45 c0       	rjmp	.+138    	; 0x319a <_fpadd_parts+0x22c>
    3110:	99 23       	and	r25, r25
    3112:	39 f0       	breq	.+14     	; 0x3122 <_fpadd_parts+0x1b4>
    3114:	a8 01       	movw	r20, r16
    3116:	97 01       	movw	r18, r14
    3118:	2a 19       	sub	r18, r10
    311a:	3b 09       	sbc	r19, r11
    311c:	4c 09       	sbc	r20, r12
    311e:	5d 09       	sbc	r21, r13
    3120:	06 c0       	rjmp	.+12     	; 0x312e <_fpadd_parts+0x1c0>
    3122:	a6 01       	movw	r20, r12
    3124:	95 01       	movw	r18, r10
    3126:	2e 19       	sub	r18, r14
    3128:	3f 09       	sbc	r19, r15
    312a:	40 0b       	sbc	r20, r16
    312c:	51 0b       	sbc	r21, r17
    312e:	57 fd       	sbrc	r21, 7
    3130:	08 c0       	rjmp	.+16     	; 0x3142 <_fpadd_parts+0x1d4>
    3132:	11 82       	std	Z+1, r1	; 0x01
    3134:	33 82       	std	Z+3, r3	; 0x03
    3136:	22 82       	std	Z+2, r2	; 0x02
    3138:	24 83       	std	Z+4, r18	; 0x04
    313a:	35 83       	std	Z+5, r19	; 0x05
    313c:	46 83       	std	Z+6, r20	; 0x06
    313e:	57 83       	std	Z+7, r21	; 0x07
    3140:	1d c0       	rjmp	.+58     	; 0x317c <_fpadd_parts+0x20e>
    3142:	81 e0       	ldi	r24, 0x01	; 1
    3144:	81 83       	std	Z+1, r24	; 0x01
    3146:	33 82       	std	Z+3, r3	; 0x03
    3148:	22 82       	std	Z+2, r2	; 0x02
    314a:	88 27       	eor	r24, r24
    314c:	99 27       	eor	r25, r25
    314e:	dc 01       	movw	r26, r24
    3150:	82 1b       	sub	r24, r18
    3152:	93 0b       	sbc	r25, r19
    3154:	a4 0b       	sbc	r26, r20
    3156:	b5 0b       	sbc	r27, r21
    3158:	84 83       	std	Z+4, r24	; 0x04
    315a:	95 83       	std	Z+5, r25	; 0x05
    315c:	a6 83       	std	Z+6, r26	; 0x06
    315e:	b7 83       	std	Z+7, r27	; 0x07
    3160:	0d c0       	rjmp	.+26     	; 0x317c <_fpadd_parts+0x20e>
    3162:	22 0f       	add	r18, r18
    3164:	33 1f       	adc	r19, r19
    3166:	44 1f       	adc	r20, r20
    3168:	55 1f       	adc	r21, r21
    316a:	24 83       	std	Z+4, r18	; 0x04
    316c:	35 83       	std	Z+5, r19	; 0x05
    316e:	46 83       	std	Z+6, r20	; 0x06
    3170:	57 83       	std	Z+7, r21	; 0x07
    3172:	82 81       	ldd	r24, Z+2	; 0x02
    3174:	93 81       	ldd	r25, Z+3	; 0x03
    3176:	01 97       	sbiw	r24, 0x01	; 1
    3178:	93 83       	std	Z+3, r25	; 0x03
    317a:	82 83       	std	Z+2, r24	; 0x02
    317c:	24 81       	ldd	r18, Z+4	; 0x04
    317e:	35 81       	ldd	r19, Z+5	; 0x05
    3180:	46 81       	ldd	r20, Z+6	; 0x06
    3182:	57 81       	ldd	r21, Z+7	; 0x07
    3184:	da 01       	movw	r26, r20
    3186:	c9 01       	movw	r24, r18
    3188:	01 97       	sbiw	r24, 0x01	; 1
    318a:	a1 09       	sbc	r26, r1
    318c:	b1 09       	sbc	r27, r1
    318e:	8f 5f       	subi	r24, 0xFF	; 255
    3190:	9f 4f       	sbci	r25, 0xFF	; 255
    3192:	af 4f       	sbci	r26, 0xFF	; 255
    3194:	bf 43       	sbci	r27, 0x3F	; 63
    3196:	28 f3       	brcs	.-54     	; 0x3162 <_fpadd_parts+0x1f4>
    3198:	0b c0       	rjmp	.+22     	; 0x31b0 <_fpadd_parts+0x242>
    319a:	91 83       	std	Z+1, r25	; 0x01
    319c:	33 82       	std	Z+3, r3	; 0x03
    319e:	22 82       	std	Z+2, r2	; 0x02
    31a0:	ea 0c       	add	r14, r10
    31a2:	fb 1c       	adc	r15, r11
    31a4:	0c 1d       	adc	r16, r12
    31a6:	1d 1d       	adc	r17, r13
    31a8:	e4 82       	std	Z+4, r14	; 0x04
    31aa:	f5 82       	std	Z+5, r15	; 0x05
    31ac:	06 83       	std	Z+6, r16	; 0x06
    31ae:	17 83       	std	Z+7, r17	; 0x07
    31b0:	83 e0       	ldi	r24, 0x03	; 3
    31b2:	80 83       	st	Z, r24
    31b4:	24 81       	ldd	r18, Z+4	; 0x04
    31b6:	35 81       	ldd	r19, Z+5	; 0x05
    31b8:	46 81       	ldd	r20, Z+6	; 0x06
    31ba:	57 81       	ldd	r21, Z+7	; 0x07
    31bc:	57 ff       	sbrs	r21, 7
    31be:	1a c0       	rjmp	.+52     	; 0x31f4 <_fpadd_parts+0x286>
    31c0:	c9 01       	movw	r24, r18
    31c2:	aa 27       	eor	r26, r26
    31c4:	97 fd       	sbrc	r25, 7
    31c6:	a0 95       	com	r26
    31c8:	ba 2f       	mov	r27, r26
    31ca:	81 70       	andi	r24, 0x01	; 1
    31cc:	90 70       	andi	r25, 0x00	; 0
    31ce:	a0 70       	andi	r26, 0x00	; 0
    31d0:	b0 70       	andi	r27, 0x00	; 0
    31d2:	56 95       	lsr	r21
    31d4:	47 95       	ror	r20
    31d6:	37 95       	ror	r19
    31d8:	27 95       	ror	r18
    31da:	82 2b       	or	r24, r18
    31dc:	93 2b       	or	r25, r19
    31de:	a4 2b       	or	r26, r20
    31e0:	b5 2b       	or	r27, r21
    31e2:	84 83       	std	Z+4, r24	; 0x04
    31e4:	95 83       	std	Z+5, r25	; 0x05
    31e6:	a6 83       	std	Z+6, r26	; 0x06
    31e8:	b7 83       	std	Z+7, r27	; 0x07
    31ea:	82 81       	ldd	r24, Z+2	; 0x02
    31ec:	93 81       	ldd	r25, Z+3	; 0x03
    31ee:	01 96       	adiw	r24, 0x01	; 1
    31f0:	93 83       	std	Z+3, r25	; 0x03
    31f2:	82 83       	std	Z+2, r24	; 0x02
    31f4:	df 01       	movw	r26, r30
    31f6:	01 c0       	rjmp	.+2      	; 0x31fa <_fpadd_parts+0x28c>
    31f8:	d2 01       	movw	r26, r4
    31fa:	cd 01       	movw	r24, r26
    31fc:	cd b7       	in	r28, 0x3d	; 61
    31fe:	de b7       	in	r29, 0x3e	; 62
    3200:	e2 e1       	ldi	r30, 0x12	; 18
    3202:	0c 94 e1 22 	jmp	0x45c2	; 0x45c2 <__epilogue_restores__>

00003206 <__subsf3>:
    3206:	a0 e2       	ldi	r26, 0x20	; 32
    3208:	b0 e0       	ldi	r27, 0x00	; 0
    320a:	e9 e0       	ldi	r30, 0x09	; 9
    320c:	f9 e1       	ldi	r31, 0x19	; 25
    320e:	0c 94 d1 22 	jmp	0x45a2	; 0x45a2 <__prologue_saves__+0x18>
    3212:	69 83       	std	Y+1, r22	; 0x01
    3214:	7a 83       	std	Y+2, r23	; 0x02
    3216:	8b 83       	std	Y+3, r24	; 0x03
    3218:	9c 83       	std	Y+4, r25	; 0x04
    321a:	2d 83       	std	Y+5, r18	; 0x05
    321c:	3e 83       	std	Y+6, r19	; 0x06
    321e:	4f 83       	std	Y+7, r20	; 0x07
    3220:	58 87       	std	Y+8, r21	; 0x08
    3222:	e9 e0       	ldi	r30, 0x09	; 9
    3224:	ee 2e       	mov	r14, r30
    3226:	f1 2c       	mov	r15, r1
    3228:	ec 0e       	add	r14, r28
    322a:	fd 1e       	adc	r15, r29
    322c:	ce 01       	movw	r24, r28
    322e:	01 96       	adiw	r24, 0x01	; 1
    3230:	b7 01       	movw	r22, r14
    3232:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    3236:	8e 01       	movw	r16, r28
    3238:	0f 5e       	subi	r16, 0xEF	; 239
    323a:	1f 4f       	sbci	r17, 0xFF	; 255
    323c:	ce 01       	movw	r24, r28
    323e:	05 96       	adiw	r24, 0x05	; 5
    3240:	b8 01       	movw	r22, r16
    3242:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    3246:	8a 89       	ldd	r24, Y+18	; 0x12
    3248:	91 e0       	ldi	r25, 0x01	; 1
    324a:	89 27       	eor	r24, r25
    324c:	8a 8b       	std	Y+18, r24	; 0x12
    324e:	c7 01       	movw	r24, r14
    3250:	b8 01       	movw	r22, r16
    3252:	ae 01       	movw	r20, r28
    3254:	47 5e       	subi	r20, 0xE7	; 231
    3256:	5f 4f       	sbci	r21, 0xFF	; 255
    3258:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <_fpadd_parts>
    325c:	0e 94 b3 1c 	call	0x3966	; 0x3966 <__pack_f>
    3260:	a0 96       	adiw	r28, 0x20	; 32
    3262:	e6 e0       	ldi	r30, 0x06	; 6
    3264:	0c 94 ed 22 	jmp	0x45da	; 0x45da <__epilogue_restores__+0x18>

00003268 <__addsf3>:
    3268:	a0 e2       	ldi	r26, 0x20	; 32
    326a:	b0 e0       	ldi	r27, 0x00	; 0
    326c:	ea e3       	ldi	r30, 0x3A	; 58
    326e:	f9 e1       	ldi	r31, 0x19	; 25
    3270:	0c 94 d1 22 	jmp	0x45a2	; 0x45a2 <__prologue_saves__+0x18>
    3274:	69 83       	std	Y+1, r22	; 0x01
    3276:	7a 83       	std	Y+2, r23	; 0x02
    3278:	8b 83       	std	Y+3, r24	; 0x03
    327a:	9c 83       	std	Y+4, r25	; 0x04
    327c:	2d 83       	std	Y+5, r18	; 0x05
    327e:	3e 83       	std	Y+6, r19	; 0x06
    3280:	4f 83       	std	Y+7, r20	; 0x07
    3282:	58 87       	std	Y+8, r21	; 0x08
    3284:	f9 e0       	ldi	r31, 0x09	; 9
    3286:	ef 2e       	mov	r14, r31
    3288:	f1 2c       	mov	r15, r1
    328a:	ec 0e       	add	r14, r28
    328c:	fd 1e       	adc	r15, r29
    328e:	ce 01       	movw	r24, r28
    3290:	01 96       	adiw	r24, 0x01	; 1
    3292:	b7 01       	movw	r22, r14
    3294:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    3298:	8e 01       	movw	r16, r28
    329a:	0f 5e       	subi	r16, 0xEF	; 239
    329c:	1f 4f       	sbci	r17, 0xFF	; 255
    329e:	ce 01       	movw	r24, r28
    32a0:	05 96       	adiw	r24, 0x05	; 5
    32a2:	b8 01       	movw	r22, r16
    32a4:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    32a8:	c7 01       	movw	r24, r14
    32aa:	b8 01       	movw	r22, r16
    32ac:	ae 01       	movw	r20, r28
    32ae:	47 5e       	subi	r20, 0xE7	; 231
    32b0:	5f 4f       	sbci	r21, 0xFF	; 255
    32b2:	0e 94 b7 17 	call	0x2f6e	; 0x2f6e <_fpadd_parts>
    32b6:	0e 94 b3 1c 	call	0x3966	; 0x3966 <__pack_f>
    32ba:	a0 96       	adiw	r28, 0x20	; 32
    32bc:	e6 e0       	ldi	r30, 0x06	; 6
    32be:	0c 94 ed 22 	jmp	0x45da	; 0x45da <__epilogue_restores__+0x18>

000032c2 <__mulsf3>:
    32c2:	a0 e2       	ldi	r26, 0x20	; 32
    32c4:	b0 e0       	ldi	r27, 0x00	; 0
    32c6:	e7 e6       	ldi	r30, 0x67	; 103
    32c8:	f9 e1       	ldi	r31, 0x19	; 25
    32ca:	0c 94 c5 22 	jmp	0x458a	; 0x458a <__prologue_saves__>
    32ce:	69 83       	std	Y+1, r22	; 0x01
    32d0:	7a 83       	std	Y+2, r23	; 0x02
    32d2:	8b 83       	std	Y+3, r24	; 0x03
    32d4:	9c 83       	std	Y+4, r25	; 0x04
    32d6:	2d 83       	std	Y+5, r18	; 0x05
    32d8:	3e 83       	std	Y+6, r19	; 0x06
    32da:	4f 83       	std	Y+7, r20	; 0x07
    32dc:	58 87       	std	Y+8, r21	; 0x08
    32de:	ce 01       	movw	r24, r28
    32e0:	01 96       	adiw	r24, 0x01	; 1
    32e2:	be 01       	movw	r22, r28
    32e4:	67 5f       	subi	r22, 0xF7	; 247
    32e6:	7f 4f       	sbci	r23, 0xFF	; 255
    32e8:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    32ec:	ce 01       	movw	r24, r28
    32ee:	05 96       	adiw	r24, 0x05	; 5
    32f0:	be 01       	movw	r22, r28
    32f2:	6f 5e       	subi	r22, 0xEF	; 239
    32f4:	7f 4f       	sbci	r23, 0xFF	; 255
    32f6:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    32fa:	99 85       	ldd	r25, Y+9	; 0x09
    32fc:	92 30       	cpi	r25, 0x02	; 2
    32fe:	88 f0       	brcs	.+34     	; 0x3322 <__mulsf3+0x60>
    3300:	89 89       	ldd	r24, Y+17	; 0x11
    3302:	82 30       	cpi	r24, 0x02	; 2
    3304:	c8 f0       	brcs	.+50     	; 0x3338 <__mulsf3+0x76>
    3306:	94 30       	cpi	r25, 0x04	; 4
    3308:	19 f4       	brne	.+6      	; 0x3310 <__mulsf3+0x4e>
    330a:	82 30       	cpi	r24, 0x02	; 2
    330c:	51 f4       	brne	.+20     	; 0x3322 <__mulsf3+0x60>
    330e:	04 c0       	rjmp	.+8      	; 0x3318 <__mulsf3+0x56>
    3310:	84 30       	cpi	r24, 0x04	; 4
    3312:	29 f4       	brne	.+10     	; 0x331e <__mulsf3+0x5c>
    3314:	92 30       	cpi	r25, 0x02	; 2
    3316:	81 f4       	brne	.+32     	; 0x3338 <__mulsf3+0x76>
    3318:	89 e4       	ldi	r24, 0x49	; 73
    331a:	94 e0       	ldi	r25, 0x04	; 4
    331c:	c6 c0       	rjmp	.+396    	; 0x34aa <__mulsf3+0x1e8>
    331e:	92 30       	cpi	r25, 0x02	; 2
    3320:	49 f4       	brne	.+18     	; 0x3334 <__mulsf3+0x72>
    3322:	20 e0       	ldi	r18, 0x00	; 0
    3324:	9a 85       	ldd	r25, Y+10	; 0x0a
    3326:	8a 89       	ldd	r24, Y+18	; 0x12
    3328:	98 13       	cpse	r25, r24
    332a:	21 e0       	ldi	r18, 0x01	; 1
    332c:	2a 87       	std	Y+10, r18	; 0x0a
    332e:	ce 01       	movw	r24, r28
    3330:	09 96       	adiw	r24, 0x09	; 9
    3332:	bb c0       	rjmp	.+374    	; 0x34aa <__mulsf3+0x1e8>
    3334:	82 30       	cpi	r24, 0x02	; 2
    3336:	49 f4       	brne	.+18     	; 0x334a <__mulsf3+0x88>
    3338:	20 e0       	ldi	r18, 0x00	; 0
    333a:	9a 85       	ldd	r25, Y+10	; 0x0a
    333c:	8a 89       	ldd	r24, Y+18	; 0x12
    333e:	98 13       	cpse	r25, r24
    3340:	21 e0       	ldi	r18, 0x01	; 1
    3342:	2a 8b       	std	Y+18, r18	; 0x12
    3344:	ce 01       	movw	r24, r28
    3346:	41 96       	adiw	r24, 0x11	; 17
    3348:	b0 c0       	rjmp	.+352    	; 0x34aa <__mulsf3+0x1e8>
    334a:	2d 84       	ldd	r2, Y+13	; 0x0d
    334c:	3e 84       	ldd	r3, Y+14	; 0x0e
    334e:	4f 84       	ldd	r4, Y+15	; 0x0f
    3350:	58 88       	ldd	r5, Y+16	; 0x10
    3352:	6d 88       	ldd	r6, Y+21	; 0x15
    3354:	7e 88       	ldd	r7, Y+22	; 0x16
    3356:	8f 88       	ldd	r8, Y+23	; 0x17
    3358:	98 8c       	ldd	r9, Y+24	; 0x18
    335a:	ee 24       	eor	r14, r14
    335c:	ff 24       	eor	r15, r15
    335e:	87 01       	movw	r16, r14
    3360:	aa 24       	eor	r10, r10
    3362:	bb 24       	eor	r11, r11
    3364:	65 01       	movw	r12, r10
    3366:	40 e0       	ldi	r20, 0x00	; 0
    3368:	50 e0       	ldi	r21, 0x00	; 0
    336a:	60 e0       	ldi	r22, 0x00	; 0
    336c:	70 e0       	ldi	r23, 0x00	; 0
    336e:	e0 e0       	ldi	r30, 0x00	; 0
    3370:	f0 e0       	ldi	r31, 0x00	; 0
    3372:	c1 01       	movw	r24, r2
    3374:	81 70       	andi	r24, 0x01	; 1
    3376:	90 70       	andi	r25, 0x00	; 0
    3378:	89 2b       	or	r24, r25
    337a:	e9 f0       	breq	.+58     	; 0x33b6 <__mulsf3+0xf4>
    337c:	e6 0c       	add	r14, r6
    337e:	f7 1c       	adc	r15, r7
    3380:	08 1d       	adc	r16, r8
    3382:	19 1d       	adc	r17, r9
    3384:	9a 01       	movw	r18, r20
    3386:	ab 01       	movw	r20, r22
    3388:	2a 0d       	add	r18, r10
    338a:	3b 1d       	adc	r19, r11
    338c:	4c 1d       	adc	r20, r12
    338e:	5d 1d       	adc	r21, r13
    3390:	80 e0       	ldi	r24, 0x00	; 0
    3392:	90 e0       	ldi	r25, 0x00	; 0
    3394:	a0 e0       	ldi	r26, 0x00	; 0
    3396:	b0 e0       	ldi	r27, 0x00	; 0
    3398:	e6 14       	cp	r14, r6
    339a:	f7 04       	cpc	r15, r7
    339c:	08 05       	cpc	r16, r8
    339e:	19 05       	cpc	r17, r9
    33a0:	20 f4       	brcc	.+8      	; 0x33aa <__mulsf3+0xe8>
    33a2:	81 e0       	ldi	r24, 0x01	; 1
    33a4:	90 e0       	ldi	r25, 0x00	; 0
    33a6:	a0 e0       	ldi	r26, 0x00	; 0
    33a8:	b0 e0       	ldi	r27, 0x00	; 0
    33aa:	ba 01       	movw	r22, r20
    33ac:	a9 01       	movw	r20, r18
    33ae:	48 0f       	add	r20, r24
    33b0:	59 1f       	adc	r21, r25
    33b2:	6a 1f       	adc	r22, r26
    33b4:	7b 1f       	adc	r23, r27
    33b6:	aa 0c       	add	r10, r10
    33b8:	bb 1c       	adc	r11, r11
    33ba:	cc 1c       	adc	r12, r12
    33bc:	dd 1c       	adc	r13, r13
    33be:	97 fe       	sbrs	r9, 7
    33c0:	08 c0       	rjmp	.+16     	; 0x33d2 <__mulsf3+0x110>
    33c2:	81 e0       	ldi	r24, 0x01	; 1
    33c4:	90 e0       	ldi	r25, 0x00	; 0
    33c6:	a0 e0       	ldi	r26, 0x00	; 0
    33c8:	b0 e0       	ldi	r27, 0x00	; 0
    33ca:	a8 2a       	or	r10, r24
    33cc:	b9 2a       	or	r11, r25
    33ce:	ca 2a       	or	r12, r26
    33d0:	db 2a       	or	r13, r27
    33d2:	31 96       	adiw	r30, 0x01	; 1
    33d4:	e0 32       	cpi	r30, 0x20	; 32
    33d6:	f1 05       	cpc	r31, r1
    33d8:	49 f0       	breq	.+18     	; 0x33ec <__mulsf3+0x12a>
    33da:	66 0c       	add	r6, r6
    33dc:	77 1c       	adc	r7, r7
    33de:	88 1c       	adc	r8, r8
    33e0:	99 1c       	adc	r9, r9
    33e2:	56 94       	lsr	r5
    33e4:	47 94       	ror	r4
    33e6:	37 94       	ror	r3
    33e8:	27 94       	ror	r2
    33ea:	c3 cf       	rjmp	.-122    	; 0x3372 <__mulsf3+0xb0>
    33ec:	fa 85       	ldd	r31, Y+10	; 0x0a
    33ee:	ea 89       	ldd	r30, Y+18	; 0x12
    33f0:	2b 89       	ldd	r18, Y+19	; 0x13
    33f2:	3c 89       	ldd	r19, Y+20	; 0x14
    33f4:	8b 85       	ldd	r24, Y+11	; 0x0b
    33f6:	9c 85       	ldd	r25, Y+12	; 0x0c
    33f8:	28 0f       	add	r18, r24
    33fa:	39 1f       	adc	r19, r25
    33fc:	2e 5f       	subi	r18, 0xFE	; 254
    33fe:	3f 4f       	sbci	r19, 0xFF	; 255
    3400:	17 c0       	rjmp	.+46     	; 0x3430 <__mulsf3+0x16e>
    3402:	ca 01       	movw	r24, r20
    3404:	81 70       	andi	r24, 0x01	; 1
    3406:	90 70       	andi	r25, 0x00	; 0
    3408:	89 2b       	or	r24, r25
    340a:	61 f0       	breq	.+24     	; 0x3424 <__mulsf3+0x162>
    340c:	16 95       	lsr	r17
    340e:	07 95       	ror	r16
    3410:	f7 94       	ror	r15
    3412:	e7 94       	ror	r14
    3414:	80 e0       	ldi	r24, 0x00	; 0
    3416:	90 e0       	ldi	r25, 0x00	; 0
    3418:	a0 e0       	ldi	r26, 0x00	; 0
    341a:	b0 e8       	ldi	r27, 0x80	; 128
    341c:	e8 2a       	or	r14, r24
    341e:	f9 2a       	or	r15, r25
    3420:	0a 2b       	or	r16, r26
    3422:	1b 2b       	or	r17, r27
    3424:	76 95       	lsr	r23
    3426:	67 95       	ror	r22
    3428:	57 95       	ror	r21
    342a:	47 95       	ror	r20
    342c:	2f 5f       	subi	r18, 0xFF	; 255
    342e:	3f 4f       	sbci	r19, 0xFF	; 255
    3430:	77 fd       	sbrc	r23, 7
    3432:	e7 cf       	rjmp	.-50     	; 0x3402 <__mulsf3+0x140>
    3434:	0c c0       	rjmp	.+24     	; 0x344e <__mulsf3+0x18c>
    3436:	44 0f       	add	r20, r20
    3438:	55 1f       	adc	r21, r21
    343a:	66 1f       	adc	r22, r22
    343c:	77 1f       	adc	r23, r23
    343e:	17 fd       	sbrc	r17, 7
    3440:	41 60       	ori	r20, 0x01	; 1
    3442:	ee 0c       	add	r14, r14
    3444:	ff 1c       	adc	r15, r15
    3446:	00 1f       	adc	r16, r16
    3448:	11 1f       	adc	r17, r17
    344a:	21 50       	subi	r18, 0x01	; 1
    344c:	30 40       	sbci	r19, 0x00	; 0
    344e:	40 30       	cpi	r20, 0x00	; 0
    3450:	90 e0       	ldi	r25, 0x00	; 0
    3452:	59 07       	cpc	r21, r25
    3454:	90 e0       	ldi	r25, 0x00	; 0
    3456:	69 07       	cpc	r22, r25
    3458:	90 e4       	ldi	r25, 0x40	; 64
    345a:	79 07       	cpc	r23, r25
    345c:	60 f3       	brcs	.-40     	; 0x3436 <__mulsf3+0x174>
    345e:	2b 8f       	std	Y+27, r18	; 0x1b
    3460:	3c 8f       	std	Y+28, r19	; 0x1c
    3462:	db 01       	movw	r26, r22
    3464:	ca 01       	movw	r24, r20
    3466:	8f 77       	andi	r24, 0x7F	; 127
    3468:	90 70       	andi	r25, 0x00	; 0
    346a:	a0 70       	andi	r26, 0x00	; 0
    346c:	b0 70       	andi	r27, 0x00	; 0
    346e:	80 34       	cpi	r24, 0x40	; 64
    3470:	91 05       	cpc	r25, r1
    3472:	a1 05       	cpc	r26, r1
    3474:	b1 05       	cpc	r27, r1
    3476:	61 f4       	brne	.+24     	; 0x3490 <__mulsf3+0x1ce>
    3478:	47 fd       	sbrc	r20, 7
    347a:	0a c0       	rjmp	.+20     	; 0x3490 <__mulsf3+0x1ce>
    347c:	e1 14       	cp	r14, r1
    347e:	f1 04       	cpc	r15, r1
    3480:	01 05       	cpc	r16, r1
    3482:	11 05       	cpc	r17, r1
    3484:	29 f0       	breq	.+10     	; 0x3490 <__mulsf3+0x1ce>
    3486:	40 5c       	subi	r20, 0xC0	; 192
    3488:	5f 4f       	sbci	r21, 0xFF	; 255
    348a:	6f 4f       	sbci	r22, 0xFF	; 255
    348c:	7f 4f       	sbci	r23, 0xFF	; 255
    348e:	40 78       	andi	r20, 0x80	; 128
    3490:	1a 8e       	std	Y+26, r1	; 0x1a
    3492:	fe 17       	cp	r31, r30
    3494:	11 f0       	breq	.+4      	; 0x349a <__mulsf3+0x1d8>
    3496:	81 e0       	ldi	r24, 0x01	; 1
    3498:	8a 8f       	std	Y+26, r24	; 0x1a
    349a:	4d 8f       	std	Y+29, r20	; 0x1d
    349c:	5e 8f       	std	Y+30, r21	; 0x1e
    349e:	6f 8f       	std	Y+31, r22	; 0x1f
    34a0:	78 a3       	std	Y+32, r23	; 0x20
    34a2:	83 e0       	ldi	r24, 0x03	; 3
    34a4:	89 8f       	std	Y+25, r24	; 0x19
    34a6:	ce 01       	movw	r24, r28
    34a8:	49 96       	adiw	r24, 0x19	; 25
    34aa:	0e 94 b3 1c 	call	0x3966	; 0x3966 <__pack_f>
    34ae:	a0 96       	adiw	r28, 0x20	; 32
    34b0:	e2 e1       	ldi	r30, 0x12	; 18
    34b2:	0c 94 e1 22 	jmp	0x45c2	; 0x45c2 <__epilogue_restores__>

000034b6 <__divsf3>:
    34b6:	a8 e1       	ldi	r26, 0x18	; 24
    34b8:	b0 e0       	ldi	r27, 0x00	; 0
    34ba:	e1 e6       	ldi	r30, 0x61	; 97
    34bc:	fa e1       	ldi	r31, 0x1A	; 26
    34be:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__prologue_saves__+0x10>
    34c2:	69 83       	std	Y+1, r22	; 0x01
    34c4:	7a 83       	std	Y+2, r23	; 0x02
    34c6:	8b 83       	std	Y+3, r24	; 0x03
    34c8:	9c 83       	std	Y+4, r25	; 0x04
    34ca:	2d 83       	std	Y+5, r18	; 0x05
    34cc:	3e 83       	std	Y+6, r19	; 0x06
    34ce:	4f 83       	std	Y+7, r20	; 0x07
    34d0:	58 87       	std	Y+8, r21	; 0x08
    34d2:	b9 e0       	ldi	r27, 0x09	; 9
    34d4:	eb 2e       	mov	r14, r27
    34d6:	f1 2c       	mov	r15, r1
    34d8:	ec 0e       	add	r14, r28
    34da:	fd 1e       	adc	r15, r29
    34dc:	ce 01       	movw	r24, r28
    34de:	01 96       	adiw	r24, 0x01	; 1
    34e0:	b7 01       	movw	r22, r14
    34e2:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    34e6:	8e 01       	movw	r16, r28
    34e8:	0f 5e       	subi	r16, 0xEF	; 239
    34ea:	1f 4f       	sbci	r17, 0xFF	; 255
    34ec:	ce 01       	movw	r24, r28
    34ee:	05 96       	adiw	r24, 0x05	; 5
    34f0:	b8 01       	movw	r22, r16
    34f2:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    34f6:	29 85       	ldd	r18, Y+9	; 0x09
    34f8:	22 30       	cpi	r18, 0x02	; 2
    34fa:	08 f4       	brcc	.+2      	; 0x34fe <__divsf3+0x48>
    34fc:	7e c0       	rjmp	.+252    	; 0x35fa <__divsf3+0x144>
    34fe:	39 89       	ldd	r19, Y+17	; 0x11
    3500:	32 30       	cpi	r19, 0x02	; 2
    3502:	10 f4       	brcc	.+4      	; 0x3508 <__divsf3+0x52>
    3504:	b8 01       	movw	r22, r16
    3506:	7c c0       	rjmp	.+248    	; 0x3600 <__divsf3+0x14a>
    3508:	8a 85       	ldd	r24, Y+10	; 0x0a
    350a:	9a 89       	ldd	r25, Y+18	; 0x12
    350c:	89 27       	eor	r24, r25
    350e:	8a 87       	std	Y+10, r24	; 0x0a
    3510:	24 30       	cpi	r18, 0x04	; 4
    3512:	11 f0       	breq	.+4      	; 0x3518 <__divsf3+0x62>
    3514:	22 30       	cpi	r18, 0x02	; 2
    3516:	31 f4       	brne	.+12     	; 0x3524 <__divsf3+0x6e>
    3518:	23 17       	cp	r18, r19
    351a:	09 f0       	breq	.+2      	; 0x351e <__divsf3+0x68>
    351c:	6e c0       	rjmp	.+220    	; 0x35fa <__divsf3+0x144>
    351e:	69 e4       	ldi	r22, 0x49	; 73
    3520:	74 e0       	ldi	r23, 0x04	; 4
    3522:	6e c0       	rjmp	.+220    	; 0x3600 <__divsf3+0x14a>
    3524:	34 30       	cpi	r19, 0x04	; 4
    3526:	39 f4       	brne	.+14     	; 0x3536 <__divsf3+0x80>
    3528:	1d 86       	std	Y+13, r1	; 0x0d
    352a:	1e 86       	std	Y+14, r1	; 0x0e
    352c:	1f 86       	std	Y+15, r1	; 0x0f
    352e:	18 8a       	std	Y+16, r1	; 0x10
    3530:	1c 86       	std	Y+12, r1	; 0x0c
    3532:	1b 86       	std	Y+11, r1	; 0x0b
    3534:	04 c0       	rjmp	.+8      	; 0x353e <__divsf3+0x88>
    3536:	32 30       	cpi	r19, 0x02	; 2
    3538:	21 f4       	brne	.+8      	; 0x3542 <__divsf3+0x8c>
    353a:	84 e0       	ldi	r24, 0x04	; 4
    353c:	89 87       	std	Y+9, r24	; 0x09
    353e:	b7 01       	movw	r22, r14
    3540:	5f c0       	rjmp	.+190    	; 0x3600 <__divsf3+0x14a>
    3542:	2b 85       	ldd	r18, Y+11	; 0x0b
    3544:	3c 85       	ldd	r19, Y+12	; 0x0c
    3546:	8b 89       	ldd	r24, Y+19	; 0x13
    3548:	9c 89       	ldd	r25, Y+20	; 0x14
    354a:	28 1b       	sub	r18, r24
    354c:	39 0b       	sbc	r19, r25
    354e:	3c 87       	std	Y+12, r19	; 0x0c
    3550:	2b 87       	std	Y+11, r18	; 0x0b
    3552:	ed 84       	ldd	r14, Y+13	; 0x0d
    3554:	fe 84       	ldd	r15, Y+14	; 0x0e
    3556:	0f 85       	ldd	r16, Y+15	; 0x0f
    3558:	18 89       	ldd	r17, Y+16	; 0x10
    355a:	ad 88       	ldd	r10, Y+21	; 0x15
    355c:	be 88       	ldd	r11, Y+22	; 0x16
    355e:	cf 88       	ldd	r12, Y+23	; 0x17
    3560:	d8 8c       	ldd	r13, Y+24	; 0x18
    3562:	ea 14       	cp	r14, r10
    3564:	fb 04       	cpc	r15, r11
    3566:	0c 05       	cpc	r16, r12
    3568:	1d 05       	cpc	r17, r13
    356a:	40 f4       	brcc	.+16     	; 0x357c <__divsf3+0xc6>
    356c:	ee 0c       	add	r14, r14
    356e:	ff 1c       	adc	r15, r15
    3570:	00 1f       	adc	r16, r16
    3572:	11 1f       	adc	r17, r17
    3574:	21 50       	subi	r18, 0x01	; 1
    3576:	30 40       	sbci	r19, 0x00	; 0
    3578:	3c 87       	std	Y+12, r19	; 0x0c
    357a:	2b 87       	std	Y+11, r18	; 0x0b
    357c:	20 e0       	ldi	r18, 0x00	; 0
    357e:	30 e0       	ldi	r19, 0x00	; 0
    3580:	40 e0       	ldi	r20, 0x00	; 0
    3582:	50 e0       	ldi	r21, 0x00	; 0
    3584:	80 e0       	ldi	r24, 0x00	; 0
    3586:	90 e0       	ldi	r25, 0x00	; 0
    3588:	a0 e0       	ldi	r26, 0x00	; 0
    358a:	b0 e4       	ldi	r27, 0x40	; 64
    358c:	60 e0       	ldi	r22, 0x00	; 0
    358e:	70 e0       	ldi	r23, 0x00	; 0
    3590:	ea 14       	cp	r14, r10
    3592:	fb 04       	cpc	r15, r11
    3594:	0c 05       	cpc	r16, r12
    3596:	1d 05       	cpc	r17, r13
    3598:	40 f0       	brcs	.+16     	; 0x35aa <__divsf3+0xf4>
    359a:	28 2b       	or	r18, r24
    359c:	39 2b       	or	r19, r25
    359e:	4a 2b       	or	r20, r26
    35a0:	5b 2b       	or	r21, r27
    35a2:	ea 18       	sub	r14, r10
    35a4:	fb 08       	sbc	r15, r11
    35a6:	0c 09       	sbc	r16, r12
    35a8:	1d 09       	sbc	r17, r13
    35aa:	b6 95       	lsr	r27
    35ac:	a7 95       	ror	r26
    35ae:	97 95       	ror	r25
    35b0:	87 95       	ror	r24
    35b2:	ee 0c       	add	r14, r14
    35b4:	ff 1c       	adc	r15, r15
    35b6:	00 1f       	adc	r16, r16
    35b8:	11 1f       	adc	r17, r17
    35ba:	6f 5f       	subi	r22, 0xFF	; 255
    35bc:	7f 4f       	sbci	r23, 0xFF	; 255
    35be:	6f 31       	cpi	r22, 0x1F	; 31
    35c0:	71 05       	cpc	r23, r1
    35c2:	31 f7       	brne	.-52     	; 0x3590 <__divsf3+0xda>
    35c4:	da 01       	movw	r26, r20
    35c6:	c9 01       	movw	r24, r18
    35c8:	8f 77       	andi	r24, 0x7F	; 127
    35ca:	90 70       	andi	r25, 0x00	; 0
    35cc:	a0 70       	andi	r26, 0x00	; 0
    35ce:	b0 70       	andi	r27, 0x00	; 0
    35d0:	80 34       	cpi	r24, 0x40	; 64
    35d2:	91 05       	cpc	r25, r1
    35d4:	a1 05       	cpc	r26, r1
    35d6:	b1 05       	cpc	r27, r1
    35d8:	61 f4       	brne	.+24     	; 0x35f2 <__divsf3+0x13c>
    35da:	27 fd       	sbrc	r18, 7
    35dc:	0a c0       	rjmp	.+20     	; 0x35f2 <__divsf3+0x13c>
    35de:	e1 14       	cp	r14, r1
    35e0:	f1 04       	cpc	r15, r1
    35e2:	01 05       	cpc	r16, r1
    35e4:	11 05       	cpc	r17, r1
    35e6:	29 f0       	breq	.+10     	; 0x35f2 <__divsf3+0x13c>
    35e8:	20 5c       	subi	r18, 0xC0	; 192
    35ea:	3f 4f       	sbci	r19, 0xFF	; 255
    35ec:	4f 4f       	sbci	r20, 0xFF	; 255
    35ee:	5f 4f       	sbci	r21, 0xFF	; 255
    35f0:	20 78       	andi	r18, 0x80	; 128
    35f2:	2d 87       	std	Y+13, r18	; 0x0d
    35f4:	3e 87       	std	Y+14, r19	; 0x0e
    35f6:	4f 87       	std	Y+15, r20	; 0x0f
    35f8:	58 8b       	std	Y+16, r21	; 0x10
    35fa:	be 01       	movw	r22, r28
    35fc:	67 5f       	subi	r22, 0xF7	; 247
    35fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3600:	cb 01       	movw	r24, r22
    3602:	0e 94 b3 1c 	call	0x3966	; 0x3966 <__pack_f>
    3606:	68 96       	adiw	r28, 0x18	; 24
    3608:	ea e0       	ldi	r30, 0x0A	; 10
    360a:	0c 94 e9 22 	jmp	0x45d2	; 0x45d2 <__epilogue_restores__+0x10>

0000360e <__gtsf2>:
    360e:	a8 e1       	ldi	r26, 0x18	; 24
    3610:	b0 e0       	ldi	r27, 0x00	; 0
    3612:	ed e0       	ldi	r30, 0x0D	; 13
    3614:	fb e1       	ldi	r31, 0x1B	; 27
    3616:	0c 94 d1 22 	jmp	0x45a2	; 0x45a2 <__prologue_saves__+0x18>
    361a:	69 83       	std	Y+1, r22	; 0x01
    361c:	7a 83       	std	Y+2, r23	; 0x02
    361e:	8b 83       	std	Y+3, r24	; 0x03
    3620:	9c 83       	std	Y+4, r25	; 0x04
    3622:	2d 83       	std	Y+5, r18	; 0x05
    3624:	3e 83       	std	Y+6, r19	; 0x06
    3626:	4f 83       	std	Y+7, r20	; 0x07
    3628:	58 87       	std	Y+8, r21	; 0x08
    362a:	89 e0       	ldi	r24, 0x09	; 9
    362c:	e8 2e       	mov	r14, r24
    362e:	f1 2c       	mov	r15, r1
    3630:	ec 0e       	add	r14, r28
    3632:	fd 1e       	adc	r15, r29
    3634:	ce 01       	movw	r24, r28
    3636:	01 96       	adiw	r24, 0x01	; 1
    3638:	b7 01       	movw	r22, r14
    363a:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    363e:	8e 01       	movw	r16, r28
    3640:	0f 5e       	subi	r16, 0xEF	; 239
    3642:	1f 4f       	sbci	r17, 0xFF	; 255
    3644:	ce 01       	movw	r24, r28
    3646:	05 96       	adiw	r24, 0x05	; 5
    3648:	b8 01       	movw	r22, r16
    364a:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    364e:	89 85       	ldd	r24, Y+9	; 0x09
    3650:	82 30       	cpi	r24, 0x02	; 2
    3652:	40 f0       	brcs	.+16     	; 0x3664 <__gtsf2+0x56>
    3654:	89 89       	ldd	r24, Y+17	; 0x11
    3656:	82 30       	cpi	r24, 0x02	; 2
    3658:	28 f0       	brcs	.+10     	; 0x3664 <__gtsf2+0x56>
    365a:	c7 01       	movw	r24, r14
    365c:	b8 01       	movw	r22, r16
    365e:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <__fpcmp_parts_f>
    3662:	01 c0       	rjmp	.+2      	; 0x3666 <__gtsf2+0x58>
    3664:	8f ef       	ldi	r24, 0xFF	; 255
    3666:	68 96       	adiw	r28, 0x18	; 24
    3668:	e6 e0       	ldi	r30, 0x06	; 6
    366a:	0c 94 ed 22 	jmp	0x45da	; 0x45da <__epilogue_restores__+0x18>

0000366e <__gesf2>:
    366e:	a8 e1       	ldi	r26, 0x18	; 24
    3670:	b0 e0       	ldi	r27, 0x00	; 0
    3672:	ed e3       	ldi	r30, 0x3D	; 61
    3674:	fb e1       	ldi	r31, 0x1B	; 27
    3676:	0c 94 d1 22 	jmp	0x45a2	; 0x45a2 <__prologue_saves__+0x18>
    367a:	69 83       	std	Y+1, r22	; 0x01
    367c:	7a 83       	std	Y+2, r23	; 0x02
    367e:	8b 83       	std	Y+3, r24	; 0x03
    3680:	9c 83       	std	Y+4, r25	; 0x04
    3682:	2d 83       	std	Y+5, r18	; 0x05
    3684:	3e 83       	std	Y+6, r19	; 0x06
    3686:	4f 83       	std	Y+7, r20	; 0x07
    3688:	58 87       	std	Y+8, r21	; 0x08
    368a:	89 e0       	ldi	r24, 0x09	; 9
    368c:	e8 2e       	mov	r14, r24
    368e:	f1 2c       	mov	r15, r1
    3690:	ec 0e       	add	r14, r28
    3692:	fd 1e       	adc	r15, r29
    3694:	ce 01       	movw	r24, r28
    3696:	01 96       	adiw	r24, 0x01	; 1
    3698:	b7 01       	movw	r22, r14
    369a:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    369e:	8e 01       	movw	r16, r28
    36a0:	0f 5e       	subi	r16, 0xEF	; 239
    36a2:	1f 4f       	sbci	r17, 0xFF	; 255
    36a4:	ce 01       	movw	r24, r28
    36a6:	05 96       	adiw	r24, 0x05	; 5
    36a8:	b8 01       	movw	r22, r16
    36aa:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    36ae:	89 85       	ldd	r24, Y+9	; 0x09
    36b0:	82 30       	cpi	r24, 0x02	; 2
    36b2:	40 f0       	brcs	.+16     	; 0x36c4 <__gesf2+0x56>
    36b4:	89 89       	ldd	r24, Y+17	; 0x11
    36b6:	82 30       	cpi	r24, 0x02	; 2
    36b8:	28 f0       	brcs	.+10     	; 0x36c4 <__gesf2+0x56>
    36ba:	c7 01       	movw	r24, r14
    36bc:	b8 01       	movw	r22, r16
    36be:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <__fpcmp_parts_f>
    36c2:	01 c0       	rjmp	.+2      	; 0x36c6 <__gesf2+0x58>
    36c4:	8f ef       	ldi	r24, 0xFF	; 255
    36c6:	68 96       	adiw	r28, 0x18	; 24
    36c8:	e6 e0       	ldi	r30, 0x06	; 6
    36ca:	0c 94 ed 22 	jmp	0x45da	; 0x45da <__epilogue_restores__+0x18>

000036ce <__ltsf2>:
    36ce:	a8 e1       	ldi	r26, 0x18	; 24
    36d0:	b0 e0       	ldi	r27, 0x00	; 0
    36d2:	ed e6       	ldi	r30, 0x6D	; 109
    36d4:	fb e1       	ldi	r31, 0x1B	; 27
    36d6:	0c 94 d1 22 	jmp	0x45a2	; 0x45a2 <__prologue_saves__+0x18>
    36da:	69 83       	std	Y+1, r22	; 0x01
    36dc:	7a 83       	std	Y+2, r23	; 0x02
    36de:	8b 83       	std	Y+3, r24	; 0x03
    36e0:	9c 83       	std	Y+4, r25	; 0x04
    36e2:	2d 83       	std	Y+5, r18	; 0x05
    36e4:	3e 83       	std	Y+6, r19	; 0x06
    36e6:	4f 83       	std	Y+7, r20	; 0x07
    36e8:	58 87       	std	Y+8, r21	; 0x08
    36ea:	89 e0       	ldi	r24, 0x09	; 9
    36ec:	e8 2e       	mov	r14, r24
    36ee:	f1 2c       	mov	r15, r1
    36f0:	ec 0e       	add	r14, r28
    36f2:	fd 1e       	adc	r15, r29
    36f4:	ce 01       	movw	r24, r28
    36f6:	01 96       	adiw	r24, 0x01	; 1
    36f8:	b7 01       	movw	r22, r14
    36fa:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    36fe:	8e 01       	movw	r16, r28
    3700:	0f 5e       	subi	r16, 0xEF	; 239
    3702:	1f 4f       	sbci	r17, 0xFF	; 255
    3704:	ce 01       	movw	r24, r28
    3706:	05 96       	adiw	r24, 0x05	; 5
    3708:	b8 01       	movw	r22, r16
    370a:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    370e:	89 85       	ldd	r24, Y+9	; 0x09
    3710:	82 30       	cpi	r24, 0x02	; 2
    3712:	40 f0       	brcs	.+16     	; 0x3724 <__ltsf2+0x56>
    3714:	89 89       	ldd	r24, Y+17	; 0x11
    3716:	82 30       	cpi	r24, 0x02	; 2
    3718:	28 f0       	brcs	.+10     	; 0x3724 <__ltsf2+0x56>
    371a:	c7 01       	movw	r24, r14
    371c:	b8 01       	movw	r22, r16
    371e:	0e 94 00 1e 	call	0x3c00	; 0x3c00 <__fpcmp_parts_f>
    3722:	01 c0       	rjmp	.+2      	; 0x3726 <__ltsf2+0x58>
    3724:	81 e0       	ldi	r24, 0x01	; 1
    3726:	68 96       	adiw	r28, 0x18	; 24
    3728:	e6 e0       	ldi	r30, 0x06	; 6
    372a:	0c 94 ed 22 	jmp	0x45da	; 0x45da <__epilogue_restores__+0x18>

0000372e <__fixsfsi>:
    372e:	ac e0       	ldi	r26, 0x0C	; 12
    3730:	b0 e0       	ldi	r27, 0x00	; 0
    3732:	ed e9       	ldi	r30, 0x9D	; 157
    3734:	fb e1       	ldi	r31, 0x1B	; 27
    3736:	0c 94 d5 22 	jmp	0x45aa	; 0x45aa <__prologue_saves__+0x20>
    373a:	69 83       	std	Y+1, r22	; 0x01
    373c:	7a 83       	std	Y+2, r23	; 0x02
    373e:	8b 83       	std	Y+3, r24	; 0x03
    3740:	9c 83       	std	Y+4, r25	; 0x04
    3742:	ce 01       	movw	r24, r28
    3744:	01 96       	adiw	r24, 0x01	; 1
    3746:	be 01       	movw	r22, r28
    3748:	6b 5f       	subi	r22, 0xFB	; 251
    374a:	7f 4f       	sbci	r23, 0xFF	; 255
    374c:	0e 94 88 1d 	call	0x3b10	; 0x3b10 <__unpack_f>
    3750:	8d 81       	ldd	r24, Y+5	; 0x05
    3752:	82 30       	cpi	r24, 0x02	; 2
    3754:	61 f1       	breq	.+88     	; 0x37ae <__fixsfsi+0x80>
    3756:	82 30       	cpi	r24, 0x02	; 2
    3758:	50 f1       	brcs	.+84     	; 0x37ae <__fixsfsi+0x80>
    375a:	84 30       	cpi	r24, 0x04	; 4
    375c:	21 f4       	brne	.+8      	; 0x3766 <__fixsfsi+0x38>
    375e:	8e 81       	ldd	r24, Y+6	; 0x06
    3760:	88 23       	and	r24, r24
    3762:	51 f1       	breq	.+84     	; 0x37b8 <__fixsfsi+0x8a>
    3764:	2e c0       	rjmp	.+92     	; 0x37c2 <__fixsfsi+0x94>
    3766:	2f 81       	ldd	r18, Y+7	; 0x07
    3768:	38 85       	ldd	r19, Y+8	; 0x08
    376a:	37 fd       	sbrc	r19, 7
    376c:	20 c0       	rjmp	.+64     	; 0x37ae <__fixsfsi+0x80>
    376e:	6e 81       	ldd	r22, Y+6	; 0x06
    3770:	2f 31       	cpi	r18, 0x1F	; 31
    3772:	31 05       	cpc	r19, r1
    3774:	1c f0       	brlt	.+6      	; 0x377c <__fixsfsi+0x4e>
    3776:	66 23       	and	r22, r22
    3778:	f9 f0       	breq	.+62     	; 0x37b8 <__fixsfsi+0x8a>
    377a:	23 c0       	rjmp	.+70     	; 0x37c2 <__fixsfsi+0x94>
    377c:	8e e1       	ldi	r24, 0x1E	; 30
    377e:	90 e0       	ldi	r25, 0x00	; 0
    3780:	82 1b       	sub	r24, r18
    3782:	93 0b       	sbc	r25, r19
    3784:	29 85       	ldd	r18, Y+9	; 0x09
    3786:	3a 85       	ldd	r19, Y+10	; 0x0a
    3788:	4b 85       	ldd	r20, Y+11	; 0x0b
    378a:	5c 85       	ldd	r21, Y+12	; 0x0c
    378c:	04 c0       	rjmp	.+8      	; 0x3796 <__fixsfsi+0x68>
    378e:	56 95       	lsr	r21
    3790:	47 95       	ror	r20
    3792:	37 95       	ror	r19
    3794:	27 95       	ror	r18
    3796:	8a 95       	dec	r24
    3798:	d2 f7       	brpl	.-12     	; 0x378e <__fixsfsi+0x60>
    379a:	66 23       	and	r22, r22
    379c:	b1 f0       	breq	.+44     	; 0x37ca <__fixsfsi+0x9c>
    379e:	50 95       	com	r21
    37a0:	40 95       	com	r20
    37a2:	30 95       	com	r19
    37a4:	21 95       	neg	r18
    37a6:	3f 4f       	sbci	r19, 0xFF	; 255
    37a8:	4f 4f       	sbci	r20, 0xFF	; 255
    37aa:	5f 4f       	sbci	r21, 0xFF	; 255
    37ac:	0e c0       	rjmp	.+28     	; 0x37ca <__fixsfsi+0x9c>
    37ae:	20 e0       	ldi	r18, 0x00	; 0
    37b0:	30 e0       	ldi	r19, 0x00	; 0
    37b2:	40 e0       	ldi	r20, 0x00	; 0
    37b4:	50 e0       	ldi	r21, 0x00	; 0
    37b6:	09 c0       	rjmp	.+18     	; 0x37ca <__fixsfsi+0x9c>
    37b8:	2f ef       	ldi	r18, 0xFF	; 255
    37ba:	3f ef       	ldi	r19, 0xFF	; 255
    37bc:	4f ef       	ldi	r20, 0xFF	; 255
    37be:	5f e7       	ldi	r21, 0x7F	; 127
    37c0:	04 c0       	rjmp	.+8      	; 0x37ca <__fixsfsi+0x9c>
    37c2:	20 e0       	ldi	r18, 0x00	; 0
    37c4:	30 e0       	ldi	r19, 0x00	; 0
    37c6:	40 e0       	ldi	r20, 0x00	; 0
    37c8:	50 e8       	ldi	r21, 0x80	; 128
    37ca:	b9 01       	movw	r22, r18
    37cc:	ca 01       	movw	r24, r20
    37ce:	2c 96       	adiw	r28, 0x0c	; 12
    37d0:	e2 e0       	ldi	r30, 0x02	; 2
    37d2:	0c 94 f1 22 	jmp	0x45e2	; 0x45e2 <__epilogue_restores__+0x20>

000037d6 <__floatunsisf>:
    37d6:	a8 e0       	ldi	r26, 0x08	; 8
    37d8:	b0 e0       	ldi	r27, 0x00	; 0
    37da:	e1 ef       	ldi	r30, 0xF1	; 241
    37dc:	fb e1       	ldi	r31, 0x1B	; 27
    37de:	0c 94 cd 22 	jmp	0x459a	; 0x459a <__prologue_saves__+0x10>
    37e2:	7b 01       	movw	r14, r22
    37e4:	8c 01       	movw	r16, r24
    37e6:	61 15       	cp	r22, r1
    37e8:	71 05       	cpc	r23, r1
    37ea:	81 05       	cpc	r24, r1
    37ec:	91 05       	cpc	r25, r1
    37ee:	19 f4       	brne	.+6      	; 0x37f6 <__floatunsisf+0x20>
    37f0:	82 e0       	ldi	r24, 0x02	; 2
    37f2:	89 83       	std	Y+1, r24	; 0x01
    37f4:	60 c0       	rjmp	.+192    	; 0x38b6 <__floatunsisf+0xe0>
    37f6:	83 e0       	ldi	r24, 0x03	; 3
    37f8:	89 83       	std	Y+1, r24	; 0x01
    37fa:	8e e1       	ldi	r24, 0x1E	; 30
    37fc:	c8 2e       	mov	r12, r24
    37fe:	d1 2c       	mov	r13, r1
    3800:	dc 82       	std	Y+4, r13	; 0x04
    3802:	cb 82       	std	Y+3, r12	; 0x03
    3804:	ed 82       	std	Y+5, r14	; 0x05
    3806:	fe 82       	std	Y+6, r15	; 0x06
    3808:	0f 83       	std	Y+7, r16	; 0x07
    380a:	18 87       	std	Y+8, r17	; 0x08
    380c:	c8 01       	movw	r24, r16
    380e:	b7 01       	movw	r22, r14
    3810:	0e 94 64 1c 	call	0x38c8	; 0x38c8 <__clzsi2>
    3814:	fc 01       	movw	r30, r24
    3816:	31 97       	sbiw	r30, 0x01	; 1
    3818:	f7 ff       	sbrs	r31, 7
    381a:	3b c0       	rjmp	.+118    	; 0x3892 <__floatunsisf+0xbc>
    381c:	22 27       	eor	r18, r18
    381e:	33 27       	eor	r19, r19
    3820:	2e 1b       	sub	r18, r30
    3822:	3f 0b       	sbc	r19, r31
    3824:	57 01       	movw	r10, r14
    3826:	68 01       	movw	r12, r16
    3828:	02 2e       	mov	r0, r18
    382a:	04 c0       	rjmp	.+8      	; 0x3834 <__floatunsisf+0x5e>
    382c:	d6 94       	lsr	r13
    382e:	c7 94       	ror	r12
    3830:	b7 94       	ror	r11
    3832:	a7 94       	ror	r10
    3834:	0a 94       	dec	r0
    3836:	d2 f7       	brpl	.-12     	; 0x382c <__floatunsisf+0x56>
    3838:	40 e0       	ldi	r20, 0x00	; 0
    383a:	50 e0       	ldi	r21, 0x00	; 0
    383c:	60 e0       	ldi	r22, 0x00	; 0
    383e:	70 e0       	ldi	r23, 0x00	; 0
    3840:	81 e0       	ldi	r24, 0x01	; 1
    3842:	90 e0       	ldi	r25, 0x00	; 0
    3844:	a0 e0       	ldi	r26, 0x00	; 0
    3846:	b0 e0       	ldi	r27, 0x00	; 0
    3848:	04 c0       	rjmp	.+8      	; 0x3852 <__floatunsisf+0x7c>
    384a:	88 0f       	add	r24, r24
    384c:	99 1f       	adc	r25, r25
    384e:	aa 1f       	adc	r26, r26
    3850:	bb 1f       	adc	r27, r27
    3852:	2a 95       	dec	r18
    3854:	d2 f7       	brpl	.-12     	; 0x384a <__floatunsisf+0x74>
    3856:	01 97       	sbiw	r24, 0x01	; 1
    3858:	a1 09       	sbc	r26, r1
    385a:	b1 09       	sbc	r27, r1
    385c:	8e 21       	and	r24, r14
    385e:	9f 21       	and	r25, r15
    3860:	a0 23       	and	r26, r16
    3862:	b1 23       	and	r27, r17
    3864:	00 97       	sbiw	r24, 0x00	; 0
    3866:	a1 05       	cpc	r26, r1
    3868:	b1 05       	cpc	r27, r1
    386a:	21 f0       	breq	.+8      	; 0x3874 <__floatunsisf+0x9e>
    386c:	41 e0       	ldi	r20, 0x01	; 1
    386e:	50 e0       	ldi	r21, 0x00	; 0
    3870:	60 e0       	ldi	r22, 0x00	; 0
    3872:	70 e0       	ldi	r23, 0x00	; 0
    3874:	4a 29       	or	r20, r10
    3876:	5b 29       	or	r21, r11
    3878:	6c 29       	or	r22, r12
    387a:	7d 29       	or	r23, r13
    387c:	4d 83       	std	Y+5, r20	; 0x05
    387e:	5e 83       	std	Y+6, r21	; 0x06
    3880:	6f 83       	std	Y+7, r22	; 0x07
    3882:	78 87       	std	Y+8, r23	; 0x08
    3884:	8e e1       	ldi	r24, 0x1E	; 30
    3886:	90 e0       	ldi	r25, 0x00	; 0
    3888:	8e 1b       	sub	r24, r30
    388a:	9f 0b       	sbc	r25, r31
    388c:	9c 83       	std	Y+4, r25	; 0x04
    388e:	8b 83       	std	Y+3, r24	; 0x03
    3890:	12 c0       	rjmp	.+36     	; 0x38b6 <__floatunsisf+0xe0>
    3892:	30 97       	sbiw	r30, 0x00	; 0
    3894:	81 f0       	breq	.+32     	; 0x38b6 <__floatunsisf+0xe0>
    3896:	0e 2e       	mov	r0, r30
    3898:	04 c0       	rjmp	.+8      	; 0x38a2 <__floatunsisf+0xcc>
    389a:	ee 0c       	add	r14, r14
    389c:	ff 1c       	adc	r15, r15
    389e:	00 1f       	adc	r16, r16
    38a0:	11 1f       	adc	r17, r17
    38a2:	0a 94       	dec	r0
    38a4:	d2 f7       	brpl	.-12     	; 0x389a <__floatunsisf+0xc4>
    38a6:	ed 82       	std	Y+5, r14	; 0x05
    38a8:	fe 82       	std	Y+6, r15	; 0x06
    38aa:	0f 83       	std	Y+7, r16	; 0x07
    38ac:	18 87       	std	Y+8, r17	; 0x08
    38ae:	ce 1a       	sub	r12, r30
    38b0:	df 0a       	sbc	r13, r31
    38b2:	dc 82       	std	Y+4, r13	; 0x04
    38b4:	cb 82       	std	Y+3, r12	; 0x03
    38b6:	1a 82       	std	Y+2, r1	; 0x02
    38b8:	ce 01       	movw	r24, r28
    38ba:	01 96       	adiw	r24, 0x01	; 1
    38bc:	0e 94 b3 1c 	call	0x3966	; 0x3966 <__pack_f>
    38c0:	28 96       	adiw	r28, 0x08	; 8
    38c2:	ea e0       	ldi	r30, 0x0A	; 10
    38c4:	0c 94 e9 22 	jmp	0x45d2	; 0x45d2 <__epilogue_restores__+0x10>

000038c8 <__clzsi2>:
    38c8:	ef 92       	push	r14
    38ca:	ff 92       	push	r15
    38cc:	0f 93       	push	r16
    38ce:	1f 93       	push	r17
    38d0:	7b 01       	movw	r14, r22
    38d2:	8c 01       	movw	r16, r24
    38d4:	80 e0       	ldi	r24, 0x00	; 0
    38d6:	e8 16       	cp	r14, r24
    38d8:	80 e0       	ldi	r24, 0x00	; 0
    38da:	f8 06       	cpc	r15, r24
    38dc:	81 e0       	ldi	r24, 0x01	; 1
    38de:	08 07       	cpc	r16, r24
    38e0:	80 e0       	ldi	r24, 0x00	; 0
    38e2:	18 07       	cpc	r17, r24
    38e4:	88 f4       	brcc	.+34     	; 0x3908 <__clzsi2+0x40>
    38e6:	8f ef       	ldi	r24, 0xFF	; 255
    38e8:	e8 16       	cp	r14, r24
    38ea:	f1 04       	cpc	r15, r1
    38ec:	01 05       	cpc	r16, r1
    38ee:	11 05       	cpc	r17, r1
    38f0:	31 f0       	breq	.+12     	; 0x38fe <__clzsi2+0x36>
    38f2:	28 f0       	brcs	.+10     	; 0x38fe <__clzsi2+0x36>
    38f4:	88 e0       	ldi	r24, 0x08	; 8
    38f6:	90 e0       	ldi	r25, 0x00	; 0
    38f8:	a0 e0       	ldi	r26, 0x00	; 0
    38fa:	b0 e0       	ldi	r27, 0x00	; 0
    38fc:	17 c0       	rjmp	.+46     	; 0x392c <__clzsi2+0x64>
    38fe:	80 e0       	ldi	r24, 0x00	; 0
    3900:	90 e0       	ldi	r25, 0x00	; 0
    3902:	a0 e0       	ldi	r26, 0x00	; 0
    3904:	b0 e0       	ldi	r27, 0x00	; 0
    3906:	12 c0       	rjmp	.+36     	; 0x392c <__clzsi2+0x64>
    3908:	80 e0       	ldi	r24, 0x00	; 0
    390a:	e8 16       	cp	r14, r24
    390c:	80 e0       	ldi	r24, 0x00	; 0
    390e:	f8 06       	cpc	r15, r24
    3910:	80 e0       	ldi	r24, 0x00	; 0
    3912:	08 07       	cpc	r16, r24
    3914:	81 e0       	ldi	r24, 0x01	; 1
    3916:	18 07       	cpc	r17, r24
    3918:	28 f0       	brcs	.+10     	; 0x3924 <__clzsi2+0x5c>
    391a:	88 e1       	ldi	r24, 0x18	; 24
    391c:	90 e0       	ldi	r25, 0x00	; 0
    391e:	a0 e0       	ldi	r26, 0x00	; 0
    3920:	b0 e0       	ldi	r27, 0x00	; 0
    3922:	04 c0       	rjmp	.+8      	; 0x392c <__clzsi2+0x64>
    3924:	80 e1       	ldi	r24, 0x10	; 16
    3926:	90 e0       	ldi	r25, 0x00	; 0
    3928:	a0 e0       	ldi	r26, 0x00	; 0
    392a:	b0 e0       	ldi	r27, 0x00	; 0
    392c:	20 e2       	ldi	r18, 0x20	; 32
    392e:	30 e0       	ldi	r19, 0x00	; 0
    3930:	40 e0       	ldi	r20, 0x00	; 0
    3932:	50 e0       	ldi	r21, 0x00	; 0
    3934:	28 1b       	sub	r18, r24
    3936:	39 0b       	sbc	r19, r25
    3938:	4a 0b       	sbc	r20, r26
    393a:	5b 0b       	sbc	r21, r27
    393c:	04 c0       	rjmp	.+8      	; 0x3946 <__clzsi2+0x7e>
    393e:	16 95       	lsr	r17
    3940:	07 95       	ror	r16
    3942:	f7 94       	ror	r15
    3944:	e7 94       	ror	r14
    3946:	8a 95       	dec	r24
    3948:	d2 f7       	brpl	.-12     	; 0x393e <__clzsi2+0x76>
    394a:	f7 01       	movw	r30, r14
    394c:	ef 5a       	subi	r30, 0xAF	; 175
    394e:	fb 4f       	sbci	r31, 0xFB	; 251
    3950:	80 81       	ld	r24, Z
    3952:	28 1b       	sub	r18, r24
    3954:	31 09       	sbc	r19, r1
    3956:	41 09       	sbc	r20, r1
    3958:	51 09       	sbc	r21, r1
    395a:	c9 01       	movw	r24, r18
    395c:	1f 91       	pop	r17
    395e:	0f 91       	pop	r16
    3960:	ff 90       	pop	r15
    3962:	ef 90       	pop	r14
    3964:	08 95       	ret

00003966 <__pack_f>:
    3966:	df 92       	push	r13
    3968:	ef 92       	push	r14
    396a:	ff 92       	push	r15
    396c:	0f 93       	push	r16
    396e:	1f 93       	push	r17
    3970:	fc 01       	movw	r30, r24
    3972:	e4 80       	ldd	r14, Z+4	; 0x04
    3974:	f5 80       	ldd	r15, Z+5	; 0x05
    3976:	06 81       	ldd	r16, Z+6	; 0x06
    3978:	17 81       	ldd	r17, Z+7	; 0x07
    397a:	d1 80       	ldd	r13, Z+1	; 0x01
    397c:	80 81       	ld	r24, Z
    397e:	82 30       	cpi	r24, 0x02	; 2
    3980:	48 f4       	brcc	.+18     	; 0x3994 <__pack_f+0x2e>
    3982:	80 e0       	ldi	r24, 0x00	; 0
    3984:	90 e0       	ldi	r25, 0x00	; 0
    3986:	a0 e1       	ldi	r26, 0x10	; 16
    3988:	b0 e0       	ldi	r27, 0x00	; 0
    398a:	e8 2a       	or	r14, r24
    398c:	f9 2a       	or	r15, r25
    398e:	0a 2b       	or	r16, r26
    3990:	1b 2b       	or	r17, r27
    3992:	a5 c0       	rjmp	.+330    	; 0x3ade <__pack_f+0x178>
    3994:	84 30       	cpi	r24, 0x04	; 4
    3996:	09 f4       	brne	.+2      	; 0x399a <__pack_f+0x34>
    3998:	9f c0       	rjmp	.+318    	; 0x3ad8 <__pack_f+0x172>
    399a:	82 30       	cpi	r24, 0x02	; 2
    399c:	21 f4       	brne	.+8      	; 0x39a6 <__pack_f+0x40>
    399e:	ee 24       	eor	r14, r14
    39a0:	ff 24       	eor	r15, r15
    39a2:	87 01       	movw	r16, r14
    39a4:	05 c0       	rjmp	.+10     	; 0x39b0 <__pack_f+0x4a>
    39a6:	e1 14       	cp	r14, r1
    39a8:	f1 04       	cpc	r15, r1
    39aa:	01 05       	cpc	r16, r1
    39ac:	11 05       	cpc	r17, r1
    39ae:	19 f4       	brne	.+6      	; 0x39b6 <__pack_f+0x50>
    39b0:	e0 e0       	ldi	r30, 0x00	; 0
    39b2:	f0 e0       	ldi	r31, 0x00	; 0
    39b4:	96 c0       	rjmp	.+300    	; 0x3ae2 <__pack_f+0x17c>
    39b6:	62 81       	ldd	r22, Z+2	; 0x02
    39b8:	73 81       	ldd	r23, Z+3	; 0x03
    39ba:	9f ef       	ldi	r25, 0xFF	; 255
    39bc:	62 38       	cpi	r22, 0x82	; 130
    39be:	79 07       	cpc	r23, r25
    39c0:	0c f0       	brlt	.+2      	; 0x39c4 <__pack_f+0x5e>
    39c2:	5b c0       	rjmp	.+182    	; 0x3a7a <__pack_f+0x114>
    39c4:	22 e8       	ldi	r18, 0x82	; 130
    39c6:	3f ef       	ldi	r19, 0xFF	; 255
    39c8:	26 1b       	sub	r18, r22
    39ca:	37 0b       	sbc	r19, r23
    39cc:	2a 31       	cpi	r18, 0x1A	; 26
    39ce:	31 05       	cpc	r19, r1
    39d0:	2c f0       	brlt	.+10     	; 0x39dc <__pack_f+0x76>
    39d2:	20 e0       	ldi	r18, 0x00	; 0
    39d4:	30 e0       	ldi	r19, 0x00	; 0
    39d6:	40 e0       	ldi	r20, 0x00	; 0
    39d8:	50 e0       	ldi	r21, 0x00	; 0
    39da:	2a c0       	rjmp	.+84     	; 0x3a30 <__pack_f+0xca>
    39dc:	b8 01       	movw	r22, r16
    39de:	a7 01       	movw	r20, r14
    39e0:	02 2e       	mov	r0, r18
    39e2:	04 c0       	rjmp	.+8      	; 0x39ec <__pack_f+0x86>
    39e4:	76 95       	lsr	r23
    39e6:	67 95       	ror	r22
    39e8:	57 95       	ror	r21
    39ea:	47 95       	ror	r20
    39ec:	0a 94       	dec	r0
    39ee:	d2 f7       	brpl	.-12     	; 0x39e4 <__pack_f+0x7e>
    39f0:	81 e0       	ldi	r24, 0x01	; 1
    39f2:	90 e0       	ldi	r25, 0x00	; 0
    39f4:	a0 e0       	ldi	r26, 0x00	; 0
    39f6:	b0 e0       	ldi	r27, 0x00	; 0
    39f8:	04 c0       	rjmp	.+8      	; 0x3a02 <__pack_f+0x9c>
    39fa:	88 0f       	add	r24, r24
    39fc:	99 1f       	adc	r25, r25
    39fe:	aa 1f       	adc	r26, r26
    3a00:	bb 1f       	adc	r27, r27
    3a02:	2a 95       	dec	r18
    3a04:	d2 f7       	brpl	.-12     	; 0x39fa <__pack_f+0x94>
    3a06:	01 97       	sbiw	r24, 0x01	; 1
    3a08:	a1 09       	sbc	r26, r1
    3a0a:	b1 09       	sbc	r27, r1
    3a0c:	8e 21       	and	r24, r14
    3a0e:	9f 21       	and	r25, r15
    3a10:	a0 23       	and	r26, r16
    3a12:	b1 23       	and	r27, r17
    3a14:	00 97       	sbiw	r24, 0x00	; 0
    3a16:	a1 05       	cpc	r26, r1
    3a18:	b1 05       	cpc	r27, r1
    3a1a:	21 f0       	breq	.+8      	; 0x3a24 <__pack_f+0xbe>
    3a1c:	81 e0       	ldi	r24, 0x01	; 1
    3a1e:	90 e0       	ldi	r25, 0x00	; 0
    3a20:	a0 e0       	ldi	r26, 0x00	; 0
    3a22:	b0 e0       	ldi	r27, 0x00	; 0
    3a24:	9a 01       	movw	r18, r20
    3a26:	ab 01       	movw	r20, r22
    3a28:	28 2b       	or	r18, r24
    3a2a:	39 2b       	or	r19, r25
    3a2c:	4a 2b       	or	r20, r26
    3a2e:	5b 2b       	or	r21, r27
    3a30:	da 01       	movw	r26, r20
    3a32:	c9 01       	movw	r24, r18
    3a34:	8f 77       	andi	r24, 0x7F	; 127
    3a36:	90 70       	andi	r25, 0x00	; 0
    3a38:	a0 70       	andi	r26, 0x00	; 0
    3a3a:	b0 70       	andi	r27, 0x00	; 0
    3a3c:	80 34       	cpi	r24, 0x40	; 64
    3a3e:	91 05       	cpc	r25, r1
    3a40:	a1 05       	cpc	r26, r1
    3a42:	b1 05       	cpc	r27, r1
    3a44:	39 f4       	brne	.+14     	; 0x3a54 <__pack_f+0xee>
    3a46:	27 ff       	sbrs	r18, 7
    3a48:	09 c0       	rjmp	.+18     	; 0x3a5c <__pack_f+0xf6>
    3a4a:	20 5c       	subi	r18, 0xC0	; 192
    3a4c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a4e:	4f 4f       	sbci	r20, 0xFF	; 255
    3a50:	5f 4f       	sbci	r21, 0xFF	; 255
    3a52:	04 c0       	rjmp	.+8      	; 0x3a5c <__pack_f+0xf6>
    3a54:	21 5c       	subi	r18, 0xC1	; 193
    3a56:	3f 4f       	sbci	r19, 0xFF	; 255
    3a58:	4f 4f       	sbci	r20, 0xFF	; 255
    3a5a:	5f 4f       	sbci	r21, 0xFF	; 255
    3a5c:	e0 e0       	ldi	r30, 0x00	; 0
    3a5e:	f0 e0       	ldi	r31, 0x00	; 0
    3a60:	20 30       	cpi	r18, 0x00	; 0
    3a62:	a0 e0       	ldi	r26, 0x00	; 0
    3a64:	3a 07       	cpc	r19, r26
    3a66:	a0 e0       	ldi	r26, 0x00	; 0
    3a68:	4a 07       	cpc	r20, r26
    3a6a:	a0 e4       	ldi	r26, 0x40	; 64
    3a6c:	5a 07       	cpc	r21, r26
    3a6e:	10 f0       	brcs	.+4      	; 0x3a74 <__pack_f+0x10e>
    3a70:	e1 e0       	ldi	r30, 0x01	; 1
    3a72:	f0 e0       	ldi	r31, 0x00	; 0
    3a74:	79 01       	movw	r14, r18
    3a76:	8a 01       	movw	r16, r20
    3a78:	27 c0       	rjmp	.+78     	; 0x3ac8 <__pack_f+0x162>
    3a7a:	60 38       	cpi	r22, 0x80	; 128
    3a7c:	71 05       	cpc	r23, r1
    3a7e:	64 f5       	brge	.+88     	; 0x3ad8 <__pack_f+0x172>
    3a80:	fb 01       	movw	r30, r22
    3a82:	e1 58       	subi	r30, 0x81	; 129
    3a84:	ff 4f       	sbci	r31, 0xFF	; 255
    3a86:	d8 01       	movw	r26, r16
    3a88:	c7 01       	movw	r24, r14
    3a8a:	8f 77       	andi	r24, 0x7F	; 127
    3a8c:	90 70       	andi	r25, 0x00	; 0
    3a8e:	a0 70       	andi	r26, 0x00	; 0
    3a90:	b0 70       	andi	r27, 0x00	; 0
    3a92:	80 34       	cpi	r24, 0x40	; 64
    3a94:	91 05       	cpc	r25, r1
    3a96:	a1 05       	cpc	r26, r1
    3a98:	b1 05       	cpc	r27, r1
    3a9a:	39 f4       	brne	.+14     	; 0x3aaa <__pack_f+0x144>
    3a9c:	e7 fe       	sbrs	r14, 7
    3a9e:	0d c0       	rjmp	.+26     	; 0x3aba <__pack_f+0x154>
    3aa0:	80 e4       	ldi	r24, 0x40	; 64
    3aa2:	90 e0       	ldi	r25, 0x00	; 0
    3aa4:	a0 e0       	ldi	r26, 0x00	; 0
    3aa6:	b0 e0       	ldi	r27, 0x00	; 0
    3aa8:	04 c0       	rjmp	.+8      	; 0x3ab2 <__pack_f+0x14c>
    3aaa:	8f e3       	ldi	r24, 0x3F	; 63
    3aac:	90 e0       	ldi	r25, 0x00	; 0
    3aae:	a0 e0       	ldi	r26, 0x00	; 0
    3ab0:	b0 e0       	ldi	r27, 0x00	; 0
    3ab2:	e8 0e       	add	r14, r24
    3ab4:	f9 1e       	adc	r15, r25
    3ab6:	0a 1f       	adc	r16, r26
    3ab8:	1b 1f       	adc	r17, r27
    3aba:	17 ff       	sbrs	r17, 7
    3abc:	05 c0       	rjmp	.+10     	; 0x3ac8 <__pack_f+0x162>
    3abe:	16 95       	lsr	r17
    3ac0:	07 95       	ror	r16
    3ac2:	f7 94       	ror	r15
    3ac4:	e7 94       	ror	r14
    3ac6:	31 96       	adiw	r30, 0x01	; 1
    3ac8:	87 e0       	ldi	r24, 0x07	; 7
    3aca:	16 95       	lsr	r17
    3acc:	07 95       	ror	r16
    3ace:	f7 94       	ror	r15
    3ad0:	e7 94       	ror	r14
    3ad2:	8a 95       	dec	r24
    3ad4:	d1 f7       	brne	.-12     	; 0x3aca <__pack_f+0x164>
    3ad6:	05 c0       	rjmp	.+10     	; 0x3ae2 <__pack_f+0x17c>
    3ad8:	ee 24       	eor	r14, r14
    3ada:	ff 24       	eor	r15, r15
    3adc:	87 01       	movw	r16, r14
    3ade:	ef ef       	ldi	r30, 0xFF	; 255
    3ae0:	f0 e0       	ldi	r31, 0x00	; 0
    3ae2:	6e 2f       	mov	r22, r30
    3ae4:	67 95       	ror	r22
    3ae6:	66 27       	eor	r22, r22
    3ae8:	67 95       	ror	r22
    3aea:	90 2f       	mov	r25, r16
    3aec:	9f 77       	andi	r25, 0x7F	; 127
    3aee:	d7 94       	ror	r13
    3af0:	dd 24       	eor	r13, r13
    3af2:	d7 94       	ror	r13
    3af4:	8e 2f       	mov	r24, r30
    3af6:	86 95       	lsr	r24
    3af8:	49 2f       	mov	r20, r25
    3afa:	46 2b       	or	r20, r22
    3afc:	58 2f       	mov	r21, r24
    3afe:	5d 29       	or	r21, r13
    3b00:	b7 01       	movw	r22, r14
    3b02:	ca 01       	movw	r24, r20
    3b04:	1f 91       	pop	r17
    3b06:	0f 91       	pop	r16
    3b08:	ff 90       	pop	r15
    3b0a:	ef 90       	pop	r14
    3b0c:	df 90       	pop	r13
    3b0e:	08 95       	ret

00003b10 <__unpack_f>:
    3b10:	fc 01       	movw	r30, r24
    3b12:	db 01       	movw	r26, r22
    3b14:	40 81       	ld	r20, Z
    3b16:	51 81       	ldd	r21, Z+1	; 0x01
    3b18:	22 81       	ldd	r18, Z+2	; 0x02
    3b1a:	62 2f       	mov	r22, r18
    3b1c:	6f 77       	andi	r22, 0x7F	; 127
    3b1e:	70 e0       	ldi	r23, 0x00	; 0
    3b20:	22 1f       	adc	r18, r18
    3b22:	22 27       	eor	r18, r18
    3b24:	22 1f       	adc	r18, r18
    3b26:	93 81       	ldd	r25, Z+3	; 0x03
    3b28:	89 2f       	mov	r24, r25
    3b2a:	88 0f       	add	r24, r24
    3b2c:	82 2b       	or	r24, r18
    3b2e:	28 2f       	mov	r18, r24
    3b30:	30 e0       	ldi	r19, 0x00	; 0
    3b32:	99 1f       	adc	r25, r25
    3b34:	99 27       	eor	r25, r25
    3b36:	99 1f       	adc	r25, r25
    3b38:	11 96       	adiw	r26, 0x01	; 1
    3b3a:	9c 93       	st	X, r25
    3b3c:	11 97       	sbiw	r26, 0x01	; 1
    3b3e:	21 15       	cp	r18, r1
    3b40:	31 05       	cpc	r19, r1
    3b42:	a9 f5       	brne	.+106    	; 0x3bae <__unpack_f+0x9e>
    3b44:	41 15       	cp	r20, r1
    3b46:	51 05       	cpc	r21, r1
    3b48:	61 05       	cpc	r22, r1
    3b4a:	71 05       	cpc	r23, r1
    3b4c:	11 f4       	brne	.+4      	; 0x3b52 <__unpack_f+0x42>
    3b4e:	82 e0       	ldi	r24, 0x02	; 2
    3b50:	37 c0       	rjmp	.+110    	; 0x3bc0 <__unpack_f+0xb0>
    3b52:	82 e8       	ldi	r24, 0x82	; 130
    3b54:	9f ef       	ldi	r25, 0xFF	; 255
    3b56:	13 96       	adiw	r26, 0x03	; 3
    3b58:	9c 93       	st	X, r25
    3b5a:	8e 93       	st	-X, r24
    3b5c:	12 97       	sbiw	r26, 0x02	; 2
    3b5e:	9a 01       	movw	r18, r20
    3b60:	ab 01       	movw	r20, r22
    3b62:	67 e0       	ldi	r22, 0x07	; 7
    3b64:	22 0f       	add	r18, r18
    3b66:	33 1f       	adc	r19, r19
    3b68:	44 1f       	adc	r20, r20
    3b6a:	55 1f       	adc	r21, r21
    3b6c:	6a 95       	dec	r22
    3b6e:	d1 f7       	brne	.-12     	; 0x3b64 <__unpack_f+0x54>
    3b70:	83 e0       	ldi	r24, 0x03	; 3
    3b72:	8c 93       	st	X, r24
    3b74:	0d c0       	rjmp	.+26     	; 0x3b90 <__unpack_f+0x80>
    3b76:	22 0f       	add	r18, r18
    3b78:	33 1f       	adc	r19, r19
    3b7a:	44 1f       	adc	r20, r20
    3b7c:	55 1f       	adc	r21, r21
    3b7e:	12 96       	adiw	r26, 0x02	; 2
    3b80:	8d 91       	ld	r24, X+
    3b82:	9c 91       	ld	r25, X
    3b84:	13 97       	sbiw	r26, 0x03	; 3
    3b86:	01 97       	sbiw	r24, 0x01	; 1
    3b88:	13 96       	adiw	r26, 0x03	; 3
    3b8a:	9c 93       	st	X, r25
    3b8c:	8e 93       	st	-X, r24
    3b8e:	12 97       	sbiw	r26, 0x02	; 2
    3b90:	20 30       	cpi	r18, 0x00	; 0
    3b92:	80 e0       	ldi	r24, 0x00	; 0
    3b94:	38 07       	cpc	r19, r24
    3b96:	80 e0       	ldi	r24, 0x00	; 0
    3b98:	48 07       	cpc	r20, r24
    3b9a:	80 e4       	ldi	r24, 0x40	; 64
    3b9c:	58 07       	cpc	r21, r24
    3b9e:	58 f3       	brcs	.-42     	; 0x3b76 <__unpack_f+0x66>
    3ba0:	14 96       	adiw	r26, 0x04	; 4
    3ba2:	2d 93       	st	X+, r18
    3ba4:	3d 93       	st	X+, r19
    3ba6:	4d 93       	st	X+, r20
    3ba8:	5c 93       	st	X, r21
    3baa:	17 97       	sbiw	r26, 0x07	; 7
    3bac:	08 95       	ret
    3bae:	2f 3f       	cpi	r18, 0xFF	; 255
    3bb0:	31 05       	cpc	r19, r1
    3bb2:	79 f4       	brne	.+30     	; 0x3bd2 <__unpack_f+0xc2>
    3bb4:	41 15       	cp	r20, r1
    3bb6:	51 05       	cpc	r21, r1
    3bb8:	61 05       	cpc	r22, r1
    3bba:	71 05       	cpc	r23, r1
    3bbc:	19 f4       	brne	.+6      	; 0x3bc4 <__unpack_f+0xb4>
    3bbe:	84 e0       	ldi	r24, 0x04	; 4
    3bc0:	8c 93       	st	X, r24
    3bc2:	08 95       	ret
    3bc4:	64 ff       	sbrs	r22, 4
    3bc6:	03 c0       	rjmp	.+6      	; 0x3bce <__unpack_f+0xbe>
    3bc8:	81 e0       	ldi	r24, 0x01	; 1
    3bca:	8c 93       	st	X, r24
    3bcc:	12 c0       	rjmp	.+36     	; 0x3bf2 <__unpack_f+0xe2>
    3bce:	1c 92       	st	X, r1
    3bd0:	10 c0       	rjmp	.+32     	; 0x3bf2 <__unpack_f+0xe2>
    3bd2:	2f 57       	subi	r18, 0x7F	; 127
    3bd4:	30 40       	sbci	r19, 0x00	; 0
    3bd6:	13 96       	adiw	r26, 0x03	; 3
    3bd8:	3c 93       	st	X, r19
    3bda:	2e 93       	st	-X, r18
    3bdc:	12 97       	sbiw	r26, 0x02	; 2
    3bde:	83 e0       	ldi	r24, 0x03	; 3
    3be0:	8c 93       	st	X, r24
    3be2:	87 e0       	ldi	r24, 0x07	; 7
    3be4:	44 0f       	add	r20, r20
    3be6:	55 1f       	adc	r21, r21
    3be8:	66 1f       	adc	r22, r22
    3bea:	77 1f       	adc	r23, r23
    3bec:	8a 95       	dec	r24
    3bee:	d1 f7       	brne	.-12     	; 0x3be4 <__unpack_f+0xd4>
    3bf0:	70 64       	ori	r23, 0x40	; 64
    3bf2:	14 96       	adiw	r26, 0x04	; 4
    3bf4:	4d 93       	st	X+, r20
    3bf6:	5d 93       	st	X+, r21
    3bf8:	6d 93       	st	X+, r22
    3bfa:	7c 93       	st	X, r23
    3bfc:	17 97       	sbiw	r26, 0x07	; 7
    3bfe:	08 95       	ret

00003c00 <__fpcmp_parts_f>:
    3c00:	1f 93       	push	r17
    3c02:	dc 01       	movw	r26, r24
    3c04:	fb 01       	movw	r30, r22
    3c06:	9c 91       	ld	r25, X
    3c08:	92 30       	cpi	r25, 0x02	; 2
    3c0a:	08 f4       	brcc	.+2      	; 0x3c0e <__fpcmp_parts_f+0xe>
    3c0c:	47 c0       	rjmp	.+142    	; 0x3c9c <__fpcmp_parts_f+0x9c>
    3c0e:	80 81       	ld	r24, Z
    3c10:	82 30       	cpi	r24, 0x02	; 2
    3c12:	08 f4       	brcc	.+2      	; 0x3c16 <__fpcmp_parts_f+0x16>
    3c14:	43 c0       	rjmp	.+134    	; 0x3c9c <__fpcmp_parts_f+0x9c>
    3c16:	94 30       	cpi	r25, 0x04	; 4
    3c18:	51 f4       	brne	.+20     	; 0x3c2e <__fpcmp_parts_f+0x2e>
    3c1a:	11 96       	adiw	r26, 0x01	; 1
    3c1c:	1c 91       	ld	r17, X
    3c1e:	84 30       	cpi	r24, 0x04	; 4
    3c20:	99 f5       	brne	.+102    	; 0x3c88 <__fpcmp_parts_f+0x88>
    3c22:	81 81       	ldd	r24, Z+1	; 0x01
    3c24:	68 2f       	mov	r22, r24
    3c26:	70 e0       	ldi	r23, 0x00	; 0
    3c28:	61 1b       	sub	r22, r17
    3c2a:	71 09       	sbc	r23, r1
    3c2c:	3f c0       	rjmp	.+126    	; 0x3cac <__fpcmp_parts_f+0xac>
    3c2e:	84 30       	cpi	r24, 0x04	; 4
    3c30:	21 f0       	breq	.+8      	; 0x3c3a <__fpcmp_parts_f+0x3a>
    3c32:	92 30       	cpi	r25, 0x02	; 2
    3c34:	31 f4       	brne	.+12     	; 0x3c42 <__fpcmp_parts_f+0x42>
    3c36:	82 30       	cpi	r24, 0x02	; 2
    3c38:	b9 f1       	breq	.+110    	; 0x3ca8 <__fpcmp_parts_f+0xa8>
    3c3a:	81 81       	ldd	r24, Z+1	; 0x01
    3c3c:	88 23       	and	r24, r24
    3c3e:	89 f1       	breq	.+98     	; 0x3ca2 <__fpcmp_parts_f+0xa2>
    3c40:	2d c0       	rjmp	.+90     	; 0x3c9c <__fpcmp_parts_f+0x9c>
    3c42:	11 96       	adiw	r26, 0x01	; 1
    3c44:	1c 91       	ld	r17, X
    3c46:	11 97       	sbiw	r26, 0x01	; 1
    3c48:	82 30       	cpi	r24, 0x02	; 2
    3c4a:	f1 f0       	breq	.+60     	; 0x3c88 <__fpcmp_parts_f+0x88>
    3c4c:	81 81       	ldd	r24, Z+1	; 0x01
    3c4e:	18 17       	cp	r17, r24
    3c50:	d9 f4       	brne	.+54     	; 0x3c88 <__fpcmp_parts_f+0x88>
    3c52:	12 96       	adiw	r26, 0x02	; 2
    3c54:	2d 91       	ld	r18, X+
    3c56:	3c 91       	ld	r19, X
    3c58:	13 97       	sbiw	r26, 0x03	; 3
    3c5a:	82 81       	ldd	r24, Z+2	; 0x02
    3c5c:	93 81       	ldd	r25, Z+3	; 0x03
    3c5e:	82 17       	cp	r24, r18
    3c60:	93 07       	cpc	r25, r19
    3c62:	94 f0       	brlt	.+36     	; 0x3c88 <__fpcmp_parts_f+0x88>
    3c64:	28 17       	cp	r18, r24
    3c66:	39 07       	cpc	r19, r25
    3c68:	bc f0       	brlt	.+46     	; 0x3c98 <__fpcmp_parts_f+0x98>
    3c6a:	14 96       	adiw	r26, 0x04	; 4
    3c6c:	8d 91       	ld	r24, X+
    3c6e:	9d 91       	ld	r25, X+
    3c70:	0d 90       	ld	r0, X+
    3c72:	bc 91       	ld	r27, X
    3c74:	a0 2d       	mov	r26, r0
    3c76:	24 81       	ldd	r18, Z+4	; 0x04
    3c78:	35 81       	ldd	r19, Z+5	; 0x05
    3c7a:	46 81       	ldd	r20, Z+6	; 0x06
    3c7c:	57 81       	ldd	r21, Z+7	; 0x07
    3c7e:	28 17       	cp	r18, r24
    3c80:	39 07       	cpc	r19, r25
    3c82:	4a 07       	cpc	r20, r26
    3c84:	5b 07       	cpc	r21, r27
    3c86:	18 f4       	brcc	.+6      	; 0x3c8e <__fpcmp_parts_f+0x8e>
    3c88:	11 23       	and	r17, r17
    3c8a:	41 f0       	breq	.+16     	; 0x3c9c <__fpcmp_parts_f+0x9c>
    3c8c:	0a c0       	rjmp	.+20     	; 0x3ca2 <__fpcmp_parts_f+0xa2>
    3c8e:	82 17       	cp	r24, r18
    3c90:	93 07       	cpc	r25, r19
    3c92:	a4 07       	cpc	r26, r20
    3c94:	b5 07       	cpc	r27, r21
    3c96:	40 f4       	brcc	.+16     	; 0x3ca8 <__fpcmp_parts_f+0xa8>
    3c98:	11 23       	and	r17, r17
    3c9a:	19 f0       	breq	.+6      	; 0x3ca2 <__fpcmp_parts_f+0xa2>
    3c9c:	61 e0       	ldi	r22, 0x01	; 1
    3c9e:	70 e0       	ldi	r23, 0x00	; 0
    3ca0:	05 c0       	rjmp	.+10     	; 0x3cac <__fpcmp_parts_f+0xac>
    3ca2:	6f ef       	ldi	r22, 0xFF	; 255
    3ca4:	7f ef       	ldi	r23, 0xFF	; 255
    3ca6:	02 c0       	rjmp	.+4      	; 0x3cac <__fpcmp_parts_f+0xac>
    3ca8:	60 e0       	ldi	r22, 0x00	; 0
    3caa:	70 e0       	ldi	r23, 0x00	; 0
    3cac:	cb 01       	movw	r24, r22
    3cae:	1f 91       	pop	r17
    3cb0:	08 95       	ret

00003cb2 <memcpy>:
    3cb2:	fb 01       	movw	r30, r22
    3cb4:	dc 01       	movw	r26, r24
    3cb6:	02 c0       	rjmp	.+4      	; 0x3cbc <memcpy+0xa>
    3cb8:	01 90       	ld	r0, Z+
    3cba:	0d 92       	st	X+, r0
    3cbc:	41 50       	subi	r20, 0x01	; 1
    3cbe:	50 40       	sbci	r21, 0x00	; 0
    3cc0:	d8 f7       	brcc	.-10     	; 0x3cb8 <memcpy+0x6>
    3cc2:	08 95       	ret

00003cc4 <memset>:
    3cc4:	dc 01       	movw	r26, r24
    3cc6:	01 c0       	rjmp	.+2      	; 0x3cca <memset+0x6>
    3cc8:	6d 93       	st	X+, r22
    3cca:	41 50       	subi	r20, 0x01	; 1
    3ccc:	50 40       	sbci	r21, 0x00	; 0
    3cce:	e0 f7       	brcc	.-8      	; 0x3cc8 <memset+0x4>
    3cd0:	08 95       	ret

00003cd2 <strcpy>:
    3cd2:	fb 01       	movw	r30, r22
    3cd4:	dc 01       	movw	r26, r24
    3cd6:	01 90       	ld	r0, Z+
    3cd8:	0d 92       	st	X+, r0
    3cda:	00 20       	and	r0, r0
    3cdc:	e1 f7       	brne	.-8      	; 0x3cd6 <strcpy+0x4>
    3cde:	08 95       	ret

00003ce0 <fdevopen>:
    3ce0:	0f 93       	push	r16
    3ce2:	1f 93       	push	r17
    3ce4:	cf 93       	push	r28
    3ce6:	df 93       	push	r29
    3ce8:	8c 01       	movw	r16, r24
    3cea:	eb 01       	movw	r28, r22
    3cec:	00 97       	sbiw	r24, 0x00	; 0
    3cee:	31 f4       	brne	.+12     	; 0x3cfc <fdevopen+0x1c>
    3cf0:	61 15       	cp	r22, r1
    3cf2:	71 05       	cpc	r23, r1
    3cf4:	19 f4       	brne	.+6      	; 0x3cfc <fdevopen+0x1c>
    3cf6:	20 e0       	ldi	r18, 0x00	; 0
    3cf8:	30 e0       	ldi	r19, 0x00	; 0
    3cfa:	38 c0       	rjmp	.+112    	; 0x3d6c <fdevopen+0x8c>
    3cfc:	81 e0       	ldi	r24, 0x01	; 1
    3cfe:	90 e0       	ldi	r25, 0x00	; 0
    3d00:	6e e0       	ldi	r22, 0x0E	; 14
    3d02:	70 e0       	ldi	r23, 0x00	; 0
    3d04:	0e 94 07 21 	call	0x420e	; 0x420e <calloc>
    3d08:	fc 01       	movw	r30, r24
    3d0a:	9c 01       	movw	r18, r24
    3d0c:	00 97       	sbiw	r24, 0x00	; 0
    3d0e:	71 f1       	breq	.+92     	; 0x3d6c <fdevopen+0x8c>
    3d10:	80 e8       	ldi	r24, 0x80	; 128
    3d12:	83 83       	std	Z+3, r24	; 0x03
    3d14:	20 97       	sbiw	r28, 0x00	; 0
    3d16:	71 f0       	breq	.+28     	; 0x3d34 <fdevopen+0x54>
    3d18:	d3 87       	std	Z+11, r29	; 0x0b
    3d1a:	c2 87       	std	Z+10, r28	; 0x0a
    3d1c:	81 e8       	ldi	r24, 0x81	; 129
    3d1e:	83 83       	std	Z+3, r24	; 0x03
    3d20:	80 91 30 06 	lds	r24, 0x0630
    3d24:	90 91 31 06 	lds	r25, 0x0631
    3d28:	89 2b       	or	r24, r25
    3d2a:	21 f4       	brne	.+8      	; 0x3d34 <fdevopen+0x54>
    3d2c:	f0 93 31 06 	sts	0x0631, r31
    3d30:	e0 93 30 06 	sts	0x0630, r30
    3d34:	01 15       	cp	r16, r1
    3d36:	11 05       	cpc	r17, r1
    3d38:	c9 f0       	breq	.+50     	; 0x3d6c <fdevopen+0x8c>
    3d3a:	11 87       	std	Z+9, r17	; 0x09
    3d3c:	00 87       	std	Z+8, r16	; 0x08
    3d3e:	83 81       	ldd	r24, Z+3	; 0x03
    3d40:	82 60       	ori	r24, 0x02	; 2
    3d42:	83 83       	std	Z+3, r24	; 0x03
    3d44:	80 91 32 06 	lds	r24, 0x0632
    3d48:	90 91 33 06 	lds	r25, 0x0633
    3d4c:	89 2b       	or	r24, r25
    3d4e:	71 f4       	brne	.+28     	; 0x3d6c <fdevopen+0x8c>
    3d50:	f0 93 33 06 	sts	0x0633, r31
    3d54:	e0 93 32 06 	sts	0x0632, r30
    3d58:	80 91 34 06 	lds	r24, 0x0634
    3d5c:	90 91 35 06 	lds	r25, 0x0635
    3d60:	89 2b       	or	r24, r25
    3d62:	21 f4       	brne	.+8      	; 0x3d6c <fdevopen+0x8c>
    3d64:	f0 93 35 06 	sts	0x0635, r31
    3d68:	e0 93 34 06 	sts	0x0634, r30
    3d6c:	c9 01       	movw	r24, r18
    3d6e:	df 91       	pop	r29
    3d70:	cf 91       	pop	r28
    3d72:	1f 91       	pop	r17
    3d74:	0f 91       	pop	r16
    3d76:	08 95       	ret

00003d78 <printf>:
    3d78:	a0 e0       	ldi	r26, 0x00	; 0
    3d7a:	b0 e0       	ldi	r27, 0x00	; 0
    3d7c:	e2 ec       	ldi	r30, 0xC2	; 194
    3d7e:	fe e1       	ldi	r31, 0x1E	; 30
    3d80:	0c 94 d5 22 	jmp	0x45aa	; 0x45aa <__prologue_saves__+0x20>
    3d84:	fe 01       	movw	r30, r28
    3d86:	35 96       	adiw	r30, 0x05	; 5
    3d88:	61 91       	ld	r22, Z+
    3d8a:	71 91       	ld	r23, Z+
    3d8c:	80 91 32 06 	lds	r24, 0x0632
    3d90:	90 91 33 06 	lds	r25, 0x0633
    3d94:	af 01       	movw	r20, r30
    3d96:	0e 94 2a 1f 	call	0x3e54	; 0x3e54 <vfprintf>
    3d9a:	20 96       	adiw	r28, 0x00	; 0
    3d9c:	e2 e0       	ldi	r30, 0x02	; 2
    3d9e:	0c 94 f1 22 	jmp	0x45e2	; 0x45e2 <__epilogue_restores__+0x20>

00003da2 <puts>:
    3da2:	0f 93       	push	r16
    3da4:	1f 93       	push	r17
    3da6:	cf 93       	push	r28
    3da8:	df 93       	push	r29
    3daa:	8c 01       	movw	r16, r24
    3dac:	e0 91 32 06 	lds	r30, 0x0632
    3db0:	f0 91 33 06 	lds	r31, 0x0633
    3db4:	83 81       	ldd	r24, Z+3	; 0x03
    3db6:	81 ff       	sbrs	r24, 1
    3db8:	21 c0       	rjmp	.+66     	; 0x3dfc <puts+0x5a>
    3dba:	c0 e0       	ldi	r28, 0x00	; 0
    3dbc:	d0 e0       	ldi	r29, 0x00	; 0
    3dbe:	0d c0       	rjmp	.+26     	; 0x3dda <puts+0x38>
    3dc0:	e0 91 32 06 	lds	r30, 0x0632
    3dc4:	f0 91 33 06 	lds	r31, 0x0633
    3dc8:	20 85       	ldd	r18, Z+8	; 0x08
    3dca:	31 85       	ldd	r19, Z+9	; 0x09
    3dcc:	bf 01       	movw	r22, r30
    3dce:	f9 01       	movw	r30, r18
    3dd0:	09 95       	icall
    3dd2:	89 2b       	or	r24, r25
    3dd4:	11 f0       	breq	.+4      	; 0x3dda <puts+0x38>
    3dd6:	cf ef       	ldi	r28, 0xFF	; 255
    3dd8:	df ef       	ldi	r29, 0xFF	; 255
    3dda:	f8 01       	movw	r30, r16
    3ddc:	81 91       	ld	r24, Z+
    3dde:	8f 01       	movw	r16, r30
    3de0:	88 23       	and	r24, r24
    3de2:	71 f7       	brne	.-36     	; 0x3dc0 <puts+0x1e>
    3de4:	e0 91 32 06 	lds	r30, 0x0632
    3de8:	f0 91 33 06 	lds	r31, 0x0633
    3dec:	20 85       	ldd	r18, Z+8	; 0x08
    3dee:	31 85       	ldd	r19, Z+9	; 0x09
    3df0:	8a e0       	ldi	r24, 0x0A	; 10
    3df2:	bf 01       	movw	r22, r30
    3df4:	f9 01       	movw	r30, r18
    3df6:	09 95       	icall
    3df8:	89 2b       	or	r24, r25
    3dfa:	11 f0       	breq	.+4      	; 0x3e00 <puts+0x5e>
    3dfc:	cf ef       	ldi	r28, 0xFF	; 255
    3dfe:	df ef       	ldi	r29, 0xFF	; 255
    3e00:	ce 01       	movw	r24, r28
    3e02:	df 91       	pop	r29
    3e04:	cf 91       	pop	r28
    3e06:	1f 91       	pop	r17
    3e08:	0f 91       	pop	r16
    3e0a:	08 95       	ret

00003e0c <sprintf>:
    3e0c:	ae e0       	ldi	r26, 0x0E	; 14
    3e0e:	b0 e0       	ldi	r27, 0x00	; 0
    3e10:	ec e0       	ldi	r30, 0x0C	; 12
    3e12:	ff e1       	ldi	r31, 0x1F	; 31
    3e14:	0c 94 d3 22 	jmp	0x45a6	; 0x45a6 <__prologue_saves__+0x1c>
    3e18:	0d 89       	ldd	r16, Y+21	; 0x15
    3e1a:	1e 89       	ldd	r17, Y+22	; 0x16
    3e1c:	86 e0       	ldi	r24, 0x06	; 6
    3e1e:	8c 83       	std	Y+4, r24	; 0x04
    3e20:	1a 83       	std	Y+2, r17	; 0x02
    3e22:	09 83       	std	Y+1, r16	; 0x01
    3e24:	8f ef       	ldi	r24, 0xFF	; 255
    3e26:	9f e7       	ldi	r25, 0x7F	; 127
    3e28:	9e 83       	std	Y+6, r25	; 0x06
    3e2a:	8d 83       	std	Y+5, r24	; 0x05
    3e2c:	9e 01       	movw	r18, r28
    3e2e:	27 5e       	subi	r18, 0xE7	; 231
    3e30:	3f 4f       	sbci	r19, 0xFF	; 255
    3e32:	ce 01       	movw	r24, r28
    3e34:	01 96       	adiw	r24, 0x01	; 1
    3e36:	6f 89       	ldd	r22, Y+23	; 0x17
    3e38:	78 8d       	ldd	r23, Y+24	; 0x18
    3e3a:	a9 01       	movw	r20, r18
    3e3c:	0e 94 2a 1f 	call	0x3e54	; 0x3e54 <vfprintf>
    3e40:	2f 81       	ldd	r18, Y+7	; 0x07
    3e42:	38 85       	ldd	r19, Y+8	; 0x08
    3e44:	02 0f       	add	r16, r18
    3e46:	13 1f       	adc	r17, r19
    3e48:	f8 01       	movw	r30, r16
    3e4a:	10 82       	st	Z, r1
    3e4c:	2e 96       	adiw	r28, 0x0e	; 14
    3e4e:	e4 e0       	ldi	r30, 0x04	; 4
    3e50:	0c 94 ef 22 	jmp	0x45de	; 0x45de <__epilogue_restores__+0x1c>

00003e54 <vfprintf>:
    3e54:	ab e0       	ldi	r26, 0x0B	; 11
    3e56:	b0 e0       	ldi	r27, 0x00	; 0
    3e58:	e0 e3       	ldi	r30, 0x30	; 48
    3e5a:	ff e1       	ldi	r31, 0x1F	; 31
    3e5c:	0c 94 c5 22 	jmp	0x458a	; 0x458a <__prologue_saves__>
    3e60:	3c 01       	movw	r6, r24
    3e62:	2b 01       	movw	r4, r22
    3e64:	5a 01       	movw	r10, r20
    3e66:	fc 01       	movw	r30, r24
    3e68:	17 82       	std	Z+7, r1	; 0x07
    3e6a:	16 82       	std	Z+6, r1	; 0x06
    3e6c:	83 81       	ldd	r24, Z+3	; 0x03
    3e6e:	81 fd       	sbrc	r24, 1
    3e70:	03 c0       	rjmp	.+6      	; 0x3e78 <vfprintf+0x24>
    3e72:	6f ef       	ldi	r22, 0xFF	; 255
    3e74:	7f ef       	ldi	r23, 0xFF	; 255
    3e76:	c6 c1       	rjmp	.+908    	; 0x4204 <vfprintf+0x3b0>
    3e78:	9a e0       	ldi	r25, 0x0A	; 10
    3e7a:	89 2e       	mov	r8, r25
    3e7c:	1e 01       	movw	r2, r28
    3e7e:	08 94       	sec
    3e80:	21 1c       	adc	r2, r1
    3e82:	31 1c       	adc	r3, r1
    3e84:	f3 01       	movw	r30, r6
    3e86:	23 81       	ldd	r18, Z+3	; 0x03
    3e88:	f2 01       	movw	r30, r4
    3e8a:	23 fd       	sbrc	r18, 3
    3e8c:	85 91       	lpm	r24, Z+
    3e8e:	23 ff       	sbrs	r18, 3
    3e90:	81 91       	ld	r24, Z+
    3e92:	2f 01       	movw	r4, r30
    3e94:	88 23       	and	r24, r24
    3e96:	09 f4       	brne	.+2      	; 0x3e9a <vfprintf+0x46>
    3e98:	b2 c1       	rjmp	.+868    	; 0x41fe <vfprintf+0x3aa>
    3e9a:	85 32       	cpi	r24, 0x25	; 37
    3e9c:	39 f4       	brne	.+14     	; 0x3eac <vfprintf+0x58>
    3e9e:	23 fd       	sbrc	r18, 3
    3ea0:	85 91       	lpm	r24, Z+
    3ea2:	23 ff       	sbrs	r18, 3
    3ea4:	81 91       	ld	r24, Z+
    3ea6:	2f 01       	movw	r4, r30
    3ea8:	85 32       	cpi	r24, 0x25	; 37
    3eaa:	29 f4       	brne	.+10     	; 0x3eb6 <vfprintf+0x62>
    3eac:	90 e0       	ldi	r25, 0x00	; 0
    3eae:	b3 01       	movw	r22, r6
    3eb0:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    3eb4:	e7 cf       	rjmp	.-50     	; 0x3e84 <vfprintf+0x30>
    3eb6:	98 2f       	mov	r25, r24
    3eb8:	ff 24       	eor	r15, r15
    3eba:	ee 24       	eor	r14, r14
    3ebc:	99 24       	eor	r9, r9
    3ebe:	ff e1       	ldi	r31, 0x1F	; 31
    3ec0:	ff 15       	cp	r31, r15
    3ec2:	d0 f0       	brcs	.+52     	; 0x3ef8 <vfprintf+0xa4>
    3ec4:	9b 32       	cpi	r25, 0x2B	; 43
    3ec6:	69 f0       	breq	.+26     	; 0x3ee2 <vfprintf+0x8e>
    3ec8:	9c 32       	cpi	r25, 0x2C	; 44
    3eca:	28 f4       	brcc	.+10     	; 0x3ed6 <vfprintf+0x82>
    3ecc:	90 32       	cpi	r25, 0x20	; 32
    3ece:	59 f0       	breq	.+22     	; 0x3ee6 <vfprintf+0x92>
    3ed0:	93 32       	cpi	r25, 0x23	; 35
    3ed2:	91 f4       	brne	.+36     	; 0x3ef8 <vfprintf+0xa4>
    3ed4:	0e c0       	rjmp	.+28     	; 0x3ef2 <vfprintf+0x9e>
    3ed6:	9d 32       	cpi	r25, 0x2D	; 45
    3ed8:	49 f0       	breq	.+18     	; 0x3eec <vfprintf+0x98>
    3eda:	90 33       	cpi	r25, 0x30	; 48
    3edc:	69 f4       	brne	.+26     	; 0x3ef8 <vfprintf+0xa4>
    3ede:	41 e0       	ldi	r20, 0x01	; 1
    3ee0:	24 c0       	rjmp	.+72     	; 0x3f2a <vfprintf+0xd6>
    3ee2:	52 e0       	ldi	r21, 0x02	; 2
    3ee4:	f5 2a       	or	r15, r21
    3ee6:	84 e0       	ldi	r24, 0x04	; 4
    3ee8:	f8 2a       	or	r15, r24
    3eea:	28 c0       	rjmp	.+80     	; 0x3f3c <vfprintf+0xe8>
    3eec:	98 e0       	ldi	r25, 0x08	; 8
    3eee:	f9 2a       	or	r15, r25
    3ef0:	25 c0       	rjmp	.+74     	; 0x3f3c <vfprintf+0xe8>
    3ef2:	e0 e1       	ldi	r30, 0x10	; 16
    3ef4:	fe 2a       	or	r15, r30
    3ef6:	22 c0       	rjmp	.+68     	; 0x3f3c <vfprintf+0xe8>
    3ef8:	f7 fc       	sbrc	r15, 7
    3efa:	29 c0       	rjmp	.+82     	; 0x3f4e <vfprintf+0xfa>
    3efc:	89 2f       	mov	r24, r25
    3efe:	80 53       	subi	r24, 0x30	; 48
    3f00:	8a 30       	cpi	r24, 0x0A	; 10
    3f02:	70 f4       	brcc	.+28     	; 0x3f20 <vfprintf+0xcc>
    3f04:	f6 fe       	sbrs	r15, 6
    3f06:	05 c0       	rjmp	.+10     	; 0x3f12 <vfprintf+0xbe>
    3f08:	98 9c       	mul	r9, r8
    3f0a:	90 2c       	mov	r9, r0
    3f0c:	11 24       	eor	r1, r1
    3f0e:	98 0e       	add	r9, r24
    3f10:	15 c0       	rjmp	.+42     	; 0x3f3c <vfprintf+0xe8>
    3f12:	e8 9c       	mul	r14, r8
    3f14:	e0 2c       	mov	r14, r0
    3f16:	11 24       	eor	r1, r1
    3f18:	e8 0e       	add	r14, r24
    3f1a:	f0 e2       	ldi	r31, 0x20	; 32
    3f1c:	ff 2a       	or	r15, r31
    3f1e:	0e c0       	rjmp	.+28     	; 0x3f3c <vfprintf+0xe8>
    3f20:	9e 32       	cpi	r25, 0x2E	; 46
    3f22:	29 f4       	brne	.+10     	; 0x3f2e <vfprintf+0xda>
    3f24:	f6 fc       	sbrc	r15, 6
    3f26:	6b c1       	rjmp	.+726    	; 0x41fe <vfprintf+0x3aa>
    3f28:	40 e4       	ldi	r20, 0x40	; 64
    3f2a:	f4 2a       	or	r15, r20
    3f2c:	07 c0       	rjmp	.+14     	; 0x3f3c <vfprintf+0xe8>
    3f2e:	9c 36       	cpi	r25, 0x6C	; 108
    3f30:	19 f4       	brne	.+6      	; 0x3f38 <vfprintf+0xe4>
    3f32:	50 e8       	ldi	r21, 0x80	; 128
    3f34:	f5 2a       	or	r15, r21
    3f36:	02 c0       	rjmp	.+4      	; 0x3f3c <vfprintf+0xe8>
    3f38:	98 36       	cpi	r25, 0x68	; 104
    3f3a:	49 f4       	brne	.+18     	; 0x3f4e <vfprintf+0xfa>
    3f3c:	f2 01       	movw	r30, r4
    3f3e:	23 fd       	sbrc	r18, 3
    3f40:	95 91       	lpm	r25, Z+
    3f42:	23 ff       	sbrs	r18, 3
    3f44:	91 91       	ld	r25, Z+
    3f46:	2f 01       	movw	r4, r30
    3f48:	99 23       	and	r25, r25
    3f4a:	09 f0       	breq	.+2      	; 0x3f4e <vfprintf+0xfa>
    3f4c:	b8 cf       	rjmp	.-144    	; 0x3ebe <vfprintf+0x6a>
    3f4e:	89 2f       	mov	r24, r25
    3f50:	85 54       	subi	r24, 0x45	; 69
    3f52:	83 30       	cpi	r24, 0x03	; 3
    3f54:	18 f0       	brcs	.+6      	; 0x3f5c <vfprintf+0x108>
    3f56:	80 52       	subi	r24, 0x20	; 32
    3f58:	83 30       	cpi	r24, 0x03	; 3
    3f5a:	38 f4       	brcc	.+14     	; 0x3f6a <vfprintf+0x116>
    3f5c:	44 e0       	ldi	r20, 0x04	; 4
    3f5e:	50 e0       	ldi	r21, 0x00	; 0
    3f60:	a4 0e       	add	r10, r20
    3f62:	b5 1e       	adc	r11, r21
    3f64:	5f e3       	ldi	r21, 0x3F	; 63
    3f66:	59 83       	std	Y+1, r21	; 0x01
    3f68:	0f c0       	rjmp	.+30     	; 0x3f88 <vfprintf+0x134>
    3f6a:	93 36       	cpi	r25, 0x63	; 99
    3f6c:	31 f0       	breq	.+12     	; 0x3f7a <vfprintf+0x126>
    3f6e:	93 37       	cpi	r25, 0x73	; 115
    3f70:	79 f0       	breq	.+30     	; 0x3f90 <vfprintf+0x13c>
    3f72:	93 35       	cpi	r25, 0x53	; 83
    3f74:	09 f0       	breq	.+2      	; 0x3f78 <vfprintf+0x124>
    3f76:	56 c0       	rjmp	.+172    	; 0x4024 <vfprintf+0x1d0>
    3f78:	20 c0       	rjmp	.+64     	; 0x3fba <vfprintf+0x166>
    3f7a:	f5 01       	movw	r30, r10
    3f7c:	80 81       	ld	r24, Z
    3f7e:	89 83       	std	Y+1, r24	; 0x01
    3f80:	42 e0       	ldi	r20, 0x02	; 2
    3f82:	50 e0       	ldi	r21, 0x00	; 0
    3f84:	a4 0e       	add	r10, r20
    3f86:	b5 1e       	adc	r11, r21
    3f88:	61 01       	movw	r12, r2
    3f8a:	01 e0       	ldi	r16, 0x01	; 1
    3f8c:	10 e0       	ldi	r17, 0x00	; 0
    3f8e:	12 c0       	rjmp	.+36     	; 0x3fb4 <vfprintf+0x160>
    3f90:	f5 01       	movw	r30, r10
    3f92:	c0 80       	ld	r12, Z
    3f94:	d1 80       	ldd	r13, Z+1	; 0x01
    3f96:	f6 fc       	sbrc	r15, 6
    3f98:	03 c0       	rjmp	.+6      	; 0x3fa0 <vfprintf+0x14c>
    3f9a:	6f ef       	ldi	r22, 0xFF	; 255
    3f9c:	7f ef       	ldi	r23, 0xFF	; 255
    3f9e:	02 c0       	rjmp	.+4      	; 0x3fa4 <vfprintf+0x150>
    3fa0:	69 2d       	mov	r22, r9
    3fa2:	70 e0       	ldi	r23, 0x00	; 0
    3fa4:	42 e0       	ldi	r20, 0x02	; 2
    3fa6:	50 e0       	ldi	r21, 0x00	; 0
    3fa8:	a4 0e       	add	r10, r20
    3faa:	b5 1e       	adc	r11, r21
    3fac:	c6 01       	movw	r24, r12
    3fae:	0e 94 30 22 	call	0x4460	; 0x4460 <strnlen>
    3fb2:	8c 01       	movw	r16, r24
    3fb4:	5f e7       	ldi	r21, 0x7F	; 127
    3fb6:	f5 22       	and	r15, r21
    3fb8:	14 c0       	rjmp	.+40     	; 0x3fe2 <vfprintf+0x18e>
    3fba:	f5 01       	movw	r30, r10
    3fbc:	c0 80       	ld	r12, Z
    3fbe:	d1 80       	ldd	r13, Z+1	; 0x01
    3fc0:	f6 fc       	sbrc	r15, 6
    3fc2:	03 c0       	rjmp	.+6      	; 0x3fca <vfprintf+0x176>
    3fc4:	6f ef       	ldi	r22, 0xFF	; 255
    3fc6:	7f ef       	ldi	r23, 0xFF	; 255
    3fc8:	02 c0       	rjmp	.+4      	; 0x3fce <vfprintf+0x17a>
    3fca:	69 2d       	mov	r22, r9
    3fcc:	70 e0       	ldi	r23, 0x00	; 0
    3fce:	42 e0       	ldi	r20, 0x02	; 2
    3fd0:	50 e0       	ldi	r21, 0x00	; 0
    3fd2:	a4 0e       	add	r10, r20
    3fd4:	b5 1e       	adc	r11, r21
    3fd6:	c6 01       	movw	r24, r12
    3fd8:	0e 94 25 22 	call	0x444a	; 0x444a <strnlen_P>
    3fdc:	8c 01       	movw	r16, r24
    3fde:	50 e8       	ldi	r21, 0x80	; 128
    3fe0:	f5 2a       	or	r15, r21
    3fe2:	f3 fe       	sbrs	r15, 3
    3fe4:	07 c0       	rjmp	.+14     	; 0x3ff4 <vfprintf+0x1a0>
    3fe6:	1a c0       	rjmp	.+52     	; 0x401c <vfprintf+0x1c8>
    3fe8:	80 e2       	ldi	r24, 0x20	; 32
    3fea:	90 e0       	ldi	r25, 0x00	; 0
    3fec:	b3 01       	movw	r22, r6
    3fee:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    3ff2:	ea 94       	dec	r14
    3ff4:	8e 2d       	mov	r24, r14
    3ff6:	90 e0       	ldi	r25, 0x00	; 0
    3ff8:	08 17       	cp	r16, r24
    3ffa:	19 07       	cpc	r17, r25
    3ffc:	a8 f3       	brcs	.-22     	; 0x3fe8 <vfprintf+0x194>
    3ffe:	0e c0       	rjmp	.+28     	; 0x401c <vfprintf+0x1c8>
    4000:	f6 01       	movw	r30, r12
    4002:	f7 fc       	sbrc	r15, 7
    4004:	85 91       	lpm	r24, Z+
    4006:	f7 fe       	sbrs	r15, 7
    4008:	81 91       	ld	r24, Z+
    400a:	6f 01       	movw	r12, r30
    400c:	90 e0       	ldi	r25, 0x00	; 0
    400e:	b3 01       	movw	r22, r6
    4010:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    4014:	e1 10       	cpse	r14, r1
    4016:	ea 94       	dec	r14
    4018:	01 50       	subi	r16, 0x01	; 1
    401a:	10 40       	sbci	r17, 0x00	; 0
    401c:	01 15       	cp	r16, r1
    401e:	11 05       	cpc	r17, r1
    4020:	79 f7       	brne	.-34     	; 0x4000 <vfprintf+0x1ac>
    4022:	ea c0       	rjmp	.+468    	; 0x41f8 <vfprintf+0x3a4>
    4024:	94 36       	cpi	r25, 0x64	; 100
    4026:	11 f0       	breq	.+4      	; 0x402c <vfprintf+0x1d8>
    4028:	99 36       	cpi	r25, 0x69	; 105
    402a:	69 f5       	brne	.+90     	; 0x4086 <vfprintf+0x232>
    402c:	f7 fe       	sbrs	r15, 7
    402e:	08 c0       	rjmp	.+16     	; 0x4040 <vfprintf+0x1ec>
    4030:	f5 01       	movw	r30, r10
    4032:	20 81       	ld	r18, Z
    4034:	31 81       	ldd	r19, Z+1	; 0x01
    4036:	42 81       	ldd	r20, Z+2	; 0x02
    4038:	53 81       	ldd	r21, Z+3	; 0x03
    403a:	84 e0       	ldi	r24, 0x04	; 4
    403c:	90 e0       	ldi	r25, 0x00	; 0
    403e:	0a c0       	rjmp	.+20     	; 0x4054 <vfprintf+0x200>
    4040:	f5 01       	movw	r30, r10
    4042:	80 81       	ld	r24, Z
    4044:	91 81       	ldd	r25, Z+1	; 0x01
    4046:	9c 01       	movw	r18, r24
    4048:	44 27       	eor	r20, r20
    404a:	37 fd       	sbrc	r19, 7
    404c:	40 95       	com	r20
    404e:	54 2f       	mov	r21, r20
    4050:	82 e0       	ldi	r24, 0x02	; 2
    4052:	90 e0       	ldi	r25, 0x00	; 0
    4054:	a8 0e       	add	r10, r24
    4056:	b9 1e       	adc	r11, r25
    4058:	9f e6       	ldi	r25, 0x6F	; 111
    405a:	f9 22       	and	r15, r25
    405c:	57 ff       	sbrs	r21, 7
    405e:	09 c0       	rjmp	.+18     	; 0x4072 <vfprintf+0x21e>
    4060:	50 95       	com	r21
    4062:	40 95       	com	r20
    4064:	30 95       	com	r19
    4066:	21 95       	neg	r18
    4068:	3f 4f       	sbci	r19, 0xFF	; 255
    406a:	4f 4f       	sbci	r20, 0xFF	; 255
    406c:	5f 4f       	sbci	r21, 0xFF	; 255
    406e:	e0 e8       	ldi	r30, 0x80	; 128
    4070:	fe 2a       	or	r15, r30
    4072:	ca 01       	movw	r24, r20
    4074:	b9 01       	movw	r22, r18
    4076:	a1 01       	movw	r20, r2
    4078:	2a e0       	ldi	r18, 0x0A	; 10
    407a:	30 e0       	ldi	r19, 0x00	; 0
    407c:	0e 94 67 22 	call	0x44ce	; 0x44ce <__ultoa_invert>
    4080:	d8 2e       	mov	r13, r24
    4082:	d2 18       	sub	r13, r2
    4084:	40 c0       	rjmp	.+128    	; 0x4106 <vfprintf+0x2b2>
    4086:	95 37       	cpi	r25, 0x75	; 117
    4088:	29 f4       	brne	.+10     	; 0x4094 <vfprintf+0x240>
    408a:	1f 2d       	mov	r17, r15
    408c:	1f 7e       	andi	r17, 0xEF	; 239
    408e:	2a e0       	ldi	r18, 0x0A	; 10
    4090:	30 e0       	ldi	r19, 0x00	; 0
    4092:	1d c0       	rjmp	.+58     	; 0x40ce <vfprintf+0x27a>
    4094:	1f 2d       	mov	r17, r15
    4096:	19 7f       	andi	r17, 0xF9	; 249
    4098:	9f 36       	cpi	r25, 0x6F	; 111
    409a:	61 f0       	breq	.+24     	; 0x40b4 <vfprintf+0x260>
    409c:	90 37       	cpi	r25, 0x70	; 112
    409e:	20 f4       	brcc	.+8      	; 0x40a8 <vfprintf+0x254>
    40a0:	98 35       	cpi	r25, 0x58	; 88
    40a2:	09 f0       	breq	.+2      	; 0x40a6 <vfprintf+0x252>
    40a4:	ac c0       	rjmp	.+344    	; 0x41fe <vfprintf+0x3aa>
    40a6:	0f c0       	rjmp	.+30     	; 0x40c6 <vfprintf+0x272>
    40a8:	90 37       	cpi	r25, 0x70	; 112
    40aa:	39 f0       	breq	.+14     	; 0x40ba <vfprintf+0x266>
    40ac:	98 37       	cpi	r25, 0x78	; 120
    40ae:	09 f0       	breq	.+2      	; 0x40b2 <vfprintf+0x25e>
    40b0:	a6 c0       	rjmp	.+332    	; 0x41fe <vfprintf+0x3aa>
    40b2:	04 c0       	rjmp	.+8      	; 0x40bc <vfprintf+0x268>
    40b4:	28 e0       	ldi	r18, 0x08	; 8
    40b6:	30 e0       	ldi	r19, 0x00	; 0
    40b8:	0a c0       	rjmp	.+20     	; 0x40ce <vfprintf+0x27a>
    40ba:	10 61       	ori	r17, 0x10	; 16
    40bc:	14 fd       	sbrc	r17, 4
    40be:	14 60       	ori	r17, 0x04	; 4
    40c0:	20 e1       	ldi	r18, 0x10	; 16
    40c2:	30 e0       	ldi	r19, 0x00	; 0
    40c4:	04 c0       	rjmp	.+8      	; 0x40ce <vfprintf+0x27a>
    40c6:	14 fd       	sbrc	r17, 4
    40c8:	16 60       	ori	r17, 0x06	; 6
    40ca:	20 e1       	ldi	r18, 0x10	; 16
    40cc:	32 e0       	ldi	r19, 0x02	; 2
    40ce:	17 ff       	sbrs	r17, 7
    40d0:	08 c0       	rjmp	.+16     	; 0x40e2 <vfprintf+0x28e>
    40d2:	f5 01       	movw	r30, r10
    40d4:	60 81       	ld	r22, Z
    40d6:	71 81       	ldd	r23, Z+1	; 0x01
    40d8:	82 81       	ldd	r24, Z+2	; 0x02
    40da:	93 81       	ldd	r25, Z+3	; 0x03
    40dc:	44 e0       	ldi	r20, 0x04	; 4
    40de:	50 e0       	ldi	r21, 0x00	; 0
    40e0:	08 c0       	rjmp	.+16     	; 0x40f2 <vfprintf+0x29e>
    40e2:	f5 01       	movw	r30, r10
    40e4:	80 81       	ld	r24, Z
    40e6:	91 81       	ldd	r25, Z+1	; 0x01
    40e8:	bc 01       	movw	r22, r24
    40ea:	80 e0       	ldi	r24, 0x00	; 0
    40ec:	90 e0       	ldi	r25, 0x00	; 0
    40ee:	42 e0       	ldi	r20, 0x02	; 2
    40f0:	50 e0       	ldi	r21, 0x00	; 0
    40f2:	a4 0e       	add	r10, r20
    40f4:	b5 1e       	adc	r11, r21
    40f6:	a1 01       	movw	r20, r2
    40f8:	0e 94 67 22 	call	0x44ce	; 0x44ce <__ultoa_invert>
    40fc:	d8 2e       	mov	r13, r24
    40fe:	d2 18       	sub	r13, r2
    4100:	8f e7       	ldi	r24, 0x7F	; 127
    4102:	f8 2e       	mov	r15, r24
    4104:	f1 22       	and	r15, r17
    4106:	f6 fe       	sbrs	r15, 6
    4108:	0b c0       	rjmp	.+22     	; 0x4120 <vfprintf+0x2cc>
    410a:	5e ef       	ldi	r21, 0xFE	; 254
    410c:	f5 22       	and	r15, r21
    410e:	d9 14       	cp	r13, r9
    4110:	38 f4       	brcc	.+14     	; 0x4120 <vfprintf+0x2cc>
    4112:	f4 fe       	sbrs	r15, 4
    4114:	07 c0       	rjmp	.+14     	; 0x4124 <vfprintf+0x2d0>
    4116:	f2 fc       	sbrc	r15, 2
    4118:	05 c0       	rjmp	.+10     	; 0x4124 <vfprintf+0x2d0>
    411a:	8f ee       	ldi	r24, 0xEF	; 239
    411c:	f8 22       	and	r15, r24
    411e:	02 c0       	rjmp	.+4      	; 0x4124 <vfprintf+0x2d0>
    4120:	1d 2d       	mov	r17, r13
    4122:	01 c0       	rjmp	.+2      	; 0x4126 <vfprintf+0x2d2>
    4124:	19 2d       	mov	r17, r9
    4126:	f4 fe       	sbrs	r15, 4
    4128:	0d c0       	rjmp	.+26     	; 0x4144 <vfprintf+0x2f0>
    412a:	fe 01       	movw	r30, r28
    412c:	ed 0d       	add	r30, r13
    412e:	f1 1d       	adc	r31, r1
    4130:	80 81       	ld	r24, Z
    4132:	80 33       	cpi	r24, 0x30	; 48
    4134:	19 f4       	brne	.+6      	; 0x413c <vfprintf+0x2e8>
    4136:	99 ee       	ldi	r25, 0xE9	; 233
    4138:	f9 22       	and	r15, r25
    413a:	08 c0       	rjmp	.+16     	; 0x414c <vfprintf+0x2f8>
    413c:	1f 5f       	subi	r17, 0xFF	; 255
    413e:	f2 fe       	sbrs	r15, 2
    4140:	05 c0       	rjmp	.+10     	; 0x414c <vfprintf+0x2f8>
    4142:	03 c0       	rjmp	.+6      	; 0x414a <vfprintf+0x2f6>
    4144:	8f 2d       	mov	r24, r15
    4146:	86 78       	andi	r24, 0x86	; 134
    4148:	09 f0       	breq	.+2      	; 0x414c <vfprintf+0x2f8>
    414a:	1f 5f       	subi	r17, 0xFF	; 255
    414c:	0f 2d       	mov	r16, r15
    414e:	f3 fc       	sbrc	r15, 3
    4150:	14 c0       	rjmp	.+40     	; 0x417a <vfprintf+0x326>
    4152:	f0 fe       	sbrs	r15, 0
    4154:	0f c0       	rjmp	.+30     	; 0x4174 <vfprintf+0x320>
    4156:	1e 15       	cp	r17, r14
    4158:	10 f0       	brcs	.+4      	; 0x415e <vfprintf+0x30a>
    415a:	9d 2c       	mov	r9, r13
    415c:	0b c0       	rjmp	.+22     	; 0x4174 <vfprintf+0x320>
    415e:	9d 2c       	mov	r9, r13
    4160:	9e 0c       	add	r9, r14
    4162:	91 1a       	sub	r9, r17
    4164:	1e 2d       	mov	r17, r14
    4166:	06 c0       	rjmp	.+12     	; 0x4174 <vfprintf+0x320>
    4168:	80 e2       	ldi	r24, 0x20	; 32
    416a:	90 e0       	ldi	r25, 0x00	; 0
    416c:	b3 01       	movw	r22, r6
    416e:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    4172:	1f 5f       	subi	r17, 0xFF	; 255
    4174:	1e 15       	cp	r17, r14
    4176:	c0 f3       	brcs	.-16     	; 0x4168 <vfprintf+0x314>
    4178:	04 c0       	rjmp	.+8      	; 0x4182 <vfprintf+0x32e>
    417a:	1e 15       	cp	r17, r14
    417c:	10 f4       	brcc	.+4      	; 0x4182 <vfprintf+0x32e>
    417e:	e1 1a       	sub	r14, r17
    4180:	01 c0       	rjmp	.+2      	; 0x4184 <vfprintf+0x330>
    4182:	ee 24       	eor	r14, r14
    4184:	04 ff       	sbrs	r16, 4
    4186:	0f c0       	rjmp	.+30     	; 0x41a6 <vfprintf+0x352>
    4188:	80 e3       	ldi	r24, 0x30	; 48
    418a:	90 e0       	ldi	r25, 0x00	; 0
    418c:	b3 01       	movw	r22, r6
    418e:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    4192:	02 ff       	sbrs	r16, 2
    4194:	1d c0       	rjmp	.+58     	; 0x41d0 <vfprintf+0x37c>
    4196:	01 fd       	sbrc	r16, 1
    4198:	03 c0       	rjmp	.+6      	; 0x41a0 <vfprintf+0x34c>
    419a:	88 e7       	ldi	r24, 0x78	; 120
    419c:	90 e0       	ldi	r25, 0x00	; 0
    419e:	0e c0       	rjmp	.+28     	; 0x41bc <vfprintf+0x368>
    41a0:	88 e5       	ldi	r24, 0x58	; 88
    41a2:	90 e0       	ldi	r25, 0x00	; 0
    41a4:	0b c0       	rjmp	.+22     	; 0x41bc <vfprintf+0x368>
    41a6:	80 2f       	mov	r24, r16
    41a8:	86 78       	andi	r24, 0x86	; 134
    41aa:	91 f0       	breq	.+36     	; 0x41d0 <vfprintf+0x37c>
    41ac:	01 ff       	sbrs	r16, 1
    41ae:	02 c0       	rjmp	.+4      	; 0x41b4 <vfprintf+0x360>
    41b0:	8b e2       	ldi	r24, 0x2B	; 43
    41b2:	01 c0       	rjmp	.+2      	; 0x41b6 <vfprintf+0x362>
    41b4:	80 e2       	ldi	r24, 0x20	; 32
    41b6:	f7 fc       	sbrc	r15, 7
    41b8:	8d e2       	ldi	r24, 0x2D	; 45
    41ba:	90 e0       	ldi	r25, 0x00	; 0
    41bc:	b3 01       	movw	r22, r6
    41be:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    41c2:	06 c0       	rjmp	.+12     	; 0x41d0 <vfprintf+0x37c>
    41c4:	80 e3       	ldi	r24, 0x30	; 48
    41c6:	90 e0       	ldi	r25, 0x00	; 0
    41c8:	b3 01       	movw	r22, r6
    41ca:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    41ce:	9a 94       	dec	r9
    41d0:	d9 14       	cp	r13, r9
    41d2:	c0 f3       	brcs	.-16     	; 0x41c4 <vfprintf+0x370>
    41d4:	da 94       	dec	r13
    41d6:	f1 01       	movw	r30, r2
    41d8:	ed 0d       	add	r30, r13
    41da:	f1 1d       	adc	r31, r1
    41dc:	80 81       	ld	r24, Z
    41de:	90 e0       	ldi	r25, 0x00	; 0
    41e0:	b3 01       	movw	r22, r6
    41e2:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    41e6:	dd 20       	and	r13, r13
    41e8:	a9 f7       	brne	.-22     	; 0x41d4 <vfprintf+0x380>
    41ea:	06 c0       	rjmp	.+12     	; 0x41f8 <vfprintf+0x3a4>
    41ec:	80 e2       	ldi	r24, 0x20	; 32
    41ee:	90 e0       	ldi	r25, 0x00	; 0
    41f0:	b3 01       	movw	r22, r6
    41f2:	0e 94 3b 22 	call	0x4476	; 0x4476 <fputc>
    41f6:	ea 94       	dec	r14
    41f8:	ee 20       	and	r14, r14
    41fa:	c1 f7       	brne	.-16     	; 0x41ec <vfprintf+0x398>
    41fc:	43 ce       	rjmp	.-890    	; 0x3e84 <vfprintf+0x30>
    41fe:	f3 01       	movw	r30, r6
    4200:	66 81       	ldd	r22, Z+6	; 0x06
    4202:	77 81       	ldd	r23, Z+7	; 0x07
    4204:	cb 01       	movw	r24, r22
    4206:	2b 96       	adiw	r28, 0x0b	; 11
    4208:	e2 e1       	ldi	r30, 0x12	; 18
    420a:	0c 94 e1 22 	jmp	0x45c2	; 0x45c2 <__epilogue_restores__>

0000420e <calloc>:
    420e:	0f 93       	push	r16
    4210:	1f 93       	push	r17
    4212:	cf 93       	push	r28
    4214:	df 93       	push	r29
    4216:	68 9f       	mul	r22, r24
    4218:	80 01       	movw	r16, r0
    421a:	69 9f       	mul	r22, r25
    421c:	10 0d       	add	r17, r0
    421e:	78 9f       	mul	r23, r24
    4220:	10 0d       	add	r17, r0
    4222:	11 24       	eor	r1, r1
    4224:	c8 01       	movw	r24, r16
    4226:	0e 94 23 21 	call	0x4246	; 0x4246 <malloc>
    422a:	ec 01       	movw	r28, r24
    422c:	00 97       	sbiw	r24, 0x00	; 0
    422e:	29 f0       	breq	.+10     	; 0x423a <calloc+0x2c>
    4230:	60 e0       	ldi	r22, 0x00	; 0
    4232:	70 e0       	ldi	r23, 0x00	; 0
    4234:	a8 01       	movw	r20, r16
    4236:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <memset>
    423a:	ce 01       	movw	r24, r28
    423c:	df 91       	pop	r29
    423e:	cf 91       	pop	r28
    4240:	1f 91       	pop	r17
    4242:	0f 91       	pop	r16
    4244:	08 95       	ret

00004246 <malloc>:
    4246:	cf 93       	push	r28
    4248:	df 93       	push	r29
    424a:	bc 01       	movw	r22, r24
    424c:	82 30       	cpi	r24, 0x02	; 2
    424e:	91 05       	cpc	r25, r1
    4250:	10 f4       	brcc	.+4      	; 0x4256 <malloc+0x10>
    4252:	62 e0       	ldi	r22, 0x02	; 2
    4254:	70 e0       	ldi	r23, 0x00	; 0
    4256:	a0 91 38 06 	lds	r26, 0x0638
    425a:	b0 91 39 06 	lds	r27, 0x0639
    425e:	ed 01       	movw	r28, r26
    4260:	e0 e0       	ldi	r30, 0x00	; 0
    4262:	f0 e0       	ldi	r31, 0x00	; 0
    4264:	40 e0       	ldi	r20, 0x00	; 0
    4266:	50 e0       	ldi	r21, 0x00	; 0
    4268:	21 c0       	rjmp	.+66     	; 0x42ac <malloc+0x66>
    426a:	88 81       	ld	r24, Y
    426c:	99 81       	ldd	r25, Y+1	; 0x01
    426e:	86 17       	cp	r24, r22
    4270:	97 07       	cpc	r25, r23
    4272:	69 f4       	brne	.+26     	; 0x428e <malloc+0x48>
    4274:	8a 81       	ldd	r24, Y+2	; 0x02
    4276:	9b 81       	ldd	r25, Y+3	; 0x03
    4278:	30 97       	sbiw	r30, 0x00	; 0
    427a:	19 f0       	breq	.+6      	; 0x4282 <malloc+0x3c>
    427c:	93 83       	std	Z+3, r25	; 0x03
    427e:	82 83       	std	Z+2, r24	; 0x02
    4280:	04 c0       	rjmp	.+8      	; 0x428a <malloc+0x44>
    4282:	90 93 39 06 	sts	0x0639, r25
    4286:	80 93 38 06 	sts	0x0638, r24
    428a:	fe 01       	movw	r30, r28
    428c:	34 c0       	rjmp	.+104    	; 0x42f6 <malloc+0xb0>
    428e:	68 17       	cp	r22, r24
    4290:	79 07       	cpc	r23, r25
    4292:	38 f4       	brcc	.+14     	; 0x42a2 <malloc+0x5c>
    4294:	41 15       	cp	r20, r1
    4296:	51 05       	cpc	r21, r1
    4298:	19 f0       	breq	.+6      	; 0x42a0 <malloc+0x5a>
    429a:	84 17       	cp	r24, r20
    429c:	95 07       	cpc	r25, r21
    429e:	08 f4       	brcc	.+2      	; 0x42a2 <malloc+0x5c>
    42a0:	ac 01       	movw	r20, r24
    42a2:	fe 01       	movw	r30, r28
    42a4:	8a 81       	ldd	r24, Y+2	; 0x02
    42a6:	9b 81       	ldd	r25, Y+3	; 0x03
    42a8:	9c 01       	movw	r18, r24
    42aa:	e9 01       	movw	r28, r18
    42ac:	20 97       	sbiw	r28, 0x00	; 0
    42ae:	e9 f6       	brne	.-70     	; 0x426a <malloc+0x24>
    42b0:	41 15       	cp	r20, r1
    42b2:	51 05       	cpc	r21, r1
    42b4:	a9 f1       	breq	.+106    	; 0x4320 <malloc+0xda>
    42b6:	ca 01       	movw	r24, r20
    42b8:	86 1b       	sub	r24, r22
    42ba:	97 0b       	sbc	r25, r23
    42bc:	04 97       	sbiw	r24, 0x04	; 4
    42be:	08 f4       	brcc	.+2      	; 0x42c2 <malloc+0x7c>
    42c0:	ba 01       	movw	r22, r20
    42c2:	e0 e0       	ldi	r30, 0x00	; 0
    42c4:	f0 e0       	ldi	r31, 0x00	; 0
    42c6:	2a c0       	rjmp	.+84     	; 0x431c <malloc+0xd6>
    42c8:	8d 91       	ld	r24, X+
    42ca:	9c 91       	ld	r25, X
    42cc:	11 97       	sbiw	r26, 0x01	; 1
    42ce:	84 17       	cp	r24, r20
    42d0:	95 07       	cpc	r25, r21
    42d2:	f9 f4       	brne	.+62     	; 0x4312 <malloc+0xcc>
    42d4:	64 17       	cp	r22, r20
    42d6:	75 07       	cpc	r23, r21
    42d8:	81 f4       	brne	.+32     	; 0x42fa <malloc+0xb4>
    42da:	12 96       	adiw	r26, 0x02	; 2
    42dc:	8d 91       	ld	r24, X+
    42de:	9c 91       	ld	r25, X
    42e0:	13 97       	sbiw	r26, 0x03	; 3
    42e2:	30 97       	sbiw	r30, 0x00	; 0
    42e4:	19 f0       	breq	.+6      	; 0x42ec <malloc+0xa6>
    42e6:	93 83       	std	Z+3, r25	; 0x03
    42e8:	82 83       	std	Z+2, r24	; 0x02
    42ea:	04 c0       	rjmp	.+8      	; 0x42f4 <malloc+0xae>
    42ec:	90 93 39 06 	sts	0x0639, r25
    42f0:	80 93 38 06 	sts	0x0638, r24
    42f4:	fd 01       	movw	r30, r26
    42f6:	32 96       	adiw	r30, 0x02	; 2
    42f8:	4c c0       	rjmp	.+152    	; 0x4392 <malloc+0x14c>
    42fa:	ca 01       	movw	r24, r20
    42fc:	86 1b       	sub	r24, r22
    42fe:	97 0b       	sbc	r25, r23
    4300:	fd 01       	movw	r30, r26
    4302:	e8 0f       	add	r30, r24
    4304:	f9 1f       	adc	r31, r25
    4306:	61 93       	st	Z+, r22
    4308:	71 93       	st	Z+, r23
    430a:	02 97       	sbiw	r24, 0x02	; 2
    430c:	8d 93       	st	X+, r24
    430e:	9c 93       	st	X, r25
    4310:	40 c0       	rjmp	.+128    	; 0x4392 <malloc+0x14c>
    4312:	fd 01       	movw	r30, r26
    4314:	82 81       	ldd	r24, Z+2	; 0x02
    4316:	93 81       	ldd	r25, Z+3	; 0x03
    4318:	9c 01       	movw	r18, r24
    431a:	d9 01       	movw	r26, r18
    431c:	10 97       	sbiw	r26, 0x00	; 0
    431e:	a1 f6       	brne	.-88     	; 0x42c8 <malloc+0x82>
    4320:	80 91 36 06 	lds	r24, 0x0636
    4324:	90 91 37 06 	lds	r25, 0x0637
    4328:	89 2b       	or	r24, r25
    432a:	41 f4       	brne	.+16     	; 0x433c <malloc+0xf6>
    432c:	80 91 53 05 	lds	r24, 0x0553
    4330:	90 91 54 05 	lds	r25, 0x0554
    4334:	90 93 37 06 	sts	0x0637, r25
    4338:	80 93 36 06 	sts	0x0636, r24
    433c:	40 91 55 05 	lds	r20, 0x0555
    4340:	50 91 56 05 	lds	r21, 0x0556
    4344:	41 15       	cp	r20, r1
    4346:	51 05       	cpc	r21, r1
    4348:	41 f4       	brne	.+16     	; 0x435a <malloc+0x114>
    434a:	4d b7       	in	r20, 0x3d	; 61
    434c:	5e b7       	in	r21, 0x3e	; 62
    434e:	80 91 51 05 	lds	r24, 0x0551
    4352:	90 91 52 05 	lds	r25, 0x0552
    4356:	48 1b       	sub	r20, r24
    4358:	59 0b       	sbc	r21, r25
    435a:	20 91 36 06 	lds	r18, 0x0636
    435e:	30 91 37 06 	lds	r19, 0x0637
    4362:	ca 01       	movw	r24, r20
    4364:	82 1b       	sub	r24, r18
    4366:	93 0b       	sbc	r25, r19
    4368:	86 17       	cp	r24, r22
    436a:	97 07       	cpc	r25, r23
    436c:	80 f0       	brcs	.+32     	; 0x438e <malloc+0x148>
    436e:	ab 01       	movw	r20, r22
    4370:	4e 5f       	subi	r20, 0xFE	; 254
    4372:	5f 4f       	sbci	r21, 0xFF	; 255
    4374:	84 17       	cp	r24, r20
    4376:	95 07       	cpc	r25, r21
    4378:	50 f0       	brcs	.+20     	; 0x438e <malloc+0x148>
    437a:	42 0f       	add	r20, r18
    437c:	53 1f       	adc	r21, r19
    437e:	50 93 37 06 	sts	0x0637, r21
    4382:	40 93 36 06 	sts	0x0636, r20
    4386:	f9 01       	movw	r30, r18
    4388:	61 93       	st	Z+, r22
    438a:	71 93       	st	Z+, r23
    438c:	02 c0       	rjmp	.+4      	; 0x4392 <malloc+0x14c>
    438e:	e0 e0       	ldi	r30, 0x00	; 0
    4390:	f0 e0       	ldi	r31, 0x00	; 0
    4392:	cf 01       	movw	r24, r30
    4394:	df 91       	pop	r29
    4396:	cf 91       	pop	r28
    4398:	08 95       	ret

0000439a <free>:
    439a:	cf 93       	push	r28
    439c:	df 93       	push	r29
    439e:	00 97       	sbiw	r24, 0x00	; 0
    43a0:	09 f4       	brne	.+2      	; 0x43a4 <free+0xa>
    43a2:	50 c0       	rjmp	.+160    	; 0x4444 <free+0xaa>
    43a4:	ec 01       	movw	r28, r24
    43a6:	22 97       	sbiw	r28, 0x02	; 2
    43a8:	1b 82       	std	Y+3, r1	; 0x03
    43aa:	1a 82       	std	Y+2, r1	; 0x02
    43ac:	a0 91 38 06 	lds	r26, 0x0638
    43b0:	b0 91 39 06 	lds	r27, 0x0639
    43b4:	10 97       	sbiw	r26, 0x00	; 0
    43b6:	09 f1       	breq	.+66     	; 0x43fa <free+0x60>
    43b8:	40 e0       	ldi	r20, 0x00	; 0
    43ba:	50 e0       	ldi	r21, 0x00	; 0
    43bc:	ac 17       	cp	r26, r28
    43be:	bd 07       	cpc	r27, r29
    43c0:	08 f1       	brcs	.+66     	; 0x4404 <free+0x6a>
    43c2:	bb 83       	std	Y+3, r27	; 0x03
    43c4:	aa 83       	std	Y+2, r26	; 0x02
    43c6:	fe 01       	movw	r30, r28
    43c8:	21 91       	ld	r18, Z+
    43ca:	31 91       	ld	r19, Z+
    43cc:	e2 0f       	add	r30, r18
    43ce:	f3 1f       	adc	r31, r19
    43d0:	ae 17       	cp	r26, r30
    43d2:	bf 07       	cpc	r27, r31
    43d4:	79 f4       	brne	.+30     	; 0x43f4 <free+0x5a>
    43d6:	8d 91       	ld	r24, X+
    43d8:	9c 91       	ld	r25, X
    43da:	11 97       	sbiw	r26, 0x01	; 1
    43dc:	28 0f       	add	r18, r24
    43de:	39 1f       	adc	r19, r25
    43e0:	2e 5f       	subi	r18, 0xFE	; 254
    43e2:	3f 4f       	sbci	r19, 0xFF	; 255
    43e4:	39 83       	std	Y+1, r19	; 0x01
    43e6:	28 83       	st	Y, r18
    43e8:	12 96       	adiw	r26, 0x02	; 2
    43ea:	8d 91       	ld	r24, X+
    43ec:	9c 91       	ld	r25, X
    43ee:	13 97       	sbiw	r26, 0x03	; 3
    43f0:	9b 83       	std	Y+3, r25	; 0x03
    43f2:	8a 83       	std	Y+2, r24	; 0x02
    43f4:	41 15       	cp	r20, r1
    43f6:	51 05       	cpc	r21, r1
    43f8:	71 f4       	brne	.+28     	; 0x4416 <free+0x7c>
    43fa:	d0 93 39 06 	sts	0x0639, r29
    43fe:	c0 93 38 06 	sts	0x0638, r28
    4402:	20 c0       	rjmp	.+64     	; 0x4444 <free+0xaa>
    4404:	12 96       	adiw	r26, 0x02	; 2
    4406:	8d 91       	ld	r24, X+
    4408:	9c 91       	ld	r25, X
    440a:	13 97       	sbiw	r26, 0x03	; 3
    440c:	ad 01       	movw	r20, r26
    440e:	00 97       	sbiw	r24, 0x00	; 0
    4410:	11 f0       	breq	.+4      	; 0x4416 <free+0x7c>
    4412:	dc 01       	movw	r26, r24
    4414:	d3 cf       	rjmp	.-90     	; 0x43bc <free+0x22>
    4416:	fa 01       	movw	r30, r20
    4418:	d3 83       	std	Z+3, r29	; 0x03
    441a:	c2 83       	std	Z+2, r28	; 0x02
    441c:	21 91       	ld	r18, Z+
    441e:	31 91       	ld	r19, Z+
    4420:	e2 0f       	add	r30, r18
    4422:	f3 1f       	adc	r31, r19
    4424:	ce 17       	cp	r28, r30
    4426:	df 07       	cpc	r29, r31
    4428:	69 f4       	brne	.+26     	; 0x4444 <free+0xaa>
    442a:	88 81       	ld	r24, Y
    442c:	99 81       	ldd	r25, Y+1	; 0x01
    442e:	28 0f       	add	r18, r24
    4430:	39 1f       	adc	r19, r25
    4432:	2e 5f       	subi	r18, 0xFE	; 254
    4434:	3f 4f       	sbci	r19, 0xFF	; 255
    4436:	fa 01       	movw	r30, r20
    4438:	31 83       	std	Z+1, r19	; 0x01
    443a:	20 83       	st	Z, r18
    443c:	8a 81       	ldd	r24, Y+2	; 0x02
    443e:	9b 81       	ldd	r25, Y+3	; 0x03
    4440:	93 83       	std	Z+3, r25	; 0x03
    4442:	82 83       	std	Z+2, r24	; 0x02
    4444:	df 91       	pop	r29
    4446:	cf 91       	pop	r28
    4448:	08 95       	ret

0000444a <strnlen_P>:
    444a:	fc 01       	movw	r30, r24
    444c:	05 90       	lpm	r0, Z+
    444e:	61 50       	subi	r22, 0x01	; 1
    4450:	70 40       	sbci	r23, 0x00	; 0
    4452:	01 10       	cpse	r0, r1
    4454:	d8 f7       	brcc	.-10     	; 0x444c <strnlen_P+0x2>
    4456:	80 95       	com	r24
    4458:	90 95       	com	r25
    445a:	8e 0f       	add	r24, r30
    445c:	9f 1f       	adc	r25, r31
    445e:	08 95       	ret

00004460 <strnlen>:
    4460:	fc 01       	movw	r30, r24
    4462:	61 50       	subi	r22, 0x01	; 1
    4464:	70 40       	sbci	r23, 0x00	; 0
    4466:	01 90       	ld	r0, Z+
    4468:	01 10       	cpse	r0, r1
    446a:	d8 f7       	brcc	.-10     	; 0x4462 <strnlen+0x2>
    446c:	80 95       	com	r24
    446e:	90 95       	com	r25
    4470:	8e 0f       	add	r24, r30
    4472:	9f 1f       	adc	r25, r31
    4474:	08 95       	ret

00004476 <fputc>:
    4476:	0f 93       	push	r16
    4478:	1f 93       	push	r17
    447a:	cf 93       	push	r28
    447c:	df 93       	push	r29
    447e:	8c 01       	movw	r16, r24
    4480:	eb 01       	movw	r28, r22
    4482:	8b 81       	ldd	r24, Y+3	; 0x03
    4484:	81 ff       	sbrs	r24, 1
    4486:	1b c0       	rjmp	.+54     	; 0x44be <fputc+0x48>
    4488:	82 ff       	sbrs	r24, 2
    448a:	0d c0       	rjmp	.+26     	; 0x44a6 <fputc+0x30>
    448c:	2e 81       	ldd	r18, Y+6	; 0x06
    448e:	3f 81       	ldd	r19, Y+7	; 0x07
    4490:	8c 81       	ldd	r24, Y+4	; 0x04
    4492:	9d 81       	ldd	r25, Y+5	; 0x05
    4494:	28 17       	cp	r18, r24
    4496:	39 07       	cpc	r19, r25
    4498:	64 f4       	brge	.+24     	; 0x44b2 <fputc+0x3c>
    449a:	e8 81       	ld	r30, Y
    449c:	f9 81       	ldd	r31, Y+1	; 0x01
    449e:	01 93       	st	Z+, r16
    44a0:	f9 83       	std	Y+1, r31	; 0x01
    44a2:	e8 83       	st	Y, r30
    44a4:	06 c0       	rjmp	.+12     	; 0x44b2 <fputc+0x3c>
    44a6:	e8 85       	ldd	r30, Y+8	; 0x08
    44a8:	f9 85       	ldd	r31, Y+9	; 0x09
    44aa:	80 2f       	mov	r24, r16
    44ac:	09 95       	icall
    44ae:	89 2b       	or	r24, r25
    44b0:	31 f4       	brne	.+12     	; 0x44be <fputc+0x48>
    44b2:	8e 81       	ldd	r24, Y+6	; 0x06
    44b4:	9f 81       	ldd	r25, Y+7	; 0x07
    44b6:	01 96       	adiw	r24, 0x01	; 1
    44b8:	9f 83       	std	Y+7, r25	; 0x07
    44ba:	8e 83       	std	Y+6, r24	; 0x06
    44bc:	02 c0       	rjmp	.+4      	; 0x44c2 <fputc+0x4c>
    44be:	0f ef       	ldi	r16, 0xFF	; 255
    44c0:	1f ef       	ldi	r17, 0xFF	; 255
    44c2:	c8 01       	movw	r24, r16
    44c4:	df 91       	pop	r29
    44c6:	cf 91       	pop	r28
    44c8:	1f 91       	pop	r17
    44ca:	0f 91       	pop	r16
    44cc:	08 95       	ret

000044ce <__ultoa_invert>:
    44ce:	fa 01       	movw	r30, r20
    44d0:	aa 27       	eor	r26, r26
    44d2:	28 30       	cpi	r18, 0x08	; 8
    44d4:	51 f1       	breq	.+84     	; 0x452a <__ultoa_invert+0x5c>
    44d6:	20 31       	cpi	r18, 0x10	; 16
    44d8:	81 f1       	breq	.+96     	; 0x453a <__ultoa_invert+0x6c>
    44da:	e8 94       	clt
    44dc:	6f 93       	push	r22
    44de:	6e 7f       	andi	r22, 0xFE	; 254
    44e0:	6e 5f       	subi	r22, 0xFE	; 254
    44e2:	7f 4f       	sbci	r23, 0xFF	; 255
    44e4:	8f 4f       	sbci	r24, 0xFF	; 255
    44e6:	9f 4f       	sbci	r25, 0xFF	; 255
    44e8:	af 4f       	sbci	r26, 0xFF	; 255
    44ea:	b1 e0       	ldi	r27, 0x01	; 1
    44ec:	3e d0       	rcall	.+124    	; 0x456a <__ultoa_invert+0x9c>
    44ee:	b4 e0       	ldi	r27, 0x04	; 4
    44f0:	3c d0       	rcall	.+120    	; 0x456a <__ultoa_invert+0x9c>
    44f2:	67 0f       	add	r22, r23
    44f4:	78 1f       	adc	r23, r24
    44f6:	89 1f       	adc	r24, r25
    44f8:	9a 1f       	adc	r25, r26
    44fa:	a1 1d       	adc	r26, r1
    44fc:	68 0f       	add	r22, r24
    44fe:	79 1f       	adc	r23, r25
    4500:	8a 1f       	adc	r24, r26
    4502:	91 1d       	adc	r25, r1
    4504:	a1 1d       	adc	r26, r1
    4506:	6a 0f       	add	r22, r26
    4508:	71 1d       	adc	r23, r1
    450a:	81 1d       	adc	r24, r1
    450c:	91 1d       	adc	r25, r1
    450e:	a1 1d       	adc	r26, r1
    4510:	20 d0       	rcall	.+64     	; 0x4552 <__ultoa_invert+0x84>
    4512:	09 f4       	brne	.+2      	; 0x4516 <__ultoa_invert+0x48>
    4514:	68 94       	set
    4516:	3f 91       	pop	r19
    4518:	2a e0       	ldi	r18, 0x0A	; 10
    451a:	26 9f       	mul	r18, r22
    451c:	11 24       	eor	r1, r1
    451e:	30 19       	sub	r19, r0
    4520:	30 5d       	subi	r19, 0xD0	; 208
    4522:	31 93       	st	Z+, r19
    4524:	de f6       	brtc	.-74     	; 0x44dc <__ultoa_invert+0xe>
    4526:	cf 01       	movw	r24, r30
    4528:	08 95       	ret
    452a:	46 2f       	mov	r20, r22
    452c:	47 70       	andi	r20, 0x07	; 7
    452e:	40 5d       	subi	r20, 0xD0	; 208
    4530:	41 93       	st	Z+, r20
    4532:	b3 e0       	ldi	r27, 0x03	; 3
    4534:	0f d0       	rcall	.+30     	; 0x4554 <__ultoa_invert+0x86>
    4536:	c9 f7       	brne	.-14     	; 0x452a <__ultoa_invert+0x5c>
    4538:	f6 cf       	rjmp	.-20     	; 0x4526 <__ultoa_invert+0x58>
    453a:	46 2f       	mov	r20, r22
    453c:	4f 70       	andi	r20, 0x0F	; 15
    453e:	40 5d       	subi	r20, 0xD0	; 208
    4540:	4a 33       	cpi	r20, 0x3A	; 58
    4542:	18 f0       	brcs	.+6      	; 0x454a <__ultoa_invert+0x7c>
    4544:	49 5d       	subi	r20, 0xD9	; 217
    4546:	31 fd       	sbrc	r19, 1
    4548:	40 52       	subi	r20, 0x20	; 32
    454a:	41 93       	st	Z+, r20
    454c:	02 d0       	rcall	.+4      	; 0x4552 <__ultoa_invert+0x84>
    454e:	a9 f7       	brne	.-22     	; 0x453a <__ultoa_invert+0x6c>
    4550:	ea cf       	rjmp	.-44     	; 0x4526 <__ultoa_invert+0x58>
    4552:	b4 e0       	ldi	r27, 0x04	; 4
    4554:	a6 95       	lsr	r26
    4556:	97 95       	ror	r25
    4558:	87 95       	ror	r24
    455a:	77 95       	ror	r23
    455c:	67 95       	ror	r22
    455e:	ba 95       	dec	r27
    4560:	c9 f7       	brne	.-14     	; 0x4554 <__ultoa_invert+0x86>
    4562:	00 97       	sbiw	r24, 0x00	; 0
    4564:	61 05       	cpc	r22, r1
    4566:	71 05       	cpc	r23, r1
    4568:	08 95       	ret
    456a:	9b 01       	movw	r18, r22
    456c:	ac 01       	movw	r20, r24
    456e:	0a 2e       	mov	r0, r26
    4570:	06 94       	lsr	r0
    4572:	57 95       	ror	r21
    4574:	47 95       	ror	r20
    4576:	37 95       	ror	r19
    4578:	27 95       	ror	r18
    457a:	ba 95       	dec	r27
    457c:	c9 f7       	brne	.-14     	; 0x4570 <__ultoa_invert+0xa2>
    457e:	62 0f       	add	r22, r18
    4580:	73 1f       	adc	r23, r19
    4582:	84 1f       	adc	r24, r20
    4584:	95 1f       	adc	r25, r21
    4586:	a0 1d       	adc	r26, r0
    4588:	08 95       	ret

0000458a <__prologue_saves__>:
    458a:	2f 92       	push	r2
    458c:	3f 92       	push	r3
    458e:	4f 92       	push	r4
    4590:	5f 92       	push	r5
    4592:	6f 92       	push	r6
    4594:	7f 92       	push	r7
    4596:	8f 92       	push	r8
    4598:	9f 92       	push	r9
    459a:	af 92       	push	r10
    459c:	bf 92       	push	r11
    459e:	cf 92       	push	r12
    45a0:	df 92       	push	r13
    45a2:	ef 92       	push	r14
    45a4:	ff 92       	push	r15
    45a6:	0f 93       	push	r16
    45a8:	1f 93       	push	r17
    45aa:	cf 93       	push	r28
    45ac:	df 93       	push	r29
    45ae:	cd b7       	in	r28, 0x3d	; 61
    45b0:	de b7       	in	r29, 0x3e	; 62
    45b2:	ca 1b       	sub	r28, r26
    45b4:	db 0b       	sbc	r29, r27
    45b6:	0f b6       	in	r0, 0x3f	; 63
    45b8:	f8 94       	cli
    45ba:	de bf       	out	0x3e, r29	; 62
    45bc:	0f be       	out	0x3f, r0	; 63
    45be:	cd bf       	out	0x3d, r28	; 61
    45c0:	09 94       	ijmp

000045c2 <__epilogue_restores__>:
    45c2:	2a 88       	ldd	r2, Y+18	; 0x12
    45c4:	39 88       	ldd	r3, Y+17	; 0x11
    45c6:	48 88       	ldd	r4, Y+16	; 0x10
    45c8:	5f 84       	ldd	r5, Y+15	; 0x0f
    45ca:	6e 84       	ldd	r6, Y+14	; 0x0e
    45cc:	7d 84       	ldd	r7, Y+13	; 0x0d
    45ce:	8c 84       	ldd	r8, Y+12	; 0x0c
    45d0:	9b 84       	ldd	r9, Y+11	; 0x0b
    45d2:	aa 84       	ldd	r10, Y+10	; 0x0a
    45d4:	b9 84       	ldd	r11, Y+9	; 0x09
    45d6:	c8 84       	ldd	r12, Y+8	; 0x08
    45d8:	df 80       	ldd	r13, Y+7	; 0x07
    45da:	ee 80       	ldd	r14, Y+6	; 0x06
    45dc:	fd 80       	ldd	r15, Y+5	; 0x05
    45de:	0c 81       	ldd	r16, Y+4	; 0x04
    45e0:	1b 81       	ldd	r17, Y+3	; 0x03
    45e2:	aa 81       	ldd	r26, Y+2	; 0x02
    45e4:	b9 81       	ldd	r27, Y+1	; 0x01
    45e6:	ce 0f       	add	r28, r30
    45e8:	d1 1d       	adc	r29, r1
    45ea:	0f b6       	in	r0, 0x3f	; 63
    45ec:	f8 94       	cli
    45ee:	de bf       	out	0x3e, r29	; 62
    45f0:	0f be       	out	0x3f, r0	; 63
    45f2:	cd bf       	out	0x3d, r28	; 61
    45f4:	ed 01       	movw	r28, r26
    45f6:	08 95       	ret

000045f8 <_exit>:
    45f8:	f8 94       	cli

000045fa <__stop_program>:
    45fa:	ff cf       	rjmp	.-2      	; 0x45fa <__stop_program>


Boot.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d4  00800100  0001fe04  00001e98  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001e04  0001e000  0001e000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001ba  008001d4  008001d4  00001f6c  2**0
                  ALLOC
  3 .debug_aranges 000000c0  00000000  00000000  00001f6c  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000062f  00000000  00000000  0000202c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000029e8  00000000  00000000  0000265b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000093a  00000000  00000000  00005043  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000019df  00000000  00000000  0000597d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000670  00000000  00000000  0000735c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000006cf  00000000  00000000  000079cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001359  00000000  00000000  0000809b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000150  00000000  00000000  000093f4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0001e000 <__vectors>:
   1e000:	0c 94 46 f0 	jmp	0x1e08c	; 0x1e08c <__ctors_end>
   1e004:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e008:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e00c:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e010:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e014:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e018:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e01c:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e020:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e024:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e028:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e02c:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e030:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e034:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e038:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e03c:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e040:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e044:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e048:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e04c:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e050:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e054:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e058:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e05c:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e060:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e064:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e068:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e06c:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e070:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e074:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e078:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e07c:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e080:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e084:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>
   1e088:	0c 94 65 f0 	jmp	0x1e0ca	; 0x1e0ca <__bad_interrupt>

0001e08c <__ctors_end>:
   1e08c:	11 24       	eor	r1, r1
   1e08e:	1f be       	out	0x3f, r1	; 63
   1e090:	cf ef       	ldi	r28, 0xFF	; 255
   1e092:	d0 e1       	ldi	r29, 0x10	; 16
   1e094:	de bf       	out	0x3e, r29	; 62
   1e096:	cd bf       	out	0x3d, r28	; 61

0001e098 <__do_copy_data>:
   1e098:	11 e0       	ldi	r17, 0x01	; 1
   1e09a:	a0 e0       	ldi	r26, 0x00	; 0
   1e09c:	b1 e0       	ldi	r27, 0x01	; 1
   1e09e:	e4 e0       	ldi	r30, 0x04	; 4
   1e0a0:	fe ef       	ldi	r31, 0xFE	; 254
   1e0a2:	01 e0       	ldi	r16, 0x01	; 1
   1e0a4:	0b bf       	out	0x3b, r16	; 59
   1e0a6:	02 c0       	rjmp	.+4      	; 0x1e0ac <__do_copy_data+0x14>
   1e0a8:	07 90       	elpm	r0, Z+
   1e0aa:	0d 92       	st	X+, r0
   1e0ac:	a4 3d       	cpi	r26, 0xD4	; 212
   1e0ae:	b1 07       	cpc	r27, r17
   1e0b0:	d9 f7       	brne	.-10     	; 0x1e0a8 <__do_copy_data+0x10>

0001e0b2 <__do_clear_bss>:
   1e0b2:	13 e0       	ldi	r17, 0x03	; 3
   1e0b4:	a4 ed       	ldi	r26, 0xD4	; 212
   1e0b6:	b1 e0       	ldi	r27, 0x01	; 1
   1e0b8:	01 c0       	rjmp	.+2      	; 0x1e0bc <.do_clear_bss_start>

0001e0ba <.do_clear_bss_loop>:
   1e0ba:	1d 92       	st	X+, r1

0001e0bc <.do_clear_bss_start>:
   1e0bc:	ae 38       	cpi	r26, 0x8E	; 142
   1e0be:	b1 07       	cpc	r27, r17
   1e0c0:	e1 f7       	brne	.-8      	; 0x1e0ba <.do_clear_bss_loop>
   1e0c2:	0e 94 f3 f0 	call	0x1e1e6	; 0x1e1e6 <main>
   1e0c6:	0c 94 00 ff 	jmp	0x1fe00	; 0x1fe00 <_exit>

0001e0ca <__bad_interrupt>:
   1e0ca:	0c 94 00 f0 	jmp	0x1e000	; 0x1e000 <__vectors>

0001e0ce <wait_1us>:

//---- MODIFY_2005_10_31 : PM-A1 V1.1 --> V1.2 (16MHz --> 8MHz)
void wait_1us(unsigned int cnt)
{
	/* 16MHz : 16 CLK 1us : 1 + (1 + (1+1)*4 + 1 + (2+1))*cnt + 1  + 1*/ 
	asm volatile
   1e0ce:	cc 01       	movw	r24, r24

0001e0d0 <L_WUS7>:
   1e0d0:	a4 e0       	ldi	r26, 0x04	; 4

0001e0d2 <L_WUSS7>:
   1e0d2:	aa 95       	dec	r26
   1e0d4:	f1 f7       	brne	.-4      	; 0x1e0d2 <L_WUSS7>
   1e0d6:	01 97       	sbiw	r24, 0x01	; 1
   1e0d8:	d9 f7       	brne	.-10     	; 0x1e0d0 <L_WUS7>
   1e0da:	00 00       	nop
		"brne	L_US"			"\n\t"
		"nop"				"\n\t"
		:  :"r" (cnt)
	);	
	*/
}
   1e0dc:	08 95       	ret

0001e0de <wait_10ms>:

//---- MODIFY_2005_10_31 : PM-A1 V1.1 --> V1.2 (16MHz --> 8MHz)
void wait_1us(unsigned int cnt)
{
	/* 16MHz : 16 CLK 1us : 1 + (1 + (1+1)*4 + 1 + (2+1))*cnt + 1  + 1*/ 
	asm volatile
   1e0de:	48 ee       	ldi	r20, 0xE8	; 232
   1e0e0:	53 e0       	ldi	r21, 0x03	; 3
   1e0e2:	0d c0       	rjmp	.+26     	; 0x1e0fe <L_WUSS38+0x12>
* Note        : Internal Function
********************************************************************************
*/
void wait_10ms(unsigned int cnt)
{
	for (; cnt; cnt--) wait_1ms(10);
   1e0e4:	2a e0       	ldi	r18, 0x0A	; 10
   1e0e6:	30 e0       	ldi	r19, 0x00	; 0

//---- MODIFY_2005_10_31 : PM-A1 V1.1 --> V1.2 (16MHz --> 8MHz)
void wait_1us(unsigned int cnt)
{
	/* 16MHz : 16 CLK 1us : 1 + (1 + (1+1)*4 + 1 + (2+1))*cnt + 1  + 1*/ 
	asm volatile
   1e0e8:	ca 01       	movw	r24, r20

0001e0ea <L_WUS38>:
   1e0ea:	a4 e0       	ldi	r26, 0x04	; 4

0001e0ec <L_WUSS38>:
   1e0ec:	aa 95       	dec	r26
   1e0ee:	f1 f7       	brne	.-4      	; 0x1e0ec <L_WUSS38>
   1e0f0:	01 97       	sbiw	r24, 0x01	; 1
   1e0f2:	d9 f7       	brne	.-10     	; 0x1e0ea <L_WUS38>
   1e0f4:	00 00       	nop
* Note        : Internal Function
********************************************************************************
*/
void wait_1ms(unsigned int cnt)
{
	for (; cnt; cnt--) wait_1us(1000);
   1e0f6:	21 50       	subi	r18, 0x01	; 1
   1e0f8:	30 40       	sbci	r19, 0x00	; 0
   1e0fa:	b1 f7       	brne	.-20     	; 0x1e0e8 <wait_10ms+0xa>
* Note        : Internal Function
********************************************************************************
*/
void wait_10ms(unsigned int cnt)
{
	for (; cnt; cnt--) wait_1ms(10);
   1e0fc:	01 97       	sbiw	r24, 0x01	; 1
   1e0fe:	00 97       	sbiw	r24, 0x00	; 0
   1e100:	89 f7       	brne	.-30     	; 0x1e0e4 <wait_10ms+0x6>
}
   1e102:	08 95       	ret

0001e104 <wait_1ms>:

//---- MODIFY_2005_10_31 : PM-A1 V1.1 --> V1.2 (16MHz --> 8MHz)
void wait_1us(unsigned int cnt)
{
	/* 16MHz : 16 CLK 1us : 1 + (1 + (1+1)*4 + 1 + (2+1))*cnt + 1  + 1*/ 
	asm volatile
   1e104:	28 ee       	ldi	r18, 0xE8	; 232
   1e106:	33 e0       	ldi	r19, 0x03	; 3
   1e108:	08 c0       	rjmp	.+16     	; 0x1e11a <L_WUSS70+0xc>
   1e10a:	c9 01       	movw	r24, r18

0001e10c <L_WUS70>:
   1e10c:	a4 e0       	ldi	r26, 0x04	; 4

0001e10e <L_WUSS70>:
   1e10e:	aa 95       	dec	r26
   1e110:	f1 f7       	brne	.-4      	; 0x1e10e <L_WUSS70>
   1e112:	01 97       	sbiw	r24, 0x01	; 1
   1e114:	d9 f7       	brne	.-10     	; 0x1e10c <L_WUS70>
   1e116:	00 00       	nop
* Note        : Internal Function
********************************************************************************
*/
void wait_1ms(unsigned int cnt)
{
	for (; cnt; cnt--) wait_1us(1000);
   1e118:	01 97       	sbiw	r24, 0x01	; 1
   1e11a:	00 97       	sbiw	r24, 0x00	; 0
   1e11c:	b1 f7       	brne	.-20     	; 0x1e10a <wait_1ms+0x6>
}
   1e11e:	08 95       	ret

0001e120 <SpmCommand>:
   1e120:	fc 01       	movw	r30, r24
   1e122:	03 c0       	rjmp	.+6      	; 0x1e12a <DoSpm>

0001e124 <SpmBufferFill>:
   1e124:	fc 01       	movw	r30, r24
   1e126:	0b 01       	movw	r0, r22
   1e128:	61 e0       	ldi	r22, 0x01	; 1

0001e12a <DoSpm>:
   1e12a:	60 93 68 00 	sts	0x0068, r22
   1e12e:	e8 95       	spm

0001e130 <WaitSpm>:
   1e130:	60 91 68 00 	lds	r22, 0x0068
   1e134:	60 fd       	sbrc	r22, 0
   1e136:	fc cf       	rjmp	.-8      	; 0x1e130 <WaitSpm>
   1e138:	11 24       	eor	r1, r1
   1e13a:	08 95       	ret

0001e13c <eeprom_read_byte>:

/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
   1e13c:	9c 01       	movw	r18, r24
    do {} while (!eeprom_is_ready ());
   1e13e:	e1 99       	sbic	0x1c, 1	; 28
   1e140:	fe cf       	rjmp	.-4      	; 0x1e13e <eeprom_read_byte+0x2>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
   1e142:	3f bb       	out	0x1f, r19	; 31
   1e144:	2e bb       	out	0x1e, r18	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
   1e146:	e0 9a       	sbi	0x1c, 0	; 28
   1e148:	8d b3       	in	r24, 0x1d	; 29
        : "i" (_SFR_IO_ADDR(EECR)),
          "i" (EERE),
          "i" (_SFR_IO_ADDR(EEDR))
    );
    return __result;
}
   1e14a:	08 95       	ret

0001e14c <init_board>:

IGM_INFO ConfigMsg;

void init_board(void)
{
	EICRA=0x00;
   1e14c:	10 92 6a 00 	sts	0x006A, r1
	EICRB=0x00;
   1e150:	1a be       	out	0x3a, r1	; 58
	EIMSK=0x00;
   1e152:	19 be       	out	0x39, r1	; 57
	EIFR=0x00;
   1e154:	18 be       	out	0x38, r1	; 56

	MCUCR |= (1 << SRE);
   1e156:	85 b7       	in	r24, 0x35	; 53
   1e158:	80 68       	ori	r24, 0x80	; 128
   1e15a:	85 bf       	out	0x35, r24	; 53
	XMCRA = (1 << SRL2) | (1 << SRW00) | (1 << SRW11);
   1e15c:	86 e4       	ldi	r24, 0x46	; 70
   1e15e:	80 93 6d 00 	sts	0x006D, r24

	// Low sector   : 0x1100 ~ 0x7FFF	1 wait-state
	// Upper sector : 0x8000 ~ 0xFFFF	2 wait-state

}
   1e162:	08 95       	ret

0001e164 <initNet>:
	unsigned char gw[4];
} StrConfigParam;

StrConfigParam NetworkParam;
void initNet(void)
{
   1e164:	df 93       	push	r29
   1e166:	cf 93       	push	r28
   1e168:	cd b7       	in	r28, 0x3d	; 61
   1e16a:	de b7       	in	r29, 0x3e	; 62
   1e16c:	28 97       	sbiw	r28, 0x08	; 8
   1e16e:	0f b6       	in	r0, 0x3f	; 63
   1e170:	f8 94       	cli
   1e172:	de bf       	out	0x3e, r29	; 62
   1e174:	0f be       	out	0x3f, r0	; 63
   1e176:	cd bf       	out	0x3d, r28	; 61
	unsigned char tx_mem_conf[8] = {8,8,8,8,8,8,8,8};  
   1e178:	de 01       	movw	r26, r28
   1e17a:	11 96       	adiw	r26, 0x01	; 1
   1e17c:	ed e3       	ldi	r30, 0x3D	; 61
   1e17e:	f1 e0       	ldi	r31, 0x01	; 1
   1e180:	88 e0       	ldi	r24, 0x08	; 8
   1e182:	01 90       	ld	r0, Z+
   1e184:	0d 92       	st	X+, r0
   1e186:	81 50       	subi	r24, 0x01	; 1
   1e188:	e1 f7       	brne	.-8      	; 0x1e182 <initNet+0x1e>
//	unsigned char buf[10] = " ";
	
	//W5300 Chip Init
	iinchip_init();
   1e18a:	0e 94 de fb 	call	0x1f7bc	; 0x1f7bc <iinchip_init>
 */
static __inline__ void
eeprom_read_block (void *__dst, const void *__src, size_t __n)
{
#if (! (defined(__AVR_ATmega2560__) || defined(__AVR_ATmega2561__)) )
    __eerd_block (__dst, __src, __n, eeprom_read_byte);
   1e18e:	86 e1       	ldi	r24, 0x16	; 22
   1e190:	92 e0       	ldi	r25, 0x02	; 2
   1e192:	60 e0       	ldi	r22, 0x00	; 0
   1e194:	70 e0       	ldi	r23, 0x00	; 0
   1e196:	48 e1       	ldi	r20, 0x18	; 24
   1e198:	50 e0       	ldi	r21, 0x00	; 0
   1e19a:	2e e9       	ldi	r18, 0x9E	; 158
   1e19c:	30 ef       	ldi	r19, 0xF0	; 240
   1e19e:	0e 94 e6 fb 	call	0x1f7cc	; 0x1f7cc <__eerd_block>
	

	eeprom_read_block(&NetworkParam, (unsigned char*)EEPOP, sizeof(NetworkParam));
	setSHAR(NetworkParam.mac);
   1e1a2:	8c e1       	ldi	r24, 0x1C	; 28
   1e1a4:	92 e0       	ldi	r25, 0x02	; 2
   1e1a6:	0e 94 2d f7 	call	0x1ee5a	; 0x1ee5a <setSHAR>
	setGAR(NetworkParam.gw);
   1e1aa:	8a e2       	ldi	r24, 0x2A	; 42
   1e1ac:	92 e0       	ldi	r25, 0x02	; 2
   1e1ae:	0e 94 45 f7 	call	0x1ee8a	; 0x1ee8a <setGAR>
	setSUBR(NetworkParam.subnet);
   1e1b2:	86 e2       	ldi	r24, 0x26	; 38
   1e1b4:	92 e0       	ldi	r25, 0x02	; 2
   1e1b6:	0e 94 61 f7 	call	0x1eec2	; 0x1eec2 <setSUBR>
	setSIPR(NetworkParam.ip);
   1e1ba:	82 e2       	ldi	r24, 0x22	; 34
   1e1bc:	92 e0       	ldi	r25, 0x02	; 2
   1e1be:	0e 94 7d f7 	call	0x1eefa	; 0x1eefa <setSIPR>
#endif
	
	//sysinit(MY_NET_MEMALLOC, MY_NET_MEMALLOC);

   /* allocate internal TX/RX Memory of W5300 */
   if(!sysinit(tx_mem_conf, tx_mem_conf))           
   1e1c2:	be 01       	movw	r22, r28
   1e1c4:	6f 5f       	subi	r22, 0xFF	; 255
   1e1c6:	7f 4f       	sbci	r23, 0xFF	; 255
   1e1c8:	cb 01       	movw	r24, r22
   1e1ca:	0e 94 d5 fa 	call	0x1f5aa	; 0x1f5aa <sysinit>
   1e1ce:	88 23       	and	r24, r24
   1e1d0:	09 f4       	brne	.+2      	; 0x1e1d4 <initNet+0x70>
   1e1d2:	ff cf       	rjmp	.-2      	; 0x1e1d2 <initNet+0x6e>
   {
      while(1);
   }
}
   1e1d4:	28 96       	adiw	r28, 0x08	; 8
   1e1d6:	0f b6       	in	r0, 0x3f	; 63
   1e1d8:	f8 94       	cli
   1e1da:	de bf       	out	0x3e, r29	; 62
   1e1dc:	0f be       	out	0x3f, r0	; 63
   1e1de:	cd bf       	out	0x3d, r28	; 61
   1e1e0:	cf 91       	pop	r28
   1e1e2:	df 91       	pop	r29
   1e1e4:	08 95       	ret

0001e1e6 <main>:

int main(void)
{
   1e1e6:	0f 93       	push	r16
   1e1e8:	1f 93       	push	r17

IGM_INFO ConfigMsg;

void init_board(void)
{
	EICRA=0x00;
   1e1ea:	10 92 6a 00 	sts	0x006A, r1
	EICRB=0x00;
   1e1ee:	1a be       	out	0x3a, r1	; 58
	EIMSK=0x00;
   1e1f0:	19 be       	out	0x39, r1	; 57
	EIFR=0x00;
   1e1f2:	18 be       	out	0x38, r1	; 56

	MCUCR |= (1 << SRE);
   1e1f4:	85 b7       	in	r24, 0x35	; 53
   1e1f6:	80 68       	ori	r24, 0x80	; 128
   1e1f8:	85 bf       	out	0x35, r24	; 53
	XMCRA = (1 << SRL2) | (1 << SRW00) | (1 << SRW11);
   1e1fa:	86 e4       	ldi	r24, 0x46	; 70
   1e1fc:	80 93 6d 00 	sts	0x006D, r24
}

int main(void)
{
	init_board();
	initUart();
   1e200:	0e 94 97 f6 	call	0x1ed2e	; 0x1ed2e <initUart>
	putStr((unsigned char *)"WIZ-Embedded WebServer\r\nBoot Start\r\n");	
   1e204:	80 e0       	ldi	r24, 0x00	; 0
   1e206:	91 e0       	ldi	r25, 0x01	; 1
   1e208:	0e 94 a4 f6 	call	0x1ed48	; 0x1ed48 <putStr>
	
	initNet();
   1e20c:	0e 94 b2 f0 	call	0x1e164	; 0x1e164 <initNet>
	
	if(loading()==1) {
   1e210:	0e 94 a6 f1 	call	0x1e34c	; 0x1e34c <loading>
   1e214:	01 97       	sbiw	r24, 0x01	; 1
   1e216:	a9 f4       	brne	.+42     	; 0x1e242 <main+0x5c>
		// GOOD

		putStr((unsigned char *)"Write ok\r\n");		
   1e218:	85 e2       	ldi	r24, 0x25	; 37
   1e21a:	91 e0       	ldi	r25, 0x01	; 1
   1e21c:	0e 94 a4 f6 	call	0x1ed48	; 0x1ed48 <putStr>

		((void (*)())0x0000)();		
   1e220:	00 e0       	ldi	r16, 0x00	; 0
   1e222:	10 e0       	ldi	r17, 0x00	; 0
   1e224:	f8 01       	movw	r30, r16
   1e226:	09 95       	icall
		
		GoApp();
   1e228:	85 b7       	in	r24, 0x35	; 53
   1e22a:	81 60       	ori	r24, 0x01	; 1
   1e22c:	85 bf       	out	0x35, r24	; 53
   1e22e:	85 b7       	in	r24, 0x35	; 53
   1e230:	8d 7f       	andi	r24, 0xFD	; 253
   1e232:	85 bf       	out	0x35, r24	; 53
   1e234:	f8 01       	movw	r30, r16
   1e236:	09 95       	icall
		putStr((unsigned char *)"Write fail\r\n");			
		while(1);

	}
	return 0;
}
   1e238:	80 e0       	ldi	r24, 0x00	; 0
   1e23a:	90 e0       	ldi	r25, 0x00	; 0
   1e23c:	1f 91       	pop	r17
   1e23e:	0f 91       	pop	r16
   1e240:	08 95       	ret
		
		GoApp();
	}
	else {
		// ERROR @_@
		putStr((unsigned char *)"Write fail\r\n");			
   1e242:	80 e3       	ldi	r24, 0x30	; 48
   1e244:	91 e0       	ldi	r25, 0x01	; 1
   1e246:	0e 94 a4 f6 	call	0x1ed48	; 0x1ed48 <putStr>
   1e24a:	ff cf       	rjmp	.-2      	; 0x1e24a <main+0x64>

0001e24c <swapl>:
	SpmCommand(page, (1 << PGWRT) | (1 << SPMEN)); 
	SpmCommand(0, (1 << RWWSRE) | (1 << SPMEN));               
}

ulong swapl(ulong l)
{
   1e24c:	ef 92       	push	r14
   1e24e:	ff 92       	push	r15
   1e250:	0f 93       	push	r16
   1e252:	1f 93       	push	r17
	ulong ret=0;
	ret = (l & 0xFF) << 24;
   1e254:	56 2f       	mov	r21, r22
   1e256:	44 27       	eor	r20, r20
   1e258:	33 27       	eor	r19, r19
   1e25a:	22 27       	eor	r18, r18
	ret |= ((l >> 8) & 0xFF) << 16;
   1e25c:	e9 2e       	mov	r14, r25
   1e25e:	ff 24       	eor	r15, r15
   1e260:	00 27       	eor	r16, r16
   1e262:	11 27       	eor	r17, r17
   1e264:	e2 2a       	or	r14, r18
   1e266:	f3 2a       	or	r15, r19
   1e268:	04 2b       	or	r16, r20
   1e26a:	15 2b       	or	r17, r21
	ret |= ((l >> 16) & 0xFF) << 8;
   1e26c:	27 2f       	mov	r18, r23
   1e26e:	30 e0       	ldi	r19, 0x00	; 0
   1e270:	40 e0       	ldi	r20, 0x00	; 0
   1e272:	50 e0       	ldi	r21, 0x00	; 0
   1e274:	a9 01       	movw	r20, r18
   1e276:	33 27       	eor	r19, r19
   1e278:	22 27       	eor	r18, r18
   1e27a:	e2 2a       	or	r14, r18
   1e27c:	f3 2a       	or	r15, r19
   1e27e:	04 2b       	or	r16, r20
   1e280:	15 2b       	or	r17, r21
   1e282:	67 2f       	mov	r22, r23
   1e284:	78 2f       	mov	r23, r24
   1e286:	89 2f       	mov	r24, r25
   1e288:	99 27       	eor	r25, r25
   1e28a:	60 70       	andi	r22, 0x00	; 0
   1e28c:	80 70       	andi	r24, 0x00	; 0
   1e28e:	90 70       	andi	r25, 0x00	; 0
   1e290:	e6 2a       	or	r14, r22
   1e292:	f7 2a       	or	r15, r23
   1e294:	08 2b       	or	r16, r24
   1e296:	19 2b       	or	r17, r25
	ret |= ((l >> 24) & 0xFF);
	return ret;
}
   1e298:	b7 01       	movw	r22, r14
   1e29a:	c8 01       	movw	r24, r16
   1e29c:	1f 91       	pop	r17
   1e29e:	0f 91       	pop	r16
   1e2a0:	ff 90       	pop	r15
   1e2a2:	ef 90       	pop	r14
   1e2a4:	08 95       	ret

0001e2a6 <FlashPage>:
#include "serial.h"

uchar FLASH_BUF[256];

static void FlashPage(uint page, void *data, uint len)
{
   1e2a6:	df 92       	push	r13
   1e2a8:	ef 92       	push	r14
   1e2aa:	ff 92       	push	r15
   1e2ac:	0f 93       	push	r16
   1e2ae:	1f 93       	push	r17
   1e2b0:	cf 93       	push	r28
   1e2b2:	df 93       	push	r29
   1e2b4:	fc 01       	movw	r30, r24
   1e2b6:	7b 01       	movw	r14, r22
   1e2b8:	8a 01       	movw	r16, r20
   1e2ba:	81 e0       	ldi	r24, 0x01	; 1
   1e2bc:	41 30       	cpi	r20, 0x01	; 1
   1e2be:	58 07       	cpc	r21, r24
   1e2c0:	10 f0       	brcs	.+4      	; 0x1e2c6 <FlashPage+0x20>
   1e2c2:	00 e0       	ldi	r16, 0x00	; 0
   1e2c4:	11 e0       	ldi	r17, 0x01	; 1
	uint i;
	uint *wp = data;
	
	if(len > 256) len = 256;
	
	if(page >= 256)
   1e2c6:	ef 3f       	cpi	r30, 0xFF	; 255
   1e2c8:	f1 05       	cpc	r31, r1
   1e2ca:	41 f0       	breq	.+16     	; 0x1e2dc <FlashPage+0x36>
   1e2cc:	38 f0       	brcs	.+14     	; 0x1e2dc <FlashPage+0x36>
	{
		if(page >= 480)
   1e2ce:	81 e0       	ldi	r24, 0x01	; 1
   1e2d0:	e0 3e       	cpi	r30, 0xE0	; 224
   1e2d2:	f8 07       	cpc	r31, r24
   1e2d4:	98 f5       	brcc	.+102    	; 0x1e33c <FlashPage+0x96>
			return;
		RAMPZ = 1;
   1e2d6:	81 e0       	ldi	r24, 0x01	; 1
   1e2d8:	8b bf       	out	0x3b, r24	; 59
   1e2da:	01 c0       	rjmp	.+2      	; 0x1e2de <FlashPage+0x38>
	}
	else RAMPZ = 0;
   1e2dc:	1b be       	out	0x3b, r1	; 59

	page <<= 8;
   1e2de:	de 2e       	mov	r13, r30
	
	SpmCommand(page, (1 << PGERS) | (1 << SPMEN));
   1e2e0:	80 e0       	ldi	r24, 0x00	; 0
   1e2e2:	9e 2f       	mov	r25, r30
   1e2e4:	63 e0       	ldi	r22, 0x03	; 3
   1e2e6:	0e 94 90 f0 	call	0x1e120	; 0x1e120 <SpmCommand>
	SpmCommand(0, (1 << RWWSRE) | (1 << SPMEN));
   1e2ea:	80 e0       	ldi	r24, 0x00	; 0
   1e2ec:	90 e0       	ldi	r25, 0x00	; 0
   1e2ee:	61 e1       	ldi	r22, 0x11	; 17
   1e2f0:	0e 94 90 f0 	call	0x1e120	; 0x1e120 <SpmCommand>
   1e2f4:	c0 e0       	ldi	r28, 0x00	; 0
   1e2f6:	d0 e0       	ldi	r29, 0x00	; 0
   1e2f8:	09 c0       	rjmp	.+18     	; 0x1e30c <FlashPage+0x66>
	
	for(i = 0; i < len; i += 2, wp++)
		SpmBufferFill(i, *wp);
   1e2fa:	f7 01       	movw	r30, r14
   1e2fc:	ec 0f       	add	r30, r28
   1e2fe:	fd 1f       	adc	r31, r29
   1e300:	60 81       	ld	r22, Z
   1e302:	71 81       	ldd	r23, Z+1	; 0x01
   1e304:	ce 01       	movw	r24, r28
   1e306:	0e 94 92 f0 	call	0x1e124	; 0x1e124 <SpmBufferFill>
	page <<= 8;
	
	SpmCommand(page, (1 << PGERS) | (1 << SPMEN));
	SpmCommand(0, (1 << RWWSRE) | (1 << SPMEN));
	
	for(i = 0; i < len; i += 2, wp++)
   1e30a:	22 96       	adiw	r28, 0x02	; 2
   1e30c:	c0 17       	cp	r28, r16
   1e30e:	d1 07       	cpc	r29, r17
   1e310:	a0 f3       	brcs	.-24     	; 0x1e2fa <FlashPage+0x54>
   1e312:	06 c0       	rjmp	.+12     	; 0x1e320 <FlashPage+0x7a>
		SpmBufferFill(i, *wp);

	for(; i < 256; i += 2)
		SpmBufferFill(i, 0xFFFF);
   1e314:	ce 01       	movw	r24, r28
   1e316:	6f ef       	ldi	r22, 0xFF	; 255
   1e318:	7f ef       	ldi	r23, 0xFF	; 255
   1e31a:	0e 94 92 f0 	call	0x1e124	; 0x1e124 <SpmBufferFill>
	SpmCommand(0, (1 << RWWSRE) | (1 << SPMEN));
	
	for(i = 0; i < len; i += 2, wp++)
		SpmBufferFill(i, *wp);

	for(; i < 256; i += 2)
   1e31e:	22 96       	adiw	r28, 0x02	; 2
   1e320:	cf 3f       	cpi	r28, 0xFF	; 255
   1e322:	d1 05       	cpc	r29, r1
   1e324:	b9 f3       	breq	.-18     	; 0x1e314 <FlashPage+0x6e>
   1e326:	b0 f3       	brcs	.-20     	; 0x1e314 <FlashPage+0x6e>
		SpmBufferFill(i, 0xFFFF);
	
	SpmCommand(page, (1 << PGWRT) | (1 << SPMEN)); 
   1e328:	80 e0       	ldi	r24, 0x00	; 0
   1e32a:	9d 2d       	mov	r25, r13
   1e32c:	65 e0       	ldi	r22, 0x05	; 5
   1e32e:	0e 94 90 f0 	call	0x1e120	; 0x1e120 <SpmCommand>
	SpmCommand(0, (1 << RWWSRE) | (1 << SPMEN));               
   1e332:	80 e0       	ldi	r24, 0x00	; 0
   1e334:	90 e0       	ldi	r25, 0x00	; 0
   1e336:	61 e1       	ldi	r22, 0x11	; 17
   1e338:	0e 94 90 f0 	call	0x1e120	; 0x1e120 <SpmCommand>
}
   1e33c:	df 91       	pop	r29
   1e33e:	cf 91       	pop	r28
   1e340:	1f 91       	pop	r17
   1e342:	0f 91       	pop	r16
   1e344:	ff 90       	pop	r15
   1e346:	ef 90       	pop	r14
   1e348:	df 90       	pop	r13
   1e34a:	08 95       	ret

0001e34c <loading>:
	ret |= ((l >> 24) & 0xFF);
	return ret;
}

int loading(void) 
{
   1e34c:	2f 92       	push	r2
   1e34e:	3f 92       	push	r3
   1e350:	5f 92       	push	r5
   1e352:	6f 92       	push	r6
   1e354:	7f 92       	push	r7
   1e356:	8f 92       	push	r8
   1e358:	9f 92       	push	r9
   1e35a:	af 92       	push	r10
   1e35c:	bf 92       	push	r11
   1e35e:	cf 92       	push	r12
   1e360:	df 92       	push	r13
   1e362:	ef 92       	push	r14
   1e364:	ff 92       	push	r15
   1e366:	0f 93       	push	r16
   1e368:	1f 93       	push	r17
   1e36a:	df 93       	push	r29
   1e36c:	cf 93       	push	r28
   1e36e:	00 d0       	rcall	.+0      	; 0x1e370 <loading+0x24>
   1e370:	00 d0       	rcall	.+0      	; 0x1e372 <loading+0x26>
   1e372:	cd b7       	in	r28, 0x3d	; 61
   1e374:	de b7       	in	r29, 0x3e	; 62
	uint size_ttdiv256remain = 0;
	ulong size_total;
	uint time_out, size_recvpp, page;
	uchar flag, last;

	size_total = 0;
   1e376:	19 82       	std	Y+1, r1	; 0x01
   1e378:	1a 82       	std	Y+2, r1	; 0x02
   1e37a:	1b 82       	std	Y+3, r1	; 0x03
   1e37c:	1c 82       	std	Y+4, r1	; 0x04
	size_recvpp = 0;
	page = 0;
	flag = 0;
	last = 0;
	
	putStr((unsigned char*)"socket-");
   1e37e:	85 e4       	ldi	r24, 0x45	; 69
   1e380:	91 e0       	ldi	r25, 0x01	; 1
   1e382:	0e 94 a4 f6 	call	0x1ed48	; 0x1ed48 <putStr>
	
	for(;flag==0;) flag = socket(SOCK_CONFIG, Sn_MR_TCP, REMOTE_UPDATE_PORT, 0);
   1e386:	80 e0       	ldi	r24, 0x00	; 0
   1e388:	61 e0       	ldi	r22, 0x01	; 1
   1e38a:	4b e4       	ldi	r20, 0x4B	; 75
   1e38c:	5e eb       	ldi	r21, 0xBE	; 190
   1e38e:	20 e0       	ldi	r18, 0x00	; 0
   1e390:	30 e0       	ldi	r19, 0x00	; 0
   1e392:	0e 94 27 f3 	call	0x1e64e	; 0x1e64e <socket>
   1e396:	88 23       	and	r24, r24
   1e398:	b1 f3       	breq	.-20     	; 0x1e386 <loading+0x3a>
	listen(SOCK_CONFIG);
   1e39a:	80 e0       	ldi	r24, 0x00	; 0
   1e39c:	0e 94 86 f3 	call	0x1e70c	; 0x1e70c <listen>

	putStr((unsigned char *)"listen");
   1e3a0:	8d e4       	ldi	r24, 0x4D	; 77
   1e3a2:	91 e0       	ldi	r25, 0x01	; 1
   1e3a4:	0e 94 a4 f6 	call	0x1ed48	; 0x1ed48 <putStr>
   1e3a8:	cc 24       	eor	r12, r12
   1e3aa:	dd 24       	eor	r13, r13
   1e3ac:	ee 24       	eor	r14, r14
   1e3ae:	ff 24       	eor	r15, r15
   1e3b0:	66 24       	eor	r6, r6
   1e3b2:	77 24       	eor	r7, r7
   1e3b4:	88 24       	eor	r8, r8
   1e3b6:	99 24       	eor	r9, r9
   1e3b8:	aa 24       	eor	r10, r10
   1e3ba:	bb 24       	eor	r11, r11
   1e3bc:	55 24       	eor	r5, r5
	flag = 0;
	while (1) {
		if (getSn_SR(SOCK_CONFIG) == SOCK_ESTABLISHED) {
			if (flag == 0) {
				if (getSn_RX_RSR(SOCK_CONFIG) >= 4) {
					recv(SOCK_CONFIG, (uchar *)&size_total, 4);		// not in file
   1e3be:	1e 01       	movw	r2, r28
   1e3c0:	08 94       	sec
   1e3c2:	21 1c       	adc	r2, r1
   1e3c4:	31 1c       	adc	r3, r1
	putStr((unsigned char *)"listen");
	
	time_out = 0;
	flag = 0;
	while (1) {
		if (getSn_SR(SOCK_CONFIG) == SOCK_ESTABLISHED) {
   1e3c6:	80 e0       	ldi	r24, 0x00	; 0
   1e3c8:	0e 94 a0 f8 	call	0x1f140	; 0x1f140 <getSn_SSR>
   1e3cc:	87 31       	cpi	r24, 0x17	; 23
   1e3ce:	d9 f7       	brne	.-10     	; 0x1e3c6 <loading+0x7a>
			if (flag == 0) {
   1e3d0:	55 20       	and	r5, r5
   1e3d2:	09 f0       	breq	.+2      	; 0x1e3d6 <loading+0x8a>
   1e3d4:	54 c0       	rjmp	.+168    	; 0x1e47e <loading+0x132>
				if (getSn_RX_RSR(SOCK_CONFIG) >= 4) {
   1e3d6:	80 e0       	ldi	r24, 0x00	; 0
   1e3d8:	0e 94 f7 f9 	call	0x1f3ee	; 0x1f3ee <getSn_RX_RSR>
   1e3dc:	64 30       	cpi	r22, 0x04	; 4
   1e3de:	71 05       	cpc	r23, r1
   1e3e0:	81 05       	cpc	r24, r1
   1e3e2:	91 05       	cpc	r25, r1
   1e3e4:	e8 f1       	brcs	.+122    	; 0x1e460 <loading+0x114>
					recv(SOCK_CONFIG, (uchar *)&size_total, 4);		// not in file
   1e3e6:	80 e0       	ldi	r24, 0x00	; 0
   1e3e8:	b1 01       	movw	r22, r2
   1e3ea:	24 e0       	ldi	r18, 0x04	; 4
   1e3ec:	30 e0       	ldi	r19, 0x00	; 0
   1e3ee:	40 e0       	ldi	r20, 0x00	; 0
   1e3f0:	50 e0       	ldi	r21, 0x00	; 0
   1e3f2:	0e 94 88 f4 	call	0x1e910	; 0x1e910 <recv>
					size_total = swapl(size_total);
   1e3f6:	29 81       	ldd	r18, Y+1	; 0x01
   1e3f8:	3a 81       	ldd	r19, Y+2	; 0x02
   1e3fa:	4b 81       	ldd	r20, Y+3	; 0x03
   1e3fc:	5c 81       	ldd	r21, Y+4	; 0x04
}

ulong swapl(ulong l)
{
	ulong ret=0;
	ret = (l & 0xFF) << 24;
   1e3fe:	b2 2f       	mov	r27, r18
   1e400:	aa 27       	eor	r26, r26
   1e402:	99 27       	eor	r25, r25
   1e404:	88 27       	eor	r24, r24
	ret |= ((l >> 8) & 0xFF) << 16;
   1e406:	e5 2e       	mov	r14, r21
   1e408:	ff 24       	eor	r15, r15
   1e40a:	00 27       	eor	r16, r16
   1e40c:	11 27       	eor	r17, r17
   1e40e:	e8 2a       	or	r14, r24
   1e410:	f9 2a       	or	r15, r25
   1e412:	0a 2b       	or	r16, r26
   1e414:	1b 2b       	or	r17, r27
	ret |= ((l >> 16) & 0xFF) << 8;
   1e416:	83 2f       	mov	r24, r19
   1e418:	90 e0       	ldi	r25, 0x00	; 0
   1e41a:	a0 e0       	ldi	r26, 0x00	; 0
   1e41c:	b0 e0       	ldi	r27, 0x00	; 0
   1e41e:	dc 01       	movw	r26, r24
   1e420:	99 27       	eor	r25, r25
   1e422:	88 27       	eor	r24, r24
   1e424:	e8 2a       	or	r14, r24
   1e426:	f9 2a       	or	r15, r25
   1e428:	0a 2b       	or	r16, r26
   1e42a:	1b 2b       	or	r17, r27
	ret |= ((l >> 24) & 0xFF);
   1e42c:	23 2f       	mov	r18, r19
   1e42e:	34 2f       	mov	r19, r20
   1e430:	45 2f       	mov	r20, r21
   1e432:	55 27       	eor	r21, r21
   1e434:	20 70       	andi	r18, 0x00	; 0
   1e436:	40 70       	andi	r20, 0x00	; 0
   1e438:	50 70       	andi	r21, 0x00	; 0
   1e43a:	e2 2a       	or	r14, r18
   1e43c:	f3 2a       	or	r15, r19
   1e43e:	04 2b       	or	r16, r20
   1e440:	15 2b       	or	r17, r21
	while (1) {
		if (getSn_SR(SOCK_CONFIG) == SOCK_ESTABLISHED) {
			if (flag == 0) {
				if (getSn_RX_RSR(SOCK_CONFIG) >= 4) {
					recv(SOCK_CONFIG, (uchar *)&size_total, 4);		// not in file
					size_total = swapl(size_total);
   1e442:	e9 82       	std	Y+1, r14	; 0x01
   1e444:	fa 82       	std	Y+2, r15	; 0x02
   1e446:	0b 83       	std	Y+3, r16	; 0x03
   1e448:	1c 83       	std	Y+4, r17	; 0x04
					size_ttdiv256 = size_total / 256;
   1e44a:	bb 27       	eor	r27, r27
   1e44c:	a1 2f       	mov	r26, r17
   1e44e:	90 2f       	mov	r25, r16
   1e450:	8f 2d       	mov	r24, r15
   1e452:	6c 01       	movw	r12, r24
					size_ttdiv256remain = size_total - (size_ttdiv256 * 256);
   1e454:	9c 2d       	mov	r25, r12
   1e456:	88 27       	eor	r24, r24
   1e458:	e8 1a       	sub	r14, r24
   1e45a:	f9 0a       	sbc	r15, r25
   1e45c:	55 24       	eor	r5, r5
   1e45e:	53 94       	inc	r5
					putData((uchar*)&size_ttdiv256, 2);
					putStr("\r\nsize_ttdiv256remain =");
					putData((uchar*)&size_ttdiv256remain, 2);
					putStr("\r\n");*/
				}
				time_out++;
   1e460:	08 94       	sec
   1e462:	61 1c       	adc	r6, r1
   1e464:	71 1c       	adc	r7, r1
				wait_10ms(1);
   1e466:	81 e0       	ldi	r24, 0x01	; 1
   1e468:	90 e0       	ldi	r25, 0x00	; 0
   1e46a:	0e 94 6f f0 	call	0x1e0de	; 0x1e0de <wait_10ms>
				if (time_out > 200) return(0);
   1e46e:	89 ec       	ldi	r24, 0xC9	; 201
   1e470:	68 16       	cp	r6, r24
   1e472:	71 04       	cpc	r7, r1
   1e474:	08 f4       	brcc	.+2      	; 0x1e478 <loading+0x12c>
   1e476:	a7 cf       	rjmp	.-178    	; 0x1e3c6 <loading+0x7a>
   1e478:	60 e0       	ldi	r22, 0x00	; 0
   1e47a:	70 e0       	ldi	r23, 0x00	; 0
   1e47c:	5a c0       	rjmp	.+180    	; 0x1e532 <loading+0x1e6>
			}
			else {
				if(size_ttdiv256) {
   1e47e:	c1 14       	cp	r12, r1
   1e480:	d1 04       	cpc	r13, r1
   1e482:	41 f1       	breq	.+80     	; 0x1e4d4 <loading+0x188>
					if((size_recv = getSn_RX_RSR(SOCK_CONFIG)) >= 256) {
   1e484:	80 e0       	ldi	r24, 0x00	; 0
   1e486:	0e 94 f7 f9 	call	0x1f3ee	; 0x1f3ee <getSn_RX_RSR>
   1e48a:	6f 3f       	cpi	r22, 0xFF	; 255
   1e48c:	71 05       	cpc	r23, r1
   1e48e:	09 f0       	breq	.+2      	; 0x1e492 <loading+0x146>
   1e490:	08 f4       	brcc	.+2      	; 0x1e494 <loading+0x148>
   1e492:	99 cf       	rjmp	.-206    	; 0x1e3c6 <loading+0x7a>
						putStr((unsigned char *)"*");
   1e494:	84 e5       	ldi	r24, 0x54	; 84
   1e496:	91 e0       	ldi	r25, 0x01	; 1
   1e498:	0e 94 a4 f6 	call	0x1ed48	; 0x1ed48 <putStr>
						recv(SOCK_CONFIG, FLASH_BUF, 256);
   1e49c:	80 e0       	ldi	r24, 0x00	; 0
   1e49e:	6e e2       	ldi	r22, 0x2E	; 46
   1e4a0:	72 e0       	ldi	r23, 0x02	; 2
   1e4a2:	20 e0       	ldi	r18, 0x00	; 0
   1e4a4:	31 e0       	ldi	r19, 0x01	; 1
   1e4a6:	40 e0       	ldi	r20, 0x00	; 0
   1e4a8:	50 e0       	ldi	r21, 0x00	; 0
   1e4aa:	0e 94 88 f4 	call	0x1e910	; 0x1e910 <recv>
//						putData(FLASH_BUF, 256);
//						while(1);
						FlashPage(page++, FLASH_BUF, 256);
   1e4ae:	85 01       	movw	r16, r10
   1e4b0:	0f 5f       	subi	r16, 0xFF	; 255
   1e4b2:	1f 4f       	sbci	r17, 0xFF	; 255
   1e4b4:	c5 01       	movw	r24, r10
   1e4b6:	6e e2       	ldi	r22, 0x2E	; 46
   1e4b8:	72 e0       	ldi	r23, 0x02	; 2
   1e4ba:	40 e0       	ldi	r20, 0x00	; 0
   1e4bc:	51 e0       	ldi	r21, 0x01	; 1
   1e4be:	0e 94 53 f1 	call	0x1e2a6	; 0x1e2a6 <FlashPage>
						size_recvpp += 256;
   1e4c2:	80 e0       	ldi	r24, 0x00	; 0
   1e4c4:	91 e0       	ldi	r25, 0x01	; 1
   1e4c6:	88 0e       	add	r8, r24
   1e4c8:	99 1e       	adc	r9, r25
						size_ttdiv256--;
   1e4ca:	08 94       	sec
   1e4cc:	c1 08       	sbc	r12, r1
   1e4ce:	d1 08       	sbc	r13, r1
   1e4d0:	58 01       	movw	r10, r16
   1e4d2:	79 cf       	rjmp	.-270    	; 0x1e3c6 <loading+0x7a>
					}
				}
				else {
					if((size_recv = getSn_RX_RSR(SOCK_CONFIG)) >= size_ttdiv256remain) {
   1e4d4:	80 e0       	ldi	r24, 0x00	; 0
   1e4d6:	0e 94 f7 f9 	call	0x1f3ee	; 0x1f3ee <getSn_RX_RSR>
   1e4da:	6e 15       	cp	r22, r14
   1e4dc:	7f 05       	cpc	r23, r15
   1e4de:	08 f4       	brcc	.+2      	; 0x1e4e2 <loading+0x196>
   1e4e0:	72 cf       	rjmp	.-284    	; 0x1e3c6 <loading+0x7a>
						putStr((unsigned char *)"-");
   1e4e2:	86 e5       	ldi	r24, 0x56	; 86
   1e4e4:	91 e0       	ldi	r25, 0x01	; 1
   1e4e6:	0e 94 a4 f6 	call	0x1ed48	; 0x1ed48 <putStr>
						recv(SOCK_CONFIG, FLASH_BUF, 256);//size_ttdiv256remain);
   1e4ea:	80 e0       	ldi	r24, 0x00	; 0
   1e4ec:	6e e2       	ldi	r22, 0x2E	; 46
   1e4ee:	72 e0       	ldi	r23, 0x02	; 2
   1e4f0:	20 e0       	ldi	r18, 0x00	; 0
   1e4f2:	31 e0       	ldi	r19, 0x01	; 1
   1e4f4:	40 e0       	ldi	r20, 0x00	; 0
   1e4f6:	50 e0       	ldi	r21, 0x00	; 0
   1e4f8:	0e 94 88 f4 	call	0x1e910	; 0x1e910 <recv>
//						putData(FLASH_BUF, size_ttdiv256remain);
//						while(1);
						FlashPage(page, FLASH_BUF, size_ttdiv256remain);
   1e4fc:	c5 01       	movw	r24, r10
   1e4fe:	6e e2       	ldi	r22, 0x2E	; 46
   1e500:	72 e0       	ldi	r23, 0x02	; 2
   1e502:	a7 01       	movw	r20, r14
   1e504:	0e 94 53 f1 	call	0x1e2a6	; 0x1e2a6 <FlashPage>
					}
				}
			} // if (flag == 0)
		} // if (state == SOCK_ESTABLISHED)
	}
	disconnect(SOCK_CONFIG);
   1e508:	80 e0       	ldi	r24, 0x00	; 0
   1e50a:	0e 94 b0 f2 	call	0x1e560	; 0x1e560 <disconnect>
   1e50e:	60 e0       	ldi	r22, 0x00	; 0
   1e510:	70 e0       	ldi	r23, 0x00	; 0
   1e512:	8e 0c       	add	r8, r14
   1e514:	9f 1c       	adc	r9, r15
   1e516:	94 01       	movw	r18, r8
   1e518:	40 e0       	ldi	r20, 0x00	; 0
   1e51a:	50 e0       	ldi	r21, 0x00	; 0
   1e51c:	89 81       	ldd	r24, Y+1	; 0x01
   1e51e:	9a 81       	ldd	r25, Y+2	; 0x02
   1e520:	ab 81       	ldd	r26, Y+3	; 0x03
   1e522:	bc 81       	ldd	r27, Y+4	; 0x04
   1e524:	28 17       	cp	r18, r24
   1e526:	39 07       	cpc	r19, r25
   1e528:	4a 07       	cpc	r20, r26
   1e52a:	5b 07       	cpc	r21, r27
   1e52c:	11 f4       	brne	.+4      	; 0x1e532 <loading+0x1e6>
   1e52e:	61 e0       	ldi	r22, 0x01	; 1
   1e530:	70 e0       	ldi	r23, 0x00	; 0

	if((size_recvpp == size_total) && (last == 1)) return 1;
	else return 0;
}
   1e532:	cb 01       	movw	r24, r22
   1e534:	0f 90       	pop	r0
   1e536:	0f 90       	pop	r0
   1e538:	0f 90       	pop	r0
   1e53a:	0f 90       	pop	r0
   1e53c:	cf 91       	pop	r28
   1e53e:	df 91       	pop	r29
   1e540:	1f 91       	pop	r17
   1e542:	0f 91       	pop	r16
   1e544:	ff 90       	pop	r15
   1e546:	ef 90       	pop	r14
   1e548:	df 90       	pop	r13
   1e54a:	cf 90       	pop	r12
   1e54c:	bf 90       	pop	r11
   1e54e:	af 90       	pop	r10
   1e550:	9f 90       	pop	r9
   1e552:	8f 90       	pop	r8
   1e554:	7f 90       	pop	r7
   1e556:	6f 90       	pop	r6
   1e558:	5f 90       	pop	r5
   1e55a:	3f 90       	pop	r3
   1e55c:	2f 90       	pop	r2
   1e55e:	08 95       	ret

0001e560 <disconnect>:
void disconnect(SOCKET s)
{
#ifdef __DEF_IINCHIP_DBG__
	printf("disconnect()\r\n");
#endif
	IINCHIP_WRITE(Sn_CR(s), Sn_CR_DISCON);
   1e560:	90 e0       	ldi	r25, 0x00	; 0
   1e562:	26 e0       	ldi	r18, 0x06	; 6
   1e564:	88 0f       	add	r24, r24
   1e566:	99 1f       	adc	r25, r25
   1e568:	2a 95       	dec	r18
   1e56a:	e1 f7       	brne	.-8      	; 0x1e564 <disconnect+0x4>
   1e56c:	8d 5f       	subi	r24, 0xFD	; 253
   1e56e:	9d 47       	sbci	r25, 0x7D	; 125
   1e570:	68 e0       	ldi	r22, 0x08	; 8
   1e572:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
}
   1e576:	08 95       	ret

0001e578 <connect>:
This function return 1 for success else 0.
*********************************************************************
*/

uint8    connect(SOCKET s, uint8 * addr, uint16 port)
{
   1e578:	cf 92       	push	r12
   1e57a:	df 92       	push	r13
   1e57c:	ef 92       	push	r14
   1e57e:	ff 92       	push	r15
   1e580:	0f 93       	push	r16
   1e582:	1f 93       	push	r17
   1e584:	cf 93       	push	r28
   1e586:	df 93       	push	r29
   1e588:	e8 2e       	mov	r14, r24
   1e58a:	eb 01       	movw	r28, r22
   1e58c:	6a 01       	movw	r12, r20
   if
   (
   1e58e:	68 81       	ld	r22, Y
   1e590:	6f 3f       	cpi	r22, 0xFF	; 255
   1e592:	51 f4       	brne	.+20     	; 0x1e5a8 <connect+0x30>
   1e594:	89 81       	ldd	r24, Y+1	; 0x01
   1e596:	8f 3f       	cpi	r24, 0xFF	; 255
   1e598:	91 f4       	brne	.+36     	; 0x1e5be <connect+0x46>
   1e59a:	8a 81       	ldd	r24, Y+2	; 0x02
   1e59c:	8f 3f       	cpi	r24, 0xFF	; 255
   1e59e:	79 f4       	brne	.+30     	; 0x1e5be <connect+0x46>
   1e5a0:	8b 81       	ldd	r24, Y+3	; 0x03
   1e5a2:	8f 3f       	cpi	r24, 0xFF	; 255
   1e5a4:	61 f4       	brne	.+24     	; 0x1e5be <connect+0x46>
   1e5a6:	3d c0       	rjmp	.+122    	; 0x1e622 <connect+0xaa>
   1e5a8:	66 23       	and	r22, r22
   1e5aa:	49 f4       	brne	.+18     	; 0x1e5be <connect+0x46>
   1e5ac:	89 81       	ldd	r24, Y+1	; 0x01
   1e5ae:	88 23       	and	r24, r24
   1e5b0:	31 f4       	brne	.+12     	; 0x1e5be <connect+0x46>
   1e5b2:	8a 81       	ldd	r24, Y+2	; 0x02
   1e5b4:	88 23       	and	r24, r24
   1e5b6:	19 f4       	brne	.+6      	; 0x1e5be <connect+0x46>
   1e5b8:	8b 81       	ldd	r24, Y+3	; 0x03
   1e5ba:	88 23       	and	r24, r24
   1e5bc:	91 f1       	breq	.+100    	; 0x1e622 <connect+0xaa>
   1e5be:	c1 14       	cp	r12, r1
   1e5c0:	d1 04       	cpc	r13, r1
   1e5c2:	79 f1       	breq	.+94     	; 0x1e622 <connect+0xaa>
      #endif
      return 0;
   }
   
		// set destination IP
		IINCHIP_WRITE(Sn_DIPR(s), addr[0]);
   1e5c4:	ff 24       	eor	r15, r15
   1e5c6:	88 e0       	ldi	r24, 0x08	; 8
   1e5c8:	92 e0       	ldi	r25, 0x02	; 2
   1e5ca:	e8 0e       	add	r14, r24
   1e5cc:	f9 1e       	adc	r15, r25
   1e5ce:	87 01       	movw	r16, r14
   1e5d0:	36 e0       	ldi	r19, 0x06	; 6
   1e5d2:	00 0f       	add	r16, r16
   1e5d4:	11 1f       	adc	r17, r17
   1e5d6:	3a 95       	dec	r19
   1e5d8:	e1 f7       	brne	.-8      	; 0x1e5d2 <connect+0x5a>
   1e5da:	c8 01       	movw	r24, r16
   1e5dc:	44 96       	adiw	r24, 0x14	; 20
   1e5de:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR1(s), addr[1]);
   1e5e2:	c8 01       	movw	r24, r16
   1e5e4:	45 96       	adiw	r24, 0x15	; 21
   1e5e6:	69 81       	ldd	r22, Y+1	; 0x01
   1e5e8:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR2(s), addr[2]);
   1e5ec:	c8 01       	movw	r24, r16
   1e5ee:	46 96       	adiw	r24, 0x16	; 22
   1e5f0:	6a 81       	ldd	r22, Y+2	; 0x02
   1e5f2:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR3(s), addr[3]);
   1e5f6:	c8 01       	movw	r24, r16
   1e5f8:	47 96       	adiw	r24, 0x17	; 23
   1e5fa:	6b 81       	ldd	r22, Y+3	; 0x03
   1e5fc:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
	
		// set destination PORT
		IINCHIP_WRITE(Sn_DPORTR(s), port >> 8);
   1e600:	c8 01       	movw	r24, r16
   1e602:	42 96       	adiw	r24, 0x12	; 18
   1e604:	6d 2d       	mov	r22, r13
   1e606:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DPORTR1(s), port & 0xff);
   1e60a:	c8 01       	movw	r24, r16
   1e60c:	43 96       	adiw	r24, 0x13	; 19
   1e60e:	6c 2d       	mov	r22, r12
   1e610:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>

		// Connect
		IINCHIP_WRITE(Sn_CR(s), Sn_CR_CONNECT);
   1e614:	c8 01       	movw	r24, r16
   1e616:	03 96       	adiw	r24, 0x03	; 3
   1e618:	64 e0       	ldi	r22, 0x04	; 4
   1e61a:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
   1e61e:	81 e0       	ldi	r24, 0x01	; 1
   1e620:	01 c0       	rjmp	.+2      	; 0x1e624 <connect+0xac>

   return 1;   
   1e622:	80 e0       	ldi	r24, 0x00	; 0
}
   1e624:	df 91       	pop	r29
   1e626:	cf 91       	pop	r28
   1e628:	1f 91       	pop	r17
   1e62a:	0f 91       	pop	r16
   1e62c:	ff 90       	pop	r15
   1e62e:	ef 90       	pop	r14
   1e630:	df 90       	pop	r13
   1e632:	cf 90       	pop	r12
   1e634:	08 95       	ret

0001e636 <close>:
void close(SOCKET s)
{
#ifdef __DEF_IINCHIP_DBG__
	printf("close()\r\n");
#endif
	IINCHIP_WRITE(Sn_CR(s), Sn_CR_CLOSE);
   1e636:	90 e0       	ldi	r25, 0x00	; 0
   1e638:	46 e0       	ldi	r20, 0x06	; 6
   1e63a:	88 0f       	add	r24, r24
   1e63c:	99 1f       	adc	r25, r25
   1e63e:	4a 95       	dec	r20
   1e640:	e1 f7       	brne	.-8      	; 0x1e63a <close+0x4>
   1e642:	8d 5f       	subi	r24, 0xFD	; 253
   1e644:	9d 47       	sbci	r25, 0x7D	; 125
   1e646:	60 e1       	ldi	r22, 0x10	; 16
   1e648:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
}
   1e64c:	08 95       	ret

0001e64e <socket>:
This function return 1 for sucess else 0.
*********************************************************************
*/

uint8 socket(SOCKET s, uint8 protocol, uint16 port, uint16 flag)
{
   1e64e:	bf 92       	push	r11
   1e650:	cf 92       	push	r12
   1e652:	df 92       	push	r13
   1e654:	ef 92       	push	r14
   1e656:	ff 92       	push	r15
   1e658:	0f 93       	push	r16
   1e65a:	1f 93       	push	r17
   1e65c:	cf 93       	push	r28
   1e65e:	df 93       	push	r29
   1e660:	b8 2e       	mov	r11, r24
   1e662:	d6 2e       	mov	r13, r22
   1e664:	7a 01       	movw	r14, r20
   1e666:	c2 2e       	mov	r12, r18
	uint8 ret;
#ifdef __DEF_IINCHIP_DBG__
	printf("socket()\r\n");
#endif
	if ((protocol == Sn_MR_TCP) || (protocol == Sn_MR_UDP) || (protocol == Sn_MR_IPRAW) || (protocol == Sn_MR_MACRAW))
   1e668:	86 2f       	mov	r24, r22
   1e66a:	81 50       	subi	r24, 0x01	; 1
   1e66c:	84 30       	cpi	r24, 0x04	; 4
   1e66e:	10 f0       	brcs	.+4      	; 0x1e674 <socket+0x26>
   1e670:	80 e0       	ldi	r24, 0x00	; 0
   1e672:	42 c0       	rjmp	.+132    	; 0x1e6f8 <socket+0xaa>
	{
		close(s);
   1e674:	8b 2d       	mov	r24, r11
   1e676:	0e 94 1b f3 	call	0x1e636	; 0x1e636 <close>
		IINCHIP_WRITE(Sn_MR(s), protocol | flag );
   1e67a:	cb 2d       	mov	r28, r11
   1e67c:	d0 e0       	ldi	r29, 0x00	; 0
   1e67e:	c8 5f       	subi	r28, 0xF8	; 248
   1e680:	dd 4f       	sbci	r29, 0xFD	; 253
   1e682:	8e 01       	movw	r16, r28
   1e684:	66 e0       	ldi	r22, 0x06	; 6
   1e686:	00 0f       	add	r16, r16
   1e688:	11 1f       	adc	r17, r17
   1e68a:	6a 95       	dec	r22
   1e68c:	e1 f7       	brne	.-8      	; 0x1e686 <socket+0x38>
   1e68e:	dc 28       	or	r13, r12
   1e690:	c8 01       	movw	r24, r16
   1e692:	01 96       	adiw	r24, 0x01	; 1
   1e694:	6d 2d       	mov	r22, r13
   1e696:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
   1e69a:	c8 01       	movw	r24, r16
   1e69c:	0a 96       	adiw	r24, 0x0a	; 10
   1e69e:	05 5f       	subi	r16, 0xF5	; 245
   1e6a0:	1f 4f       	sbci	r17, 0xFF	; 255
#ifdef __DEF_IINCHIP_DBG__
		printf("Sn_MR(%d) = 0x%02x\r\n", s, IINCHIP_READ(Sn_MR(s)));
#endif
		if (port != 0) {
   1e6a2:	e1 14       	cp	r14, r1
   1e6a4:	f1 04       	cpc	r15, r1
   1e6a6:	31 f0       	breq	.+12     	; 0x1e6b4 <socket+0x66>
			IINCHIP_WRITE(Sn_PORTR(s),(uint8)((port & 0xff00) >> 8));
   1e6a8:	6f 2d       	mov	r22, r15
   1e6aa:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
			IINCHIP_WRITE((Sn_PORTR(s) + 1),(uint8)(port & 0x00ff));
   1e6ae:	c8 01       	movw	r24, r16
   1e6b0:	6e 2d       	mov	r22, r14
   1e6b2:	10 c0       	rjmp	.+32     	; 0x1e6d4 <socket+0x86>
		} else {
			local_port++; // if don't set the source port, set local_port number.
   1e6b4:	20 91 3e 03 	lds	r18, 0x033E
   1e6b8:	30 91 3f 03 	lds	r19, 0x033F
   1e6bc:	2f 5f       	subi	r18, 0xFF	; 255
   1e6be:	3f 4f       	sbci	r19, 0xFF	; 255
   1e6c0:	30 93 3f 03 	sts	0x033F, r19
   1e6c4:	20 93 3e 03 	sts	0x033E, r18
			IINCHIP_WRITE(Sn_PORTR(s),(uint8)((local_port & 0xff00) >> 8));
   1e6c8:	63 2f       	mov	r22, r19
   1e6ca:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
			IINCHIP_WRITE((Sn_PORTR(s) + 1),(uint8)(local_port & 0x00ff));
   1e6ce:	c8 01       	movw	r24, r16
   1e6d0:	60 91 3e 03 	lds	r22, 0x033E
   1e6d4:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		}
		IINCHIP_WRITE(Sn_CR(s), Sn_CR_OPEN); // run sockinit Sn_CR
   1e6d8:	56 e0       	ldi	r21, 0x06	; 6
   1e6da:	cc 0f       	add	r28, r28
   1e6dc:	dd 1f       	adc	r29, r29
   1e6de:	5a 95       	dec	r21
   1e6e0:	e1 f7       	brne	.-8      	; 0x1e6da <socket+0x8c>
   1e6e2:	ce 01       	movw	r24, r28
   1e6e4:	03 96       	adiw	r24, 0x03	; 3
   1e6e6:	61 e0       	ldi	r22, 0x01	; 1
   1e6e8:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		ret = 1;
		first_send_flag[s] = 1;
   1e6ec:	eb 2d       	mov	r30, r11
   1e6ee:	f0 e0       	ldi	r31, 0x00	; 0
   1e6f0:	ea 5c       	subi	r30, 0xCA	; 202
   1e6f2:	fc 4f       	sbci	r31, 0xFC	; 252
   1e6f4:	81 e0       	ldi	r24, 0x01	; 1
   1e6f6:	80 83       	st	Z, r24
	}
#ifdef __DEF_IINCHIP_DBG__
	printf("Sn_SSR = 0x%02x , Protocol = 0x%02x\r\n", getSn_SSR(s), IINCHIP_READ(Sn_MR(s)));
#endif
	return ret;
}
   1e6f8:	df 91       	pop	r29
   1e6fa:	cf 91       	pop	r28
   1e6fc:	1f 91       	pop	r17
   1e6fe:	0f 91       	pop	r16
   1e700:	ff 90       	pop	r15
   1e702:	ef 90       	pop	r14
   1e704:	df 90       	pop	r13
   1e706:	cf 90       	pop	r12
   1e708:	bf 90       	pop	r11
   1e70a:	08 95       	ret

0001e70c <listen>:
This function return 1 for success else 0.
*********************************************************************
*/

uint8 listen(SOCKET s)
{
   1e70c:	1f 93       	push	r17
   1e70e:	18 2f       	mov	r17, r24
	uint8 ret;
#ifdef __DEF_IINCHIP_DBG__
	printf("listen()\r\n");
#endif
	if( getSn_SSR(s) == SOCK_INIT )
   1e710:	0e 94 a0 f8 	call	0x1f140	; 0x1f140 <getSn_SSR>
   1e714:	83 31       	cpi	r24, 0x13	; 19
   1e716:	11 f0       	breq	.+4      	; 0x1e71c <listen+0x10>
   1e718:	80 e0       	ldi	r24, 0x00	; 0
   1e71a:	0d c0       	rjmp	.+26     	; 0x1e736 <listen+0x2a>
	{
		IINCHIP_WRITE(Sn_CR(s), Sn_CR_LISTEN);
   1e71c:	81 2f       	mov	r24, r17
   1e71e:	90 e0       	ldi	r25, 0x00	; 0
   1e720:	76 e0       	ldi	r23, 0x06	; 6
   1e722:	88 0f       	add	r24, r24
   1e724:	99 1f       	adc	r25, r25
   1e726:	7a 95       	dec	r23
   1e728:	e1 f7       	brne	.-8      	; 0x1e722 <listen+0x16>
   1e72a:	8d 5f       	subi	r24, 0xFD	; 253
   1e72c:	9d 47       	sbci	r25, 0x7D	; 125
   1e72e:	62 e0       	ldi	r22, 0x02	; 2
   1e730:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
   1e734:	81 e0       	ldi	r24, 0x01	; 1
#ifdef __DEF_IINCHIP_DBG__	
	printf("Sn_PORTR(%d) : 0x%02x\r\n", s, IINCHIP_READ(Sn_PORTR(s)));
	printf("Sn_PORTR(%d)+1 : 0x%02x\r\n", s, IINCHIP_READ(Sn_PORTR(s)+1));
#endif	
	return ret;
}
   1e736:	1f 91       	pop	r17
   1e738:	08 95       	ret

0001e73a <igmpsend>:
#endif
	return data_len;
}

uint16 igmpsend(SOCKET s, uint8 * buf, uint16 len)
{
   1e73a:	ff 92       	push	r15
   1e73c:	0f 93       	push	r16
   1e73e:	1f 93       	push	r17
   1e740:	cf 93       	push	r28
   1e742:	df 93       	push	r29
   1e744:	f8 2e       	mov	r15, r24
   1e746:	8b 01       	movw	r16, r22
   1e748:	ea 01       	movw	r28, r20
	uint16 ret=0;
	
#ifdef __DEF_IINCHIP_DBG__
	printf("igmpsend()\r\n");
#endif
   if (len > getIINCHIP_TxMAX(s)) ret = getIINCHIP_TxMAX(s); // check size not to exceed MAX size.
   1e74a:	0e 94 c4 fb 	call	0x1f788	; 0x1f788 <getIINCHIP_TxMAX>
   1e74e:	9e 01       	movw	r18, r28
   1e750:	40 e0       	ldi	r20, 0x00	; 0
   1e752:	50 e0       	ldi	r21, 0x00	; 0
   1e754:	62 17       	cp	r22, r18
   1e756:	73 07       	cpc	r23, r19
   1e758:	84 07       	cpc	r24, r20
   1e75a:	95 07       	cpc	r25, r21
   1e75c:	20 f4       	brcc	.+8      	; 0x1e766 <igmpsend+0x2c>
   1e75e:	8f 2d       	mov	r24, r15
   1e760:	0e 94 c4 fb 	call	0x1f788	; 0x1f788 <getIINCHIP_TxMAX>
   1e764:	eb 01       	movw	r28, r22
   else ret = len;

	if	(ret == 0) 
   1e766:	20 97       	sbiw	r28, 0x00	; 0
   1e768:	99 f1       	breq	.+102    	; 0x1e7d0 <igmpsend+0x96>
#endif
	}
	else
	{
		// copy data
      setSn_TX_WRSR(s,ret);
   1e76a:	ae 01       	movw	r20, r28
   1e76c:	60 e0       	ldi	r22, 0x00	; 0
   1e76e:	70 e0       	ldi	r23, 0x00	; 0
   1e770:	8f 2d       	mov	r24, r15
   1e772:	0e 94 7c f9 	call	0x1f2f8	; 0x1f2f8 <setSn_TX_WRSR>
      ret += (ret & 0x01);
   1e776:	ce 01       	movw	r24, r28
   1e778:	81 70       	andi	r24, 0x01	; 1
   1e77a:	90 70       	andi	r25, 0x00	; 0
   1e77c:	c8 0f       	add	r28, r24
   1e77e:	d9 1f       	adc	r29, r25
      wiz_write_buf(s, buf, ret);
   1e780:	9e 01       	movw	r18, r28
   1e782:	40 e0       	ldi	r20, 0x00	; 0
   1e784:	50 e0       	ldi	r21, 0x00	; 0
   1e786:	8f 2d       	mov	r24, r15
   1e788:	b8 01       	movw	r22, r16
   1e78a:	0e 94 62 fb 	call	0x1f6c4	; 0x1f6c4 <wiz_write_buf>
  	   IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
   1e78e:	8f 2d       	mov	r24, r15
   1e790:	90 e0       	ldi	r25, 0x00	; 0
   1e792:	e6 e0       	ldi	r30, 0x06	; 6
   1e794:	88 0f       	add	r24, r24
   1e796:	99 1f       	adc	r25, r25
   1e798:	ea 95       	dec	r30
   1e79a:	e1 f7       	brne	.-8      	; 0x1e794 <igmpsend+0x5a>
   1e79c:	8d 5f       	subi	r24, 0xFD	; 253
   1e79e:	9d 47       	sbci	r25, 0x7D	; 125
   1e7a0:	60 e2       	ldi	r22, 0x20	; 32
   1e7a2:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
   1e7a6:	07 c0       	rjmp	.+14     	; 0x1e7b6 <igmpsend+0x7c>
      while (!((isr=getSn_IR(s)) & Sn_IR_SENDOK))
      {
      	status = getSn_SSR(s);
   1e7a8:	8f 2d       	mov	r24, r15
   1e7aa:	0e 94 a0 f8 	call	0x1f140	; 0x1f140 <getSn_SSR>
			  if ((status == SOCK_CLOSED) || (isr & Sn_IR_TIMEOUT))
   1e7ae:	88 23       	and	r24, r24
   1e7b0:	49 f0       	breq	.+18     	; 0x1e7c4 <igmpsend+0x8a>
   1e7b2:	03 fd       	sbrc	r16, 3
   1e7b4:	07 c0       	rjmp	.+14     	; 0x1e7c4 <igmpsend+0x8a>
		// copy data
      setSn_TX_WRSR(s,ret);
      ret += (ret & 0x01);
      wiz_write_buf(s, buf, ret);
  	   IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
      while (!((isr=getSn_IR(s)) & Sn_IR_SENDOK))
   1e7b6:	8f 2d       	mov	r24, r15
   1e7b8:	0e 94 8a f8 	call	0x1f114	; 0x1f114 <getSn_IR>
   1e7bc:	08 2f       	mov	r16, r24
   1e7be:	84 ff       	sbrs	r24, 4
   1e7c0:	f3 cf       	rjmp	.-26     	; 0x1e7a8 <igmpsend+0x6e>
   1e7c2:	02 c0       	rjmp	.+4      	; 0x1e7c8 <igmpsend+0x8e>
   1e7c4:	c0 e0       	ldi	r28, 0x00	; 0
   1e7c6:	d0 e0       	ldi	r29, 0x00	; 0
			    printf("igmpsend fail.\r\n");
          #endif
				  ret = 0; break;
			    }
		  }
		setSn_IR(s, Sn_IR_SENDOK);
   1e7c8:	8f 2d       	mov	r24, r15
   1e7ca:	60 e1       	ldi	r22, 0x10	; 16
   1e7cc:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <setSn_IR>
	  
	}
	return ret;
}
   1e7d0:	ce 01       	movw	r24, r28
   1e7d2:	df 91       	pop	r29
   1e7d4:	cf 91       	pop	r28
   1e7d6:	1f 91       	pop	r17
   1e7d8:	0f 91       	pop	r16
   1e7da:	ff 90       	pop	r15
   1e7dc:	08 95       	ret

0001e7de <sendto>:
and "len" is the data size to send and addr is the peer's Destination IP address and port is
the peer's destination port number. This function return send data size for success else -1.
*********************************************************************
*/
uint16 sendto(SOCKET s, uint8 * buf, uint16 len, uint8 * addr, uint16 port)
{
   1e7de:	6f 92       	push	r6
   1e7e0:	7f 92       	push	r7
   1e7e2:	8f 92       	push	r8
   1e7e4:	9f 92       	push	r9
   1e7e6:	bf 92       	push	r11
   1e7e8:	cf 92       	push	r12
   1e7ea:	df 92       	push	r13
   1e7ec:	ef 92       	push	r14
   1e7ee:	ff 92       	push	r15
   1e7f0:	0f 93       	push	r16
   1e7f2:	1f 93       	push	r17
   1e7f4:	cf 93       	push	r28
   1e7f6:	df 93       	push	r29
   1e7f8:	b8 2e       	mov	r11, r24
   1e7fa:	3b 01       	movw	r6, r22
   1e7fc:	6a 01       	movw	r12, r20
   1e7fe:	e9 01       	movw	r28, r18
   1e800:	48 01       	movw	r8, r16
	uint16 ret=0;

#ifdef __DEF_IINCHIP_DBG__
//	printf("sendto()\r\n");
#endif
	if (len > getIINCHIP_TxMAX(s)) ret = getIINCHIP_TxMAX(s); // check size not to exceed MAX size.
   1e802:	0e 94 c4 fb 	call	0x1f788	; 0x1f788 <getIINCHIP_TxMAX>
   1e806:	96 01       	movw	r18, r12
   1e808:	40 e0       	ldi	r20, 0x00	; 0
   1e80a:	50 e0       	ldi	r21, 0x00	; 0
   1e80c:	62 17       	cp	r22, r18
   1e80e:	73 07       	cpc	r23, r19
   1e810:	84 07       	cpc	r24, r20
   1e812:	95 07       	cpc	r25, r21
   1e814:	20 f4       	brcc	.+8      	; 0x1e81e <sendto+0x40>
   1e816:	8b 2d       	mov	r24, r11
   1e818:	0e 94 c4 fb 	call	0x1f788	; 0x1f788 <getIINCHIP_TxMAX>
   1e81c:	6b 01       	movw	r12, r22
	else ret = len;

	if
		(
   1e81e:	68 81       	ld	r22, Y
   1e820:	66 23       	and	r22, r22
   1e822:	51 f4       	brne	.+20     	; 0x1e838 <sendto+0x5a>
   1e824:	89 81       	ldd	r24, Y+1	; 0x01
   1e826:	88 23       	and	r24, r24
   1e828:	39 f4       	brne	.+14     	; 0x1e838 <sendto+0x5a>
   1e82a:	8a 81       	ldd	r24, Y+2	; 0x02
   1e82c:	88 23       	and	r24, r24
   1e82e:	21 f4       	brne	.+8      	; 0x1e838 <sendto+0x5a>
   1e830:	8b 81       	ldd	r24, Y+3	; 0x03
   1e832:	88 23       	and	r24, r24
   1e834:	09 f4       	brne	.+2      	; 0x1e838 <sendto+0x5a>
   1e836:	5d c0       	rjmp	.+186    	; 0x1e8f2 <sendto+0x114>
   1e838:	81 14       	cp	r8, r1
   1e83a:	91 04       	cpc	r9, r1
   1e83c:	09 f4       	brne	.+2      	; 0x1e840 <sendto+0x62>
   1e83e:	59 c0       	rjmp	.+178    	; 0x1e8f2 <sendto+0x114>
   1e840:	c1 14       	cp	r12, r1
   1e842:	d1 04       	cpc	r13, r1
   1e844:	09 f4       	brne	.+2      	; 0x1e848 <sendto+0x6a>
   1e846:	55 c0       	rjmp	.+170    	; 0x1e8f2 <sendto+0x114>
	printf("Fail[invalid ip,port]\r\n");
#endif
	}
	else
	{
		IINCHIP_WRITE(Sn_DIPR(s), addr[0]);
   1e848:	eb 2c       	mov	r14, r11
   1e84a:	ff 24       	eor	r15, r15
   1e84c:	88 e0       	ldi	r24, 0x08	; 8
   1e84e:	92 e0       	ldi	r25, 0x02	; 2
   1e850:	e8 0e       	add	r14, r24
   1e852:	f9 1e       	adc	r15, r25
   1e854:	87 01       	movw	r16, r14
   1e856:	f6 e0       	ldi	r31, 0x06	; 6
   1e858:	00 0f       	add	r16, r16
   1e85a:	11 1f       	adc	r17, r17
   1e85c:	fa 95       	dec	r31
   1e85e:	e1 f7       	brne	.-8      	; 0x1e858 <sendto+0x7a>
   1e860:	c8 01       	movw	r24, r16
   1e862:	44 96       	adiw	r24, 0x14	; 20
   1e864:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR1(s), addr[1]);
   1e868:	c8 01       	movw	r24, r16
   1e86a:	45 96       	adiw	r24, 0x15	; 21
   1e86c:	69 81       	ldd	r22, Y+1	; 0x01
   1e86e:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR2(s), addr[2]);
   1e872:	c8 01       	movw	r24, r16
   1e874:	46 96       	adiw	r24, 0x16	; 22
   1e876:	6a 81       	ldd	r22, Y+2	; 0x02
   1e878:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DIPR3(s), addr[3]);
   1e87c:	c8 01       	movw	r24, r16
   1e87e:	47 96       	adiw	r24, 0x17	; 23
   1e880:	6b 81       	ldd	r22, Y+3	; 0x03
   1e882:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>

		IINCHIP_WRITE(Sn_DPORTR(s), port >> 8);
   1e886:	c8 01       	movw	r24, r16
   1e888:	42 96       	adiw	r24, 0x12	; 18
   1e88a:	69 2d       	mov	r22, r9
   1e88c:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
		IINCHIP_WRITE(Sn_DPORTR1(s), port & 0xff);
   1e890:	c8 01       	movw	r24, r16
   1e892:	43 96       	adiw	r24, 0x13	; 19
   1e894:	68 2d       	mov	r22, r8
   1e896:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>

		// copy data
		setSn_TX_WRSR(s, ret);
   1e89a:	a6 01       	movw	r20, r12
   1e89c:	60 e0       	ldi	r22, 0x00	; 0
   1e89e:	70 e0       	ldi	r23, 0x00	; 0
   1e8a0:	8b 2d       	mov	r24, r11
   1e8a2:	0e 94 7c f9 	call	0x1f2f8	; 0x1f2f8 <setSn_TX_WRSR>
		ret += (ret & 0x01);
   1e8a6:	c6 01       	movw	r24, r12
   1e8a8:	81 70       	andi	r24, 0x01	; 1
   1e8aa:	90 70       	andi	r25, 0x00	; 0
   1e8ac:	c8 0e       	add	r12, r24
   1e8ae:	d9 1e       	adc	r13, r25
		wiz_write_buf(s, buf, ret);
   1e8b0:	96 01       	movw	r18, r12
   1e8b2:	40 e0       	ldi	r20, 0x00	; 0
   1e8b4:	50 e0       	ldi	r21, 0x00	; 0
   1e8b6:	8b 2d       	mov	r24, r11
   1e8b8:	b3 01       	movw	r22, r6
   1e8ba:	0e 94 62 fb 	call	0x1f6c4	; 0x1f6c4 <wiz_write_buf>
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
   1e8be:	c8 01       	movw	r24, r16
   1e8c0:	03 96       	adiw	r24, 0x03	; 3
   1e8c2:	60 e2       	ldi	r22, 0x20	; 32
   1e8c4:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
   1e8c8:	07 c0       	rjmp	.+14     	; 0x1e8d8 <sendto+0xfa>
		while (!((isr = getSn_IR(s)) & Sn_IR_SENDOK))
		{
			status = getSn_SSR(s);
   1e8ca:	8b 2d       	mov	r24, r11
   1e8cc:	0e 94 a0 f8 	call	0x1f140	; 0x1f140 <getSn_SSR>

			if ((status == SOCK_CLOSED) || (isr & Sn_IR_TIMEOUT))
   1e8d0:	88 23       	and	r24, r24
   1e8d2:	49 f0       	breq	.+18     	; 0x1e8e6 <sendto+0x108>
   1e8d4:	c3 fd       	sbrc	r28, 3
   1e8d6:	07 c0       	rjmp	.+14     	; 0x1e8e6 <sendto+0x108>
		// copy data
		setSn_TX_WRSR(s, ret);
		ret += (ret & 0x01);
		wiz_write_buf(s, buf, ret);
		IINCHIP_WRITE(Sn_CR(s),Sn_CR_SEND);
		while (!((isr = getSn_IR(s)) & Sn_IR_SENDOK))
   1e8d8:	8b 2d       	mov	r24, r11
   1e8da:	0e 94 8a f8 	call	0x1f114	; 0x1f114 <getSn_IR>
   1e8de:	c8 2f       	mov	r28, r24
   1e8e0:	84 ff       	sbrs	r24, 4
   1e8e2:	f3 cf       	rjmp	.-26     	; 0x1e8ca <sendto+0xec>
   1e8e4:	02 c0       	rjmp	.+4      	; 0x1e8ea <sendto+0x10c>
   1e8e6:	cc 24       	eor	r12, r12
   1e8e8:	dd 24       	eor	r13, r13
//				printf("send fail.\r\n");
#endif
				ret = 0; break;
			}
		}
		setSn_IR(s, Sn_IR_SENDOK);
   1e8ea:	8b 2d       	mov	r24, r11
   1e8ec:	60 e1       	ldi	r22, 0x10	; 16
   1e8ee:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <setSn_IR>
	}
	return ret;
}
   1e8f2:	c6 01       	movw	r24, r12
   1e8f4:	df 91       	pop	r29
   1e8f6:	cf 91       	pop	r28
   1e8f8:	1f 91       	pop	r17
   1e8fa:	0f 91       	pop	r16
   1e8fc:	ff 90       	pop	r15
   1e8fe:	ef 90       	pop	r14
   1e900:	df 90       	pop	r13
   1e902:	cf 90       	pop	r12
   1e904:	bf 90       	pop	r11
   1e906:	9f 90       	pop	r9
   1e908:	8f 90       	pop	r8
   1e90a:	7f 90       	pop	r7
   1e90c:	6f 90       	pop	r6
   1e90e:	08 95       	ret

0001e910 <recv>:
to be received and "len" is the data size to be read. This function return received data size
for success else -1.
*********************************************************************
*/
uint32 recv(SOCKET s, uint8 * buf, uint32 len)
{
   1e910:	cf 92       	push	r12
   1e912:	df 92       	push	r13
   1e914:	ff 92       	push	r15
   1e916:	0f 93       	push	r16
   1e918:	1f 93       	push	r17
   1e91a:	df 93       	push	r29
   1e91c:	cf 93       	push	r28
   1e91e:	00 d0       	rcall	.+0      	; 0x1e920 <recv+0x10>
   1e920:	cd b7       	in	r28, 0x3d	; 61
   1e922:	de b7       	in	r29, 0x3e	; 62
   1e924:	f8 2e       	mov	r15, r24
   1e926:	6b 01       	movw	r12, r22
	uint16 pack_size = 0;
   1e928:	1a 82       	std	Y+2, r1	; 0x02
   1e92a:	19 82       	std	Y+1, r1	; 0x01

#ifdef __DEF_IINCHIP_DBG__
	printf("recv() : len=%08lx\r\n",len);
#endif

	if(IINCHIP_READ(Sn_MR(s)) & Sn_MR_ALIGN)
   1e92c:	08 2f       	mov	r16, r24
   1e92e:	10 e0       	ldi	r17, 0x00	; 0
   1e930:	08 5f       	subi	r16, 0xF8	; 248
   1e932:	1d 4f       	sbci	r17, 0xFD	; 253
   1e934:	c8 01       	movw	r24, r16
   1e936:	b6 e0       	ldi	r27, 0x06	; 6
   1e938:	88 0f       	add	r24, r24
   1e93a:	99 1f       	adc	r25, r25
   1e93c:	ba 95       	dec	r27
   1e93e:	e1 f7       	brne	.-8      	; 0x1e938 <recv+0x28>
   1e940:	01 96       	adiw	r24, 0x01	; 1
   1e942:	0e 94 e5 f6 	call	0x1edca	; 0x1edca <IINCHIP_READ>
		wiz_read_buf(s, buf, len);

		IINCHIP_WRITE(Sn_CR(s),Sn_CR_RECV);
		return len;
	}
	wiz_read_buf(s, (uint8*)&pack_size, 2);
   1e946:	8f 2d       	mov	r24, r15
   1e948:	be 01       	movw	r22, r28
   1e94a:	6f 5f       	subi	r22, 0xFF	; 255
   1e94c:	7f 4f       	sbci	r23, 0xFF	; 255
   1e94e:	22 e0       	ldi	r18, 0x02	; 2
   1e950:	30 e0       	ldi	r19, 0x00	; 0
   1e952:	40 e0       	ldi	r20, 0x00	; 0
   1e954:	50 e0       	ldi	r21, 0x00	; 0
   1e956:	0e 94 93 fb 	call	0x1f726	; 0x1f726 <wiz_read_buf>
	pack_size = SWAP16(pack_size);
   1e95a:	99 81       	ldd	r25, Y+1	; 0x01
   1e95c:	8a 81       	ldd	r24, Y+2	; 0x02

	len = pack_size;
   1e95e:	9c 01       	movw	r18, r24
   1e960:	40 e0       	ldi	r20, 0x00	; 0
   1e962:	50 e0       	ldi	r21, 0x00	; 0
	if(pack_size & 0x01) len += 1;
   1e964:	80 ff       	sbrs	r24, 0
   1e966:	04 c0       	rjmp	.+8      	; 0x1e970 <recv+0x60>
   1e968:	2f 5f       	subi	r18, 0xFF	; 255
   1e96a:	3f 4f       	sbci	r19, 0xFF	; 255
   1e96c:	4f 4f       	sbci	r20, 0xFF	; 255
   1e96e:	5f 4f       	sbci	r21, 0xFF	; 255

		IINCHIP_WRITE(Sn_CR(s),Sn_CR_RECV);
		return len;
	}
	wiz_read_buf(s, (uint8*)&pack_size, 2);
	pack_size = SWAP16(pack_size);
   1e970:	9a 83       	std	Y+2, r25	; 0x02
   1e972:	89 83       	std	Y+1, r24	; 0x01
	if(pack_size & 0x01) len += 1;
#ifdef __DEF_IINCHIP_DBG__   
	printf("%u:pack_size=%d\r\n", s, pack_size);
#endif

	wiz_read_buf(s, buf, len);
   1e974:	8f 2d       	mov	r24, r15
   1e976:	b6 01       	movw	r22, r12
   1e978:	0e 94 93 fb 	call	0x1f726	; 0x1f726 <wiz_read_buf>

	IINCHIP_WRITE(Sn_CR(s), Sn_CR_RECV);
   1e97c:	a6 e0       	ldi	r26, 0x06	; 6
   1e97e:	00 0f       	add	r16, r16
   1e980:	11 1f       	adc	r17, r17
   1e982:	aa 95       	dec	r26
   1e984:	e1 f7       	brne	.-8      	; 0x1e97e <recv+0x6e>
   1e986:	c8 01       	movw	r24, r16
   1e988:	03 96       	adiw	r24, 0x03	; 3
   1e98a:	60 e4       	ldi	r22, 0x40	; 64
   1e98c:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
	return (uint32)pack_size;
   1e990:	29 81       	ldd	r18, Y+1	; 0x01
   1e992:	3a 81       	ldd	r19, Y+2	; 0x02
   1e994:	40 e0       	ldi	r20, 0x00	; 0
   1e996:	50 e0       	ldi	r21, 0x00	; 0
}
   1e998:	b9 01       	movw	r22, r18
   1e99a:	ca 01       	movw	r24, r20
   1e99c:	0f 90       	pop	r0
   1e99e:	0f 90       	pop	r0
   1e9a0:	cf 91       	pop	r28
   1e9a2:	df 91       	pop	r29
   1e9a4:	1f 91       	pop	r17
   1e9a6:	0f 91       	pop	r16
   1e9a8:	ff 90       	pop	r15
   1e9aa:	df 90       	pop	r13
   1e9ac:	cf 90       	pop	r12
   1e9ae:	08 95       	ret

0001e9b0 <recvfrom>:
IP address and port is a pointer to store the peer's port number.
This function return received data size for success else -1.
*********************************************************************
*/
uint16 recvfrom(SOCKET s,	uint8 * buf, uint16 len, uint8 * addr, uint16 *port)
{
   1e9b0:	7f 92       	push	r7
   1e9b2:	8f 92       	push	r8
   1e9b4:	9f 92       	push	r9
   1e9b6:	af 92       	push	r10
   1e9b8:	bf 92       	push	r11
   1e9ba:	cf 92       	push	r12
   1e9bc:	df 92       	push	r13
   1e9be:	ef 92       	push	r14
   1e9c0:	ff 92       	push	r15
   1e9c2:	0f 93       	push	r16
   1e9c4:	1f 93       	push	r17
   1e9c6:	df 93       	push	r29
   1e9c8:	cf 93       	push	r28
   1e9ca:	cd b7       	in	r28, 0x3d	; 61
   1e9cc:	de b7       	in	r29, 0x3e	; 62
   1e9ce:	2c 97       	sbiw	r28, 0x0c	; 12
   1e9d0:	0f b6       	in	r0, 0x3f	; 63
   1e9d2:	f8 94       	cli
   1e9d4:	de bf       	out	0x3e, r29	; 62
   1e9d6:	0f be       	out	0x3f, r0	; 63
   1e9d8:	cd bf       	out	0x3d, r28	; 61
   1e9da:	78 2e       	mov	r7, r24
   1e9dc:	6b 01       	movw	r12, r22
   1e9de:	79 01       	movw	r14, r18

#ifdef __DEF_IINCHIP_DBG__
//	printf("recvfrom()\r\n");
#endif

	if ( len > 0 )
   1e9e0:	45 2b       	or	r20, r21
   1e9e2:	19 f4       	brne	.+6      	; 0x1e9ea <recvfrom+0x3a>
   1e9e4:	00 e0       	ldi	r16, 0x00	; 0
   1e9e6:	10 e0       	ldi	r17, 0x00	; 0
   1e9e8:	1a c1       	rjmp	.+564    	; 0x1ec1e <recvfrom+0x26e>
	{
		switch (IINCHIP_READ(Sn_MR(s)) & 0x07)
   1e9ea:	88 2e       	mov	r8, r24
   1e9ec:	99 24       	eor	r9, r9
   1e9ee:	88 e0       	ldi	r24, 0x08	; 8
   1e9f0:	92 e0       	ldi	r25, 0x02	; 2
   1e9f2:	88 0e       	add	r8, r24
   1e9f4:	99 1e       	adc	r9, r25
   1e9f6:	54 01       	movw	r10, r8
   1e9f8:	96 e0       	ldi	r25, 0x06	; 6
   1e9fa:	aa 0c       	add	r10, r10
   1e9fc:	bb 1c       	adc	r11, r11
   1e9fe:	9a 95       	dec	r25
   1ea00:	e1 f7       	brne	.-8      	; 0x1e9fa <recvfrom+0x4a>
   1ea02:	08 94       	sec
   1ea04:	a1 1c       	adc	r10, r1
   1ea06:	b1 1c       	adc	r11, r1
   1ea08:	c5 01       	movw	r24, r10
   1ea0a:	0e 94 e5 f6 	call	0x1edca	; 0x1edca <IINCHIP_READ>
   1ea0e:	90 e0       	ldi	r25, 0x00	; 0
   1ea10:	87 70       	andi	r24, 0x07	; 7
   1ea12:	90 70       	andi	r25, 0x00	; 0
   1ea14:	83 30       	cpi	r24, 0x03	; 3
   1ea16:	91 05       	cpc	r25, r1
   1ea18:	69 f1       	breq	.+90     	; 0x1ea74 <recvfrom+0xc4>
   1ea1a:	84 30       	cpi	r24, 0x04	; 4
   1ea1c:	91 05       	cpc	r25, r1
   1ea1e:	09 f4       	brne	.+2      	; 0x1ea22 <recvfrom+0x72>
   1ea20:	45 c0       	rjmp	.+138    	; 0x1eaac <recvfrom+0xfc>
   1ea22:	02 97       	sbiw	r24, 0x02	; 2
   1ea24:	19 f0       	breq	.+6      	; 0x1ea2c <recvfrom+0x7c>
   1ea26:	80 e0       	ldi	r24, 0x00	; 0
   1ea28:	90 e0       	ldi	r25, 0x00	; 0
   1ea2a:	4f c0       	rjmp	.+158    	; 0x1eaca <recvfrom+0x11a>
		{
			case Sn_MR_UDP :
				wiz_read_buf(s, head, 0x08);
   1ea2c:	87 2d       	mov	r24, r7
   1ea2e:	be 01       	movw	r22, r28
   1ea30:	6b 5f       	subi	r22, 0xFB	; 251
   1ea32:	7f 4f       	sbci	r23, 0xFF	; 255
   1ea34:	28 e0       	ldi	r18, 0x08	; 8
   1ea36:	30 e0       	ldi	r19, 0x00	; 0
   1ea38:	40 e0       	ldi	r20, 0x00	; 0
   1ea3a:	50 e0       	ldi	r21, 0x00	; 0
   1ea3c:	0e 94 93 fb 	call	0x1f726	; 0x1f726 <wiz_read_buf>
				// read peer's IP address, port number.
				addr[0] = head[0];
   1ea40:	8d 81       	ldd	r24, Y+5	; 0x05
   1ea42:	d7 01       	movw	r26, r14
   1ea44:	8c 93       	st	X, r24
				addr[1] = head[1];
   1ea46:	8e 81       	ldd	r24, Y+6	; 0x06
   1ea48:	11 96       	adiw	r26, 0x01	; 1
   1ea4a:	8c 93       	st	X, r24
   1ea4c:	11 97       	sbiw	r26, 0x01	; 1
				addr[2] = head[2];
   1ea4e:	8f 81       	ldd	r24, Y+7	; 0x07
   1ea50:	12 96       	adiw	r26, 0x02	; 2
   1ea52:	8c 93       	st	X, r24
   1ea54:	12 97       	sbiw	r26, 0x02	; 2
				addr[3] = head[3];
   1ea56:	88 85       	ldd	r24, Y+8	; 0x08
   1ea58:	13 96       	adiw	r26, 0x03	; 3
   1ea5a:	8c 93       	st	X, r24
				*port = head[4];
				*port = (*port << 8) + head[5];
   1ea5c:	99 85       	ldd	r25, Y+9	; 0x09
   1ea5e:	80 e0       	ldi	r24, 0x00	; 0
   1ea60:	2a 85       	ldd	r18, Y+10	; 0x0a
   1ea62:	82 0f       	add	r24, r18
   1ea64:	91 1d       	adc	r25, r1
   1ea66:	f8 01       	movw	r30, r16
   1ea68:	91 83       	std	Z+1, r25	; 0x01
   1ea6a:	80 83       	st	Z, r24
				data_len = (uint16)head[6];
				data_len = (data_len << 8) + (uint16)head[7];
   1ea6c:	9b 85       	ldd	r25, Y+11	; 0x0b
   1ea6e:	80 e0       	ldi	r24, 0x00	; 0
   1ea70:	2c 85       	ldd	r18, Y+12	; 0x0c
   1ea72:	29 c0       	rjmp	.+82     	; 0x1eac6 <recvfrom+0x116>
//				printf("source Port : %d\r\n", *port);
//				printf("source IP : %d.%d.%d.%d\r\n", addr[0], addr[1], addr[2], addr[3]);
#endif
				break;
			case Sn_MR_IPRAW :
				wiz_read_buf(s, head, 0x06);
   1ea74:	87 2d       	mov	r24, r7
   1ea76:	be 01       	movw	r22, r28
   1ea78:	6b 5f       	subi	r22, 0xFB	; 251
   1ea7a:	7f 4f       	sbci	r23, 0xFF	; 255
   1ea7c:	26 e0       	ldi	r18, 0x06	; 6
   1ea7e:	30 e0       	ldi	r19, 0x00	; 0
   1ea80:	40 e0       	ldi	r20, 0x00	; 0
   1ea82:	50 e0       	ldi	r21, 0x00	; 0
   1ea84:	0e 94 93 fb 	call	0x1f726	; 0x1f726 <wiz_read_buf>
				addr[0] = head[0];
   1ea88:	8d 81       	ldd	r24, Y+5	; 0x05
   1ea8a:	d7 01       	movw	r26, r14
   1ea8c:	8c 93       	st	X, r24
				addr[1] = head[1];
   1ea8e:	8e 81       	ldd	r24, Y+6	; 0x06
   1ea90:	11 96       	adiw	r26, 0x01	; 1
   1ea92:	8c 93       	st	X, r24
   1ea94:	11 97       	sbiw	r26, 0x01	; 1
				addr[2] = head[2];
   1ea96:	8f 81       	ldd	r24, Y+7	; 0x07
   1ea98:	12 96       	adiw	r26, 0x02	; 2
   1ea9a:	8c 93       	st	X, r24
   1ea9c:	12 97       	sbiw	r26, 0x02	; 2
				addr[3] = head[3];
   1ea9e:	88 85       	ldd	r24, Y+8	; 0x08
   1eaa0:	13 96       	adiw	r26, 0x03	; 3
   1eaa2:	8c 93       	st	X, r24
				data_len = (uint16)head[4];
				data_len = (data_len << 8) + (uint16)head[5];
   1eaa4:	99 85       	ldd	r25, Y+9	; 0x09
   1eaa6:	80 e0       	ldi	r24, 0x00	; 0
   1eaa8:	2a 85       	ldd	r18, Y+10	; 0x0a
   1eaaa:	0d c0       	rjmp	.+26     	; 0x1eac6 <recvfrom+0x116>
				printf("IP RAW msg arrived\r\n");
				printf("source IP : %d.%d.%d.%d\r\n", addr[0], addr[1], addr[2], addr[3]);
#endif
				break;
			case Sn_MR_MACRAW :
				wiz_read_buf(s, head, 2);
   1eaac:	87 2d       	mov	r24, r7
   1eaae:	be 01       	movw	r22, r28
   1eab0:	6b 5f       	subi	r22, 0xFB	; 251
   1eab2:	7f 4f       	sbci	r23, 0xFF	; 255
   1eab4:	22 e0       	ldi	r18, 0x02	; 2
   1eab6:	30 e0       	ldi	r19, 0x00	; 0
   1eab8:	40 e0       	ldi	r20, 0x00	; 0
   1eaba:	50 e0       	ldi	r21, 0x00	; 0
   1eabc:	0e 94 93 fb 	call	0x1f726	; 0x1f726 <wiz_read_buf>
				data_len = (uint16)head[0];
				data_len = (data_len<<8) + (uint16)head[1];
   1eac0:	9d 81       	ldd	r25, Y+5	; 0x05
   1eac2:	80 e0       	ldi	r24, 0x00	; 0
   1eac4:	2e 81       	ldd	r18, Y+6	; 0x06
   1eac6:	82 0f       	add	r24, r18
   1eac8:	91 1d       	adc	r25, r1
				break;

			default :
				break;
		}
		data_len += (data_len & 0x01);
   1eaca:	8c 01       	movw	r16, r24
   1eacc:	01 70       	andi	r16, 0x01	; 1
   1eace:	10 70       	andi	r17, 0x00	; 0
   1ead0:	08 0f       	add	r16, r24
   1ead2:	19 1f       	adc	r17, r25
		wiz_read_buf(s, buf, data_len); // data copy.
   1ead4:	98 01       	movw	r18, r16
   1ead6:	40 e0       	ldi	r20, 0x00	; 0
   1ead8:	50 e0       	ldi	r21, 0x00	; 0
   1eada:	87 2d       	mov	r24, r7
   1eadc:	b6 01       	movw	r22, r12
   1eade:	0e 94 93 fb 	call	0x1f726	; 0x1f726 <wiz_read_buf>
		if((IINCHIP_READ(Sn_MR(s)) & 0x07)==Sn_MR_MACRAW)
   1eae2:	c5 01       	movw	r24, r10
   1eae4:	0e 94 e5 f6 	call	0x1edca	; 0x1edca <IINCHIP_READ>
   1eae8:	87 70       	andi	r24, 0x07	; 7
   1eaea:	84 30       	cpi	r24, 0x04	; 4
   1eaec:	09 f0       	breq	.+2      	; 0x1eaf0 <recvfrom+0x140>
   1eaee:	8d c0       	rjmp	.+282    	; 0x1ec0a <recvfrom+0x25a>
		{
			uint8 crc[4];
#ifndef __DEF_IINCHIP_DGB__
				printf("MAC RAW msg arrived\r\n");
   1eaf0:	88 e5       	ldi	r24, 0x58	; 88
   1eaf2:	91 e0       	ldi	r25, 0x01	; 1
   1eaf4:	0e 94 17 fc 	call	0x1f82e	; 0x1f82e <puts>
				printf("dest mac=%.2X.%.2X.%.2X.%.2X.%.2X.%.2X\r\n",buf[0],buf[1],buf[2],buf[3],buf[4],buf[5]);
   1eaf8:	ed b7       	in	r30, 0x3d	; 61
   1eafa:	fe b7       	in	r31, 0x3e	; 62
   1eafc:	3e 97       	sbiw	r30, 0x0e	; 14
   1eafe:	0f b6       	in	r0, 0x3f	; 63
   1eb00:	f8 94       	cli
   1eb02:	fe bf       	out	0x3e, r31	; 62
   1eb04:	0f be       	out	0x3f, r0	; 63
   1eb06:	ed bf       	out	0x3d, r30	; 61
   1eb08:	31 96       	adiw	r30, 0x01	; 1
   1eb0a:	8d e6       	ldi	r24, 0x6D	; 109
   1eb0c:	91 e0       	ldi	r25, 0x01	; 1
   1eb0e:	ad b7       	in	r26, 0x3d	; 61
   1eb10:	be b7       	in	r27, 0x3e	; 62
   1eb12:	12 96       	adiw	r26, 0x02	; 2
   1eb14:	9c 93       	st	X, r25
   1eb16:	8e 93       	st	-X, r24
   1eb18:	11 97       	sbiw	r26, 0x01	; 1
   1eb1a:	d6 01       	movw	r26, r12
   1eb1c:	8c 91       	ld	r24, X
   1eb1e:	82 83       	std	Z+2, r24	; 0x02
   1eb20:	13 82       	std	Z+3, r1	; 0x03
   1eb22:	11 96       	adiw	r26, 0x01	; 1
   1eb24:	8c 91       	ld	r24, X
   1eb26:	11 97       	sbiw	r26, 0x01	; 1
   1eb28:	84 83       	std	Z+4, r24	; 0x04
   1eb2a:	15 82       	std	Z+5, r1	; 0x05
   1eb2c:	12 96       	adiw	r26, 0x02	; 2
   1eb2e:	8c 91       	ld	r24, X
   1eb30:	12 97       	sbiw	r26, 0x02	; 2
   1eb32:	86 83       	std	Z+6, r24	; 0x06
   1eb34:	17 82       	std	Z+7, r1	; 0x07
   1eb36:	13 96       	adiw	r26, 0x03	; 3
   1eb38:	8c 91       	ld	r24, X
   1eb3a:	13 97       	sbiw	r26, 0x03	; 3
   1eb3c:	80 87       	std	Z+8, r24	; 0x08
   1eb3e:	11 86       	std	Z+9, r1	; 0x09
   1eb40:	14 96       	adiw	r26, 0x04	; 4
   1eb42:	8c 91       	ld	r24, X
   1eb44:	14 97       	sbiw	r26, 0x04	; 4
   1eb46:	82 87       	std	Z+10, r24	; 0x0a
   1eb48:	13 86       	std	Z+11, r1	; 0x0b
   1eb4a:	15 96       	adiw	r26, 0x05	; 5
   1eb4c:	8c 91       	ld	r24, X
   1eb4e:	84 87       	std	Z+12, r24	; 0x0c
   1eb50:	15 86       	std	Z+13, r1	; 0x0d
   1eb52:	0e 94 02 fc 	call	0x1f804	; 0x1f804 <printf>
				printf("src  mac=%.2X.%.2X.%.2X.%.2X.%.2X.%.2X\r\n",buf[6],buf[7],buf[8],buf[9],buf[10],buf[11]);
   1eb56:	ed b7       	in	r30, 0x3d	; 61
   1eb58:	fe b7       	in	r31, 0x3e	; 62
   1eb5a:	31 96       	adiw	r30, 0x01	; 1
   1eb5c:	86 e9       	ldi	r24, 0x96	; 150
   1eb5e:	91 e0       	ldi	r25, 0x01	; 1
   1eb60:	ad b7       	in	r26, 0x3d	; 61
   1eb62:	be b7       	in	r27, 0x3e	; 62
   1eb64:	12 96       	adiw	r26, 0x02	; 2
   1eb66:	9c 93       	st	X, r25
   1eb68:	8e 93       	st	-X, r24
   1eb6a:	11 97       	sbiw	r26, 0x01	; 1
   1eb6c:	d6 01       	movw	r26, r12
   1eb6e:	16 96       	adiw	r26, 0x06	; 6
   1eb70:	8c 91       	ld	r24, X
   1eb72:	16 97       	sbiw	r26, 0x06	; 6
   1eb74:	82 83       	std	Z+2, r24	; 0x02
   1eb76:	13 82       	std	Z+3, r1	; 0x03
   1eb78:	17 96       	adiw	r26, 0x07	; 7
   1eb7a:	8c 91       	ld	r24, X
   1eb7c:	17 97       	sbiw	r26, 0x07	; 7
   1eb7e:	84 83       	std	Z+4, r24	; 0x04
   1eb80:	15 82       	std	Z+5, r1	; 0x05
   1eb82:	18 96       	adiw	r26, 0x08	; 8
   1eb84:	8c 91       	ld	r24, X
   1eb86:	18 97       	sbiw	r26, 0x08	; 8
   1eb88:	86 83       	std	Z+6, r24	; 0x06
   1eb8a:	17 82       	std	Z+7, r1	; 0x07
   1eb8c:	19 96       	adiw	r26, 0x09	; 9
   1eb8e:	8c 91       	ld	r24, X
   1eb90:	19 97       	sbiw	r26, 0x09	; 9
   1eb92:	80 87       	std	Z+8, r24	; 0x08
   1eb94:	11 86       	std	Z+9, r1	; 0x09
   1eb96:	1a 96       	adiw	r26, 0x0a	; 10
   1eb98:	8c 91       	ld	r24, X
   1eb9a:	1a 97       	sbiw	r26, 0x0a	; 10
   1eb9c:	82 87       	std	Z+10, r24	; 0x0a
   1eb9e:	13 86       	std	Z+11, r1	; 0x0b
   1eba0:	1b 96       	adiw	r26, 0x0b	; 11
   1eba2:	8c 91       	ld	r24, X
   1eba4:	84 87       	std	Z+12, r24	; 0x0c
   1eba6:	15 86       	std	Z+13, r1	; 0x0d
   1eba8:	0e 94 02 fc 	call	0x1f804	; 0x1f804 <printf>
				printf("type    =%.2X%.2X\r\n",buf[12],buf[13]); 
   1ebac:	ed b7       	in	r30, 0x3d	; 61
   1ebae:	fe b7       	in	r31, 0x3e	; 62
   1ebb0:	38 96       	adiw	r30, 0x08	; 8
   1ebb2:	0f b6       	in	r0, 0x3f	; 63
   1ebb4:	f8 94       	cli
   1ebb6:	fe bf       	out	0x3e, r31	; 62
   1ebb8:	0f be       	out	0x3f, r0	; 63
   1ebba:	ed bf       	out	0x3d, r30	; 61
   1ebbc:	31 96       	adiw	r30, 0x01	; 1
   1ebbe:	8f eb       	ldi	r24, 0xBF	; 191
   1ebc0:	91 e0       	ldi	r25, 0x01	; 1
   1ebc2:	ad b7       	in	r26, 0x3d	; 61
   1ebc4:	be b7       	in	r27, 0x3e	; 62
   1ebc6:	12 96       	adiw	r26, 0x02	; 2
   1ebc8:	9c 93       	st	X, r25
   1ebca:	8e 93       	st	-X, r24
   1ebcc:	11 97       	sbiw	r26, 0x01	; 1
   1ebce:	d6 01       	movw	r26, r12
   1ebd0:	1c 96       	adiw	r26, 0x0c	; 12
   1ebd2:	8c 91       	ld	r24, X
   1ebd4:	1c 97       	sbiw	r26, 0x0c	; 12
   1ebd6:	82 83       	std	Z+2, r24	; 0x02
   1ebd8:	13 82       	std	Z+3, r1	; 0x03
   1ebda:	1d 96       	adiw	r26, 0x0d	; 13
   1ebdc:	8c 91       	ld	r24, X
   1ebde:	84 83       	std	Z+4, r24	; 0x04
   1ebe0:	15 82       	std	Z+5, r1	; 0x05
   1ebe2:	0e 94 02 fc 	call	0x1f804	; 0x1f804 <printf>
#endif				
			wiz_read_buf(s, crc, 4);
   1ebe6:	ed b7       	in	r30, 0x3d	; 61
   1ebe8:	fe b7       	in	r31, 0x3e	; 62
   1ebea:	36 96       	adiw	r30, 0x06	; 6
   1ebec:	0f b6       	in	r0, 0x3f	; 63
   1ebee:	f8 94       	cli
   1ebf0:	fe bf       	out	0x3e, r31	; 62
   1ebf2:	0f be       	out	0x3f, r0	; 63
   1ebf4:	ed bf       	out	0x3d, r30	; 61
   1ebf6:	87 2d       	mov	r24, r7
   1ebf8:	be 01       	movw	r22, r28
   1ebfa:	6f 5f       	subi	r22, 0xFF	; 255
   1ebfc:	7f 4f       	sbci	r23, 0xFF	; 255
   1ebfe:	24 e0       	ldi	r18, 0x04	; 4
   1ec00:	30 e0       	ldi	r19, 0x00	; 0
   1ec02:	40 e0       	ldi	r20, 0x00	; 0
   1ec04:	50 e0       	ldi	r21, 0x00	; 0
   1ec06:	0e 94 93 fb 	call	0x1f726	; 0x1f726 <wiz_read_buf>
		}
		IINCHIP_WRITE(Sn_CR(s), Sn_CR_RECV);
   1ec0a:	86 e0       	ldi	r24, 0x06	; 6
   1ec0c:	88 0c       	add	r8, r8
   1ec0e:	99 1c       	adc	r9, r9
   1ec10:	8a 95       	dec	r24
   1ec12:	e1 f7       	brne	.-8      	; 0x1ec0c <recvfrom+0x25c>
   1ec14:	c4 01       	movw	r24, r8
   1ec16:	03 96       	adiw	r24, 0x03	; 3
   1ec18:	60 e4       	ldi	r22, 0x40	; 64
   1ec1a:	0e 94 e8 f6 	call	0x1edd0	; 0x1edd0 <IINCHIP_WRITE>
	}
#ifdef __DEF_IINCHIP_DBG__
//	printf("recvfrom() end ..\r\n");
#endif
	return data_len;
}
   1ec1e:	c8 01       	movw	r24, r16
   1ec20:	2c 96       	adiw	r28, 0x0c	; 12
   1ec22:	0f b6       	in	r0, 0x3f	; 63
   1ec24:	f8 94       	cli
   1ec26:	de bf       	out	0x3e, r29	; 62
   1ec28:	0f be       	out	0x3f, r0	; 63
   1ec2a:	cd bf       	out	0x3d, r28	; 61
   1ec2c:	cf 91       	pop	r28
   1ec2e:	df 91       	pop	r29
   1ec30:	1f 91       	pop	r17
   1ec32:	0f 91       	pop	r16
   1ec34:	ff 90       	pop	r15
   1ec36:	ef 90       	pop	r14
   1ec38:	df 90       	pop	r13
   1ec3a:	cf 90       	pop	r12
   1ec3c:	bf 90       	pop	r11
   1ec3e:	af 90       	pop	r10
   1ec40:	9f 90       	pop	r9
   1ec42:	8f 90       	pop	r8
   1ec44:	7f 90       	pop	r7
   1ec46:	08 95       	ret

0001ec48 <send>:
This function return 1 for success else 0.
*********************************************************************
*/

uint32   send(SOCKET s, uint8 * buf, uint32 len)
{
   1ec48:	9f 92       	push	r9
   1ec4a:	af 92       	push	r10
   1ec4c:	bf 92       	push	r11
   1ec4e:	cf 92       	push	r12
   1ec50:	df 92       	push	r13
   1ec52:	ef 92       	push	r14
   1ec54:	ff 92       	push	r15
   1ec56:	0f 93       	push	r16
   1ec58:	1f 93       	push	r17
   1ec5a:	cf 93       	push	r28
   1ec5c:	df 93       	push	r29
   1ec5e:	98 2e       	mov	r9, r24
   1ec60:	eb 01       	movw	r28, r22
   1ec62:	79 01       	movw	r14, r18
   1ec64:	8a 01       	movw	r16, r20

      printf("%d : send()\r\n",s);
   #endif
   
   ret = len;
   if (len > getIINCHIP_TxMAX(s)) ret = getIINCHIP_TxMAX(s); // check size not to exceed MAX size.
   1ec66:	0e 94 c4 fb 	call	0x1f788	; 0x1f788 <getIINCHIP_TxMAX>
   1ec6a:	6e 15       	cp	r22, r14
   1ec6c:	7f 05       	cpc	r23, r15
   1ec6e:	80 07       	cpc	r24, r16
   1ec70:	91 07       	cpc	r25, r17
   1ec72:	28 f4       	brcc	.+10     	; 0x1ec7e <send+0x36>
   1ec74:	89 2d       	mov	r24, r9
   1ec76:	0e 94 c4 fb 	call	0x1f788	; 0x1f788 <getIINCHIP_TxMAX>
   1ec7a:	7b 01       	movw	r14, r22
   1ec7c:	8c 01       	movw	r16, r24
    */
   // -----------------------
   // NOTE : CODE BLOCK START
   do                                   
   {
      freesize = getSn_TX_FSR(s);
   1ec7e:	89 2d       	mov	r24, r9
   1ec80:	0e 94 92 f9 	call	0x1f324	; 0x1f324 <getSn_TX_FSR>
   1ec84:	5b 01       	movw	r10, r22
   1ec86:	6c 01       	movw	r12, r24
      status = getSn_SSR(s);
   1ec88:	89 2d       	mov	r24, r9
   1ec8a:	0e 94 a0 f8 	call	0x1f140	; 0x1f140 <getSn_SSR>
            printf("%d:Send Size=%08lx(%d)\r\n",s,ret,ret);
            printf("MR=%04x\r\n",*((vuint16*)MR));
            loopcnt = 0;
         }
      #endif
      if ((status != SOCK_ESTABLISHED) && (status != SOCK_CLOSE_WAIT)) return 0;
   1ec8e:	87 31       	cpi	r24, 0x17	; 23
   1ec90:	11 f0       	breq	.+4      	; 0x1ec96 <send+0x4e>
   1ec92:	8c 31       	cpi	r24, 0x1C	; 28
   1ec94:	d9 f5       	brne	.+118    	; 0x1ed0c <send+0xc4>
   } while (freesize < ret);
   1ec96:	ae 14       	cp	r10, r14
   1ec98:	bf 04       	cpc	r11, r15
   1ec9a:	c0 06       	cpc	r12, r16
   1ec9c:	d1 06       	cpc	r13, r17
   1ec9e:	78 f3       	brcs	.-34     	; 0x1ec7e <send+0x36>
   // NOTE : CODE BLOCK END
   // ---------------------
   
	 if(ret & 0x01) wiz_write_buf(s, buf, (ret+1));
   1eca0:	c7 01       	movw	r24, r14
   1eca2:	81 70       	andi	r24, 0x01	; 1
   1eca4:	90 70       	andi	r25, 0x00	; 0
   1eca6:	89 2b       	or	r24, r25
   1eca8:	49 f0       	breq	.+18     	; 0x1ecbc <send+0x74>
   1ecaa:	a8 01       	movw	r20, r16
   1ecac:	97 01       	movw	r18, r14
   1ecae:	2f 5f       	subi	r18, 0xFF	; 255
   1ecb0:	3f 4f       	sbci	r19, 0xFF	; 255
   1ecb2:	4f 4f       	sbci	r20, 0xFF	; 255
   1ecb4:	5f 4f       	sbci	r21, 0xFF	; 255
   1ecb6:	89 2d       	mov	r24, r9
   1ecb8:	be 01       	movw	r22, r28
   1ecba:	04 c0       	rjmp	.+8      	; 0x1ecc4 <send+0x7c>
	 else wiz_write_buf(s,buf,ret);                   // copy data
   1ecbc:	89 2d       	mov	r24, r9
   1ecbe:	be 01       	movw	r22, r28
   1ecc0:	a8 01       	movw	r20, r16
   1ecc2:	97 01       	movw	r18, r14
   1ecc4:	0e 94 62 fb 	call	0x1f6c4	; 0x1f6c4 <wiz_write_buf>

   #ifdef __DEF_IINCHIP_DBG__
      loopcnt=0;
   #endif   
   
   if(!first_send_flag[s])                	 // if first send, skip.
   1ecc8:	e9 2d       	mov	r30, r9
   1ecca:	f0 e0       	ldi	r31, 0x00	; 0
   1eccc:	ea 5c       	subi	r30, 0xCA	; 202
   1ecce:	fc 4f       	sbci	r31, 0xFC	; 252
   1ecd0:	80 81       	ld	r24, Z
   1ecd2:	88 23       	and	r24, r24
   1ecd4:	31 f0       	breq	.+12     	; 0x1ece2 <send+0x9a>
   1ecd6:	0f c0       	rjmp	.+30     	; 0x1ecf6 <send+0xae>
            printf("%d:Send Size=%08lx(%d)\r\n",s,ret,ret);
            printf("MR=%04x\r\n",*((vuint16*)MR));
            loopcnt = 0;
         }
      #endif
         if (getSn_SSR(s) == SOCK_CLOSED)    // check timeout or abnormal closed.
   1ecd8:	89 2d       	mov	r24, r9
   1ecda:	0e 94 a0 f8 	call	0x1f140	; 0x1f140 <getSn_SSR>
   1ecde:	88 23       	and	r24, r24
   1ece0:	a9 f0       	breq	.+42     	; 0x1ed0c <send+0xc4>
      loopcnt=0;
   #endif   
   
   if(!first_send_flag[s])                	 // if first send, skip.
   {
      while (!(getSn_IR(s) & Sn_IR_SENDOK))  // wait previous SEND command completion.
   1ece2:	89 2d       	mov	r24, r9
   1ece4:	0e 94 8a f8 	call	0x1f114	; 0x1f114 <getSn_IR>
   1ece8:	84 ff       	sbrs	r24, 4
   1ecea:	f6 cf       	rjmp	.-20     	; 0x1ecd8 <send+0x90>
               printf("%d : Send Fail. SOCK_CLOSED.\r\n",s);
            #endif
            return 0;
         }
      }
      setSn_IR(s, Sn_IR_SENDOK);             // clear Sn_IR_SENDOK	
   1ecec:	89 2d       	mov	r24, r9
   1ecee:	60 e1       	ldi	r22, 0x10	; 16
   1ecf0:	0e 94 95 f8 	call	0x1f12a	; 0x1f12a <setSn_IR>
   1ecf4:	01 c0       	rjmp	.+2      	; 0x1ecf8 <send+0xb0>
   }
   else first_send_flag[s] = 0;
   1ecf6:	10 82       	st	Z, r1
   
   // send
   setSn_TX_WRSR(s,ret);   
   1ecf8:	89 2d       	mov	r24, r9
   1ecfa:	b8 01       	movw	r22, r16
   1ecfc:	a7 01       	movw	r20, r14
   1ecfe:	0e 94 7c f9 	call	0x1f2f8	; 0x1f2f8 <setSn_TX_WRSR>
   setSn_CR(s,Sn_CR_SEND);
   1ed02:	89 2d       	mov	r24, r9
   1ed04:	60 e2       	ldi	r22, 0x20	; 32
   1ed06:	0e 94 64 f8 	call	0x1f0c8	; 0x1f0c8 <setSn_CR>
   1ed0a:	03 c0       	rjmp	.+6      	; 0x1ed12 <send+0xca>
   return ret;
   1ed0c:	ee 24       	eor	r14, r14
   1ed0e:	ff 24       	eor	r15, r15
   1ed10:	87 01       	movw	r16, r14
}
   1ed12:	b7 01       	movw	r22, r14
   1ed14:	c8 01       	movw	r24, r16
   1ed16:	df 91       	pop	r29
   1ed18:	cf 91       	pop	r28
   1ed1a:	1f 91       	pop	r17
   1ed1c:	0f 91       	pop	r16
   1ed1e:	ff 90       	pop	r15
   1ed20:	ef 90       	pop	r14
   1ed22:	df 90       	pop	r13
   1ed24:	cf 90       	pop	r12
   1ed26:	bf 90       	pop	r11
   1ed28:	af 90       	pop	r10
   1ed2a:	9f 90       	pop	r9
   1ed2c:	08 95       	ret

0001ed2e <initUart>:
#include <avr/io.h>
#include "serial.h"

void initUart(void){
	/* set baud rate */
	UBRR0H = (uchar) (UART_BAUD_SELECT>>8);
   1ed2e:	10 92 90 00 	sts	0x0090, r1
	UBRR0L = (uchar) UART_BAUD_SELECT;
   1ed32:	80 e1       	ldi	r24, 0x10	; 16
   1ed34:	89 b9       	out	0x09, r24	; 9

	/* Enable UART receiver and transmitter */
	UCSR0A = ( 1 << U2X0 );
   1ed36:	82 e0       	ldi	r24, 0x02	; 2
   1ed38:	8b b9       	out	0x0b, r24	; 11
	UCSR0B = ( 1 << TXEN0 ); 
   1ed3a:	88 e0       	ldi	r24, 0x08	; 8
   1ed3c:	8a b9       	out	0x0a, r24	; 10

//	fdevopen((void*)USART0_Transmit, (void*)USART0_Receive);
}
   1ed3e:	08 95       	ret

0001ed40 <USART0_Transmit>:

void USART0_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
   1ed40:	5d 9b       	sbis	0x0b, 5	; 11
   1ed42:	fe cf       	rjmp	.-4      	; 0x1ed40 <USART0_Transmit>
		; 			                
	/* Start transmittion */
	UDR0 = data; 			        
   1ed44:	8c b9       	out	0x0c, r24	; 12
}
   1ed46:	08 95       	ret

0001ed48 <putStr>:

void putStr(unsigned char* data)
{
   1ed48:	fc 01       	movw	r30, r24
   1ed4a:	04 c0       	rjmp	.+8      	; 0x1ed54 <putStr+0xc>
}

void USART0_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
   1ed4c:	5d 9b       	sbis	0x0b, 5	; 11
   1ed4e:	fe cf       	rjmp	.-4      	; 0x1ed4c <putStr+0x4>
	UDR0 = data; 			        
}

void putStr(unsigned char* data)
{
	for(;*data;) USART0_Transmit(*(data++));
   1ed50:	31 96       	adiw	r30, 0x01	; 1
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
		; 			                
	/* Start transmittion */
	UDR0 = data; 			        
   1ed52:	8c b9       	out	0x0c, r24	; 12
}

void putStr(unsigned char* data)
{
	for(;*data;) USART0_Transmit(*(data++));
   1ed54:	80 81       	ld	r24, Z
   1ed56:	88 23       	and	r24, r24
   1ed58:	c9 f7       	brne	.-14     	; 0x1ed4c <putStr+0x4>
}
   1ed5a:	08 95       	ret

0001ed5c <putData>:

void putData(unsigned char* data, uint len)
{
   1ed5c:	1f 93       	push	r17
   1ed5e:	fc 01       	movw	r30, r24
   1ed60:	40 e0       	ldi	r20, 0x00	; 0
   1ed62:	20 e0       	ldi	r18, 0x00	; 0
   1ed64:	30 e0       	ldi	r19, 0x00	; 0
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
		; 			                
	/* Start transmittion */
	UDR0 = data; 			        
   1ed66:	10 e2       	ldi	r17, 0x20	; 32
	uchar temp, hn, ln, lf;
	uint i;

	lf = 0;
	for(i = 0; i < len; i++) {
		temp = *(data++);
   1ed68:	bd e0       	ldi	r27, 0x0D	; 13
   1ed6a:	aa e0       	ldi	r26, 0x0A	; 10
   1ed6c:	29 c0       	rjmp	.+82     	; 0x1edc0 <putData+0x64>
   1ed6e:	90 81       	ld	r25, Z

		hn = (temp >> 4);
   1ed70:	89 2f       	mov	r24, r25
   1ed72:	82 95       	swap	r24
   1ed74:	8f 70       	andi	r24, 0x0F	; 15
		if(hn > 9) hn += ('a' - 10);
   1ed76:	8a 30       	cpi	r24, 0x0A	; 10
   1ed78:	18 f0       	brcs	.+6      	; 0x1ed80 <putData+0x24>
   1ed7a:	58 2f       	mov	r21, r24
   1ed7c:	59 5a       	subi	r21, 0xA9	; 169
   1ed7e:	02 c0       	rjmp	.+4      	; 0x1ed84 <putData+0x28>
		else hn += 0x30;
   1ed80:	58 2f       	mov	r21, r24
   1ed82:	50 5d       	subi	r21, 0xD0	; 208

		ln = (temp & 0x0f);
   1ed84:	89 2f       	mov	r24, r25
   1ed86:	8f 70       	andi	r24, 0x0F	; 15
		if(ln > 9) ln += ('a' - 10);
   1ed88:	8a 30       	cpi	r24, 0x0A	; 10
   1ed8a:	10 f0       	brcs	.+4      	; 0x1ed90 <putData+0x34>
   1ed8c:	89 5a       	subi	r24, 0xA9	; 169
   1ed8e:	01 c0       	rjmp	.+2      	; 0x1ed92 <putData+0x36>
		else ln += 0x30;
   1ed90:	80 5d       	subi	r24, 0xD0	; 208
}

void USART0_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
   1ed92:	5d 9b       	sbis	0x0b, 5	; 11
   1ed94:	fe cf       	rjmp	.-4      	; 0x1ed92 <putData+0x36>
		; 			                
	/* Start transmittion */
	UDR0 = data; 			        
   1ed96:	5c b9       	out	0x0c, r21	; 12
}

void USART0_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
   1ed98:	5d 9b       	sbis	0x0b, 5	; 11
   1ed9a:	fe cf       	rjmp	.-4      	; 0x1ed98 <putData+0x3c>
		; 			                
	/* Start transmittion */
	UDR0 = data; 			        
   1ed9c:	8c b9       	out	0x0c, r24	; 12
}

void USART0_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
   1ed9e:	5d 9b       	sbis	0x0b, 5	; 11
   1eda0:	fe cf       	rjmp	.-4      	; 0x1ed9e <putData+0x42>
		; 			                
	/* Start transmittion */
	UDR0 = data; 			        
   1eda2:	1c b9       	out	0x0c, r17	; 12

		USART0_Transmit(hn);
		USART0_Transmit(ln);
		USART0_Transmit(' ');

		if(lf == 16) {
   1eda4:	40 31       	cpi	r20, 0x10	; 16
   1eda6:	41 f4       	brne	.+16     	; 0x1edb8 <putData+0x5c>
}

void USART0_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
   1eda8:	5d 9b       	sbis	0x0b, 5	; 11
   1edaa:	fe cf       	rjmp	.-4      	; 0x1eda8 <putData+0x4c>
		; 			                
	/* Start transmittion */
	UDR0 = data; 			        
   1edac:	bc b9       	out	0x0c, r27	; 12
}

void USART0_Transmit( unsigned char data )
{
	/* Wait for empty transmit buffer */
	while ( !(UCSR0A & (1<<UDRE0)) )
   1edae:	5d 9b       	sbis	0x0b, 5	; 11
   1edb0:	fe cf       	rjmp	.-4      	; 0x1edae <putData+0x52>
		; 			                
	/* Start transmittion */
	UDR0 = data; 			        
   1edb2:	ac b9       	out	0x0c, r26	; 12
   1edb4:	40 e0       	ldi	r20, 0x00	; 0
   1edb6:	01 c0       	rjmp	.+2      	; 0x1edba <putData+0x5e>
		if(lf == 16) {
			lf = 0;
			USART0_Transmit('\r');
			USART0_Transmit('\n');
		}
		else lf++;
   1edb8:	4f 5f       	subi	r20, 0xFF	; 255
	uchar temp, hn, ln, lf;
	uint i;

	lf = 0;
	for(i = 0; i < len; i++) {
		temp = *(data++);
   1edba:	31 96       	adiw	r30, 0x01	; 1
{
	uchar temp, hn, ln, lf;
	uint i;

	lf = 0;
	for(i = 0; i < len; i++) {
   1edbc:	2f 5f       	subi	r18, 0xFF	; 255
   1edbe:	3f 4f       	sbci	r19, 0xFF	; 255
   1edc0:	26 17       	cp	r18, r22
   1edc2:	37 07       	cpc	r19, r23
   1edc4:	a0 f2       	brcs	.-88     	; 0x1ed6e <putData+0x12>
			USART0_Transmit('\r');
			USART0_Transmit('\n');
		}
		else lf++;
	}
}
   1edc6:	1f 91       	pop	r17
   1edc8:	08 95       	ret

0001edca <IINCHIP_READ>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1edca:	fc 01       	movw	r30, r24
   1edcc:	80 81       	ld	r24, Z
	  if(addr &0x01) data = *((vuint8*)IDM_DR1);
	  else data = *((vuint8*)IDM_DR);

   return data;
#endif
}
   1edce:	08 95       	ret

0001edd0 <IINCHIP_WRITE>:

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1edd0:	fc 01       	movw	r30, r24
   1edd2:	60 83       	st	Z, r22
    *((vuint8*)IDM_AR) = addr >> 8;
	  *((vuint8*)IDM_AR1) = addr;
	  if(addr &0x01) *((vuint8*)IDM_DR1) = data;
	  else *((vuint8*)IDM_DR) = data;
#endif
}
   1edd4:	08 95       	ret

0001edd6 <getMR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1edd6:	40 91 00 80 	lds	r20, 0x8000


uint16   getMR(void)
{
   return (IINCHIP_READ(MR_) << 8 | IINCHIP_READ(MR));
}
   1edda:	20 91 01 80 	lds	r18, 0x8001
   1edde:	94 2f       	mov	r25, r20
   1ede0:	80 e0       	ldi	r24, 0x00	; 0
   1ede2:	30 e0       	ldi	r19, 0x00	; 0
   1ede4:	28 2b       	or	r18, r24
   1ede6:	39 2b       	or	r19, r25
   1ede8:	c9 01       	movw	r24, r18
   1edea:	08 95       	ret

0001edec <setMR>:
void     setMR(uint16 val)
{
   *((volatile uint8*)MR_) = val >> 8;
   1edec:	90 93 00 80 	sts	0x8000, r25
   *((volatile uint8*)MR) = val & 0xff;
   1edf0:	80 93 01 80 	sts	0x8001, r24
}
   1edf4:	08 95       	ret

0001edf6 <getIR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1edf6:	40 91 02 80 	lds	r20, 0x8002
/* Interrupt */ 

uint16 getIR(void)
{
   return (IINCHIP_READ(IR0) << 8 | IINCHIP_READ(IR1)); 
}
   1edfa:	20 91 03 80 	lds	r18, 0x8003
   1edfe:	94 2f       	mov	r25, r20
   1ee00:	80 e0       	ldi	r24, 0x00	; 0
   1ee02:	30 e0       	ldi	r19, 0x00	; 0
   1ee04:	28 2b       	or	r18, r24
   1ee06:	39 2b       	or	r19, r25
   1ee08:	c9 01       	movw	r24, r18
   1ee0a:	08 95       	ret

0001ee0c <setIR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ee0c:	10 92 02 80 	sts	0x8002, r1
}

void setIR(uint8 s, uint16 val)
{
   IINCHIP_WRITE(IR,val&0xFF00);
}
   1ee10:	08 95       	ret

0001ee12 <getIMR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee12:	40 91 04 80 	lds	r20, 0x8004
}

uint16   getIMR(void)
{
   return ((IINCHIP_READ(IMR0) << 8) | IINCHIP_READ(IMR1));
}
   1ee16:	20 91 05 80 	lds	r18, 0x8005
   1ee1a:	94 2f       	mov	r25, r20
   1ee1c:	80 e0       	ldi	r24, 0x00	; 0
   1ee1e:	30 e0       	ldi	r19, 0x00	; 0
   1ee20:	28 2b       	or	r18, r24
   1ee22:	39 2b       	or	r19, r25
   1ee24:	c9 01       	movw	r24, r18
   1ee26:	08 95       	ret

0001ee28 <setIMR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ee28:	90 93 04 80 	sts	0x8004, r25
}
void     setIMR(uint16 mask)
{
	IINCHIP_WRITE(IMR0, mask >> 8); 
	IINCHIP_WRITE(IMR1, mask & 0xff); 
}
   1ee2c:	80 93 05 80 	sts	0x8005, r24
   1ee30:	08 95       	ret

0001ee32 <getSHAR>:


/* Network Information */

void getSHAR(uint8 * addr)
{
   1ee32:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee34:	80 91 08 80 	lds	r24, 0x8008

/* Network Information */

void getSHAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SHAR);
   1ee38:	80 83       	st	Z, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee3a:	80 91 09 80 	lds	r24, 0x8009
/* Network Information */

void getSHAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
   1ee3e:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee40:	80 91 0a 80 	lds	r24, 0x800A

void getSHAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
	addr[2] = IINCHIP_READ(SHAR2);
   1ee44:	82 83       	std	Z+2, r24	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee46:	80 91 0b 80 	lds	r24, 0x800B
void getSHAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
	addr[2] = IINCHIP_READ(SHAR2);
	addr[3] = IINCHIP_READ(SHAR3);
   1ee4a:	83 83       	std	Z+3, r24	; 0x03
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee4c:	80 91 0c 80 	lds	r24, 0x800C
{
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
	addr[2] = IINCHIP_READ(SHAR2);
	addr[3] = IINCHIP_READ(SHAR3);
	addr[4] = IINCHIP_READ(SHAR4);
   1ee50:	84 83       	std	Z+4, r24	; 0x04
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee52:	80 91 0d 80 	lds	r24, 0x800D
	addr[0] = IINCHIP_READ(SHAR);
	addr[1] = IINCHIP_READ(SHAR1);
	addr[2] = IINCHIP_READ(SHAR2);
	addr[3] = IINCHIP_READ(SHAR3);
	addr[4] = IINCHIP_READ(SHAR4);
	addr[5] = IINCHIP_READ(SHAR5);
   1ee56:	85 83       	std	Z+5, r24	; 0x05
}
   1ee58:	08 95       	ret

0001ee5a <setSHAR>:
void setSHAR(uint8 * addr)
{
   1ee5a:	dc 01       	movw	r26, r24
   1ee5c:	e8 e0       	ldi	r30, 0x08	; 8
   1ee5e:	f0 e8       	ldi	r31, 0x80	; 128
	uint8 k;

	for(k = 0; k < 6; k++) {
		IINCHIP_WRITE(SHAR+k, addr[k]);
   1ee60:	8d 91       	ld	r24, X+
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ee62:	81 93       	st	Z+, r24
}
void setSHAR(uint8 * addr)
{
	uint8 k;

	for(k = 0; k < 6; k++) {
   1ee64:	80 e8       	ldi	r24, 0x80	; 128
   1ee66:	ee 30       	cpi	r30, 0x0E	; 14
   1ee68:	f8 07       	cpc	r31, r24
   1ee6a:	d1 f7       	brne	.-12     	; 0x1ee60 <setSHAR+0x6>
		IINCHIP_WRITE(SHAR+k, addr[k]);
	}
}
   1ee6c:	08 95       	ret

0001ee6e <getGAR>:
void getGAR(uint8 * addr)
{
   1ee6e:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee70:	80 91 10 80 	lds	r24, 0x8010
		IINCHIP_WRITE(SHAR+k, addr[k]);
	}
}
void getGAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(GAR);
   1ee74:	80 83       	st	Z, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee76:	80 91 11 80 	lds	r24, 0x8011
	}
}
void getGAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(GAR);
	addr[1] = IINCHIP_READ(GAR1);
   1ee7a:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee7c:	80 91 12 80 	lds	r24, 0x8012
}
void getGAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(GAR);
	addr[1] = IINCHIP_READ(GAR1);
	addr[2] = IINCHIP_READ(GAR2);
   1ee80:	82 83       	std	Z+2, r24	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ee82:	80 91 13 80 	lds	r24, 0x8013
void getGAR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(GAR);
	addr[1] = IINCHIP_READ(GAR1);
	addr[2] = IINCHIP_READ(GAR2);
	addr[3] = IINCHIP_READ(GAR3);
   1ee86:	83 83       	std	Z+3, r24	; 0x03
}
   1ee88:	08 95       	ret

0001ee8a <setGAR>:
void setGAR(uint8 * addr)
{
   1ee8a:	fc 01       	movw	r30, r24
	IINCHIP_WRITE((GAR),addr[0]);
   1ee8c:	80 81       	ld	r24, Z
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ee8e:	80 93 10 80 	sts	0x8010, r24
	addr[3] = IINCHIP_READ(GAR3);
}
void setGAR(uint8 * addr)
{
	IINCHIP_WRITE((GAR),addr[0]);
	IINCHIP_WRITE((GAR1),addr[1]);
   1ee92:	81 81       	ldd	r24, Z+1	; 0x01
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ee94:	80 93 11 80 	sts	0x8011, r24
}
void setGAR(uint8 * addr)
{
	IINCHIP_WRITE((GAR),addr[0]);
	IINCHIP_WRITE((GAR1),addr[1]);
	IINCHIP_WRITE((GAR2),addr[2]);
   1ee98:	82 81       	ldd	r24, Z+2	; 0x02
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ee9a:	80 93 12 80 	sts	0x8012, r24
void setGAR(uint8 * addr)
{
	IINCHIP_WRITE((GAR),addr[0]);
	IINCHIP_WRITE((GAR1),addr[1]);
	IINCHIP_WRITE((GAR2),addr[2]);
	IINCHIP_WRITE((GAR3),addr[3]);
   1ee9e:	83 81       	ldd	r24, Z+3	; 0x03
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1eea0:	80 93 13 80 	sts	0x8013, r24
{
	IINCHIP_WRITE((GAR),addr[0]);
	IINCHIP_WRITE((GAR1),addr[1]);
	IINCHIP_WRITE((GAR2),addr[2]);
	IINCHIP_WRITE((GAR3),addr[3]);
}
   1eea4:	08 95       	ret

0001eea6 <getSUBR>:

void getSUBR(uint8 * addr)
{
   1eea6:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eea8:	80 91 14 80 	lds	r24, 0x8014
	IINCHIP_WRITE((GAR3),addr[3]);
}

void getSUBR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SUBR);
   1eeac:	80 83       	st	Z, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eeae:	80 91 15 80 	lds	r24, 0x8015
}

void getSUBR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SUBR);
	addr[1] = IINCHIP_READ(SUBR1);
   1eeb2:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eeb4:	80 91 16 80 	lds	r24, 0x8016

void getSUBR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SUBR);
	addr[1] = IINCHIP_READ(SUBR1);
	addr[2] = IINCHIP_READ(SUBR2);
   1eeb8:	82 83       	std	Z+2, r24	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eeba:	80 91 17 80 	lds	r24, 0x8017
void getSUBR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SUBR);
	addr[1] = IINCHIP_READ(SUBR1);
	addr[2] = IINCHIP_READ(SUBR2);
	addr[3] = IINCHIP_READ(SUBR3);
   1eebe:	83 83       	std	Z+3, r24	; 0x03
}
   1eec0:	08 95       	ret

0001eec2 <setSUBR>:
void setSUBR(uint8 * addr)
{
   1eec2:	fc 01       	movw	r30, r24
	IINCHIP_WRITE((SUBR),addr[0]);
   1eec4:	80 81       	ld	r24, Z
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1eec6:	80 93 14 80 	sts	0x8014, r24
	addr[3] = IINCHIP_READ(SUBR3);
}
void setSUBR(uint8 * addr)
{
	IINCHIP_WRITE((SUBR),addr[0]);
	IINCHIP_WRITE((SUBR1),addr[1]);
   1eeca:	81 81       	ldd	r24, Z+1	; 0x01
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1eecc:	80 93 15 80 	sts	0x8015, r24
}
void setSUBR(uint8 * addr)
{
	IINCHIP_WRITE((SUBR),addr[0]);
	IINCHIP_WRITE((SUBR1),addr[1]);
	IINCHIP_WRITE((SUBR2),addr[2]);
   1eed0:	82 81       	ldd	r24, Z+2	; 0x02
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1eed2:	80 93 16 80 	sts	0x8016, r24
void setSUBR(uint8 * addr)
{
	IINCHIP_WRITE((SUBR),addr[0]);
	IINCHIP_WRITE((SUBR1),addr[1]);
	IINCHIP_WRITE((SUBR2),addr[2]);
	IINCHIP_WRITE((SUBR3),addr[3]);
   1eed6:	83 81       	ldd	r24, Z+3	; 0x03
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1eed8:	80 93 17 80 	sts	0x8017, r24
{
	IINCHIP_WRITE((SUBR),addr[0]);
	IINCHIP_WRITE((SUBR1),addr[1]);
	IINCHIP_WRITE((SUBR2),addr[2]);
	IINCHIP_WRITE((SUBR3),addr[3]);
}
   1eedc:	08 95       	ret

0001eede <getSIPR>:

void getSIPR(uint8 * addr)
{
   1eede:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eee0:	80 91 18 80 	lds	r24, 0x8018
	IINCHIP_WRITE((SUBR3),addr[3]);
}

void getSIPR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SIPR);
   1eee4:	80 83       	st	Z, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eee6:	80 91 19 80 	lds	r24, 0x8019
}

void getSIPR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SIPR);
	addr[1] = IINCHIP_READ(SIPR1);
   1eeea:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eeec:	80 91 1a 80 	lds	r24, 0x801A

void getSIPR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SIPR);
	addr[1] = IINCHIP_READ(SIPR1);
	addr[2] = IINCHIP_READ(SIPR2);
   1eef0:	82 83       	std	Z+2, r24	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eef2:	80 91 1b 80 	lds	r24, 0x801B
void getSIPR(uint8 * addr)
{
	addr[0] = IINCHIP_READ(SIPR);
	addr[1] = IINCHIP_READ(SIPR1);
	addr[2] = IINCHIP_READ(SIPR2);
	addr[3] = IINCHIP_READ(SIPR3);
   1eef6:	83 83       	std	Z+3, r24	; 0x03
}
   1eef8:	08 95       	ret

0001eefa <setSIPR>:
void setSIPR(uint8 * addr)
{
   1eefa:	fc 01       	movw	r30, r24
	IINCHIP_WRITE((SIPR),addr[0]);
   1eefc:	80 81       	ld	r24, Z
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1eefe:	80 93 18 80 	sts	0x8018, r24
	addr[3] = IINCHIP_READ(SIPR3);
}
void setSIPR(uint8 * addr)
{
	IINCHIP_WRITE((SIPR),addr[0]);
	IINCHIP_WRITE((SIPR1),addr[1]);
   1ef02:	81 81       	ldd	r24, Z+1	; 0x01
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ef04:	80 93 19 80 	sts	0x8019, r24
}
void setSIPR(uint8 * addr)
{
	IINCHIP_WRITE((SIPR),addr[0]);
	IINCHIP_WRITE((SIPR1),addr[1]);
	IINCHIP_WRITE((SIPR2),addr[2]);
   1ef08:	82 81       	ldd	r24, Z+2	; 0x02
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ef0a:	80 93 1a 80 	sts	0x801A, r24
void setSIPR(uint8 * addr)
{
	IINCHIP_WRITE((SIPR),addr[0]);
	IINCHIP_WRITE((SIPR1),addr[1]);
	IINCHIP_WRITE((SIPR2),addr[2]);
	IINCHIP_WRITE((SIPR3),addr[3]);
   1ef0e:	83 81       	ldd	r24, Z+3	; 0x03
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ef10:	80 93 1b 80 	sts	0x801B, r24
{
	IINCHIP_WRITE((SIPR),addr[0]);
	IINCHIP_WRITE((SIPR1),addr[1]);
	IINCHIP_WRITE((SIPR2),addr[2]);
	IINCHIP_WRITE((SIPR3),addr[3]);
}
   1ef14:	08 95       	ret

0001ef16 <getRTR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef16:	40 91 1c 80 	lds	r20, 0x801C
/* Retransmittion */

uint16   getRTR(void)
{
   return ((IINCHIP_READ(RTR0) << 8) | IINCHIP_READ(RTR1));
}
   1ef1a:	20 91 1d 80 	lds	r18, 0x801D
   1ef1e:	94 2f       	mov	r25, r20
   1ef20:	80 e0       	ldi	r24, 0x00	; 0
   1ef22:	30 e0       	ldi	r19, 0x00	; 0
   1ef24:	28 2b       	or	r18, r24
   1ef26:	39 2b       	or	r19, r25
   1ef28:	c9 01       	movw	r24, r18
   1ef2a:	08 95       	ret

0001ef2c <setRTR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ef2c:	90 93 1c 80 	sts	0x801C, r25
}
void     setRTR(uint16 timeout)
{
	IINCHIP_WRITE(RTR0, timeout >> 8);
	IINCHIP_WRITE(RTR1, timeout);
}
   1ef30:	80 93 1d 80 	sts	0x801D, r24
   1ef34:	08 95       	ret

0001ef36 <getRCR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef36:	80 91 1f 80 	lds	r24, 0x801F
}

uint8    getRCR(void)
{
   return (uint8)IINCHIP_READ(RCR);
}
   1ef3a:	08 95       	ret

0001ef3c <setRCR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ef3c:	80 93 1f 80 	sts	0x801F, r24
   return (uint8)IINCHIP_READ(RCR);
}
void     setRCR(uint8 retry)
{
   IINCHIP_WRITE(RCR,retry);
}
   1ef40:	08 95       	ret

0001ef42 <getPATR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef42:	40 91 32 80 	lds	r20, 0x8032

/* PPPoE */
uint16   getPATR(void)
{
   return ((IINCHIP_READ(PATR0) << 8) | IINCHIP_READ(PATR1));
}
   1ef46:	20 91 33 80 	lds	r18, 0x8033
   1ef4a:	94 2f       	mov	r25, r20
   1ef4c:	80 e0       	ldi	r24, 0x00	; 0
   1ef4e:	30 e0       	ldi	r19, 0x00	; 0
   1ef50:	28 2b       	or	r18, r24
   1ef52:	39 2b       	or	r19, r25
   1ef54:	c9 01       	movw	r24, r18
   1ef56:	08 95       	ret

0001ef58 <getPTIMER>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef58:	80 91 36 80 	lds	r24, 0x8036
}

uint8    getPTIMER(void)
{
   return (uint8)IINCHIP_READ(PTIMER);
}
   1ef5c:	08 95       	ret

0001ef5e <setPTIMER>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ef5e:	80 93 36 80 	sts	0x8036, r24
   return (uint8)IINCHIP_READ(PTIMER);
}
void     setPTIMER(uint8 time)
{
   IINCHIP_WRITE(PTIMER,time);
}
   1ef62:	08 95       	ret

0001ef64 <getPMAGICR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef64:	80 91 38 80 	lds	r24, 0x8038
}

uint8    getPMAGICR(void)
{
   return (uint8)IINCHIP_READ(PMAGICR);
}
   1ef68:	08 95       	ret

0001ef6a <setPMAGICR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1ef6a:	80 93 38 80 	sts	0x8038, r24
   return (uint8)IINCHIP_READ(PMAGICR);
}
void     setPMAGICR(uint8 magic)
{
   IINCHIP_WRITE(PMAGICR,magic);
}
   1ef6e:	08 95       	ret

0001ef70 <getPSIDR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef70:	40 91 3c 80 	lds	r20, 0x803C
}

uint16   getPSIDR(void)
{
   return ((IINCHIP_READ(PSIDR0) << 8) | IINCHIP_READ(PSIDR1));
}
   1ef74:	20 91 3d 80 	lds	r18, 0x803D
   1ef78:	94 2f       	mov	r25, r20
   1ef7a:	80 e0       	ldi	r24, 0x00	; 0
   1ef7c:	30 e0       	ldi	r19, 0x00	; 0
   1ef7e:	28 2b       	or	r18, r24
   1ef80:	39 2b       	or	r19, r25
   1ef82:	c9 01       	movw	r24, r18
   1ef84:	08 95       	ret

0001ef86 <getPDHAR>:

void     getPDHAR(uint8* addr)
{
   1ef86:	dc 01       	movw	r26, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef88:	e0 e4       	ldi	r30, 0x40	; 64
   1ef8a:	f0 e8       	ldi	r31, 0x80	; 128
   1ef8c:	80 81       	ld	r24, Z
   return ((IINCHIP_READ(PSIDR0) << 8) | IINCHIP_READ(PSIDR1));
}

void     getPDHAR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   1ef8e:	1c 92       	st	X, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef90:	80 81       	ld	r24, Z
}

void     getPDHAR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   1ef92:	11 96       	adiw	r26, 0x01	; 1
   1ef94:	8c 93       	st	X, r24
   1ef96:	11 97       	sbiw	r26, 0x01	; 1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1ef98:	e2 e4       	ldi	r30, 0x42	; 66
   1ef9a:	f0 e8       	ldi	r31, 0x80	; 128
   1ef9c:	80 81       	ld	r24, Z

void     getPDHAR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   addr[2] = (uint8)(IINCHIP_READ(PDHAR2) >> 8);
   1ef9e:	12 96       	adiw	r26, 0x02	; 2
   1efa0:	1c 92       	st	X, r1
   1efa2:	12 97       	sbiw	r26, 0x02	; 2
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1efa4:	80 81       	ld	r24, Z
void     getPDHAR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   addr[2] = (uint8)(IINCHIP_READ(PDHAR2) >> 8);
   addr[3] = (uint8)IINCHIP_READ(PDHAR2);
   1efa6:	13 96       	adiw	r26, 0x03	; 3
   1efa8:	8c 93       	st	X, r24
   1efaa:	13 97       	sbiw	r26, 0x03	; 3
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1efac:	e4 e4       	ldi	r30, 0x44	; 68
   1efae:	f0 e8       	ldi	r31, 0x80	; 128
   1efb0:	80 81       	ld	r24, Z
{
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   addr[2] = (uint8)(IINCHIP_READ(PDHAR2) >> 8);
   addr[3] = (uint8)IINCHIP_READ(PDHAR2);
   addr[4] = (uint8)(IINCHIP_READ(PDHAR4) >> 8);
   1efb2:	14 96       	adiw	r26, 0x04	; 4
   1efb4:	1c 92       	st	X, r1
   1efb6:	14 97       	sbiw	r26, 0x04	; 4
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1efb8:	80 81       	ld	r24, Z
   addr[0] = (uint8)(IINCHIP_READ(PDHAR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(PDHAR);
   addr[2] = (uint8)(IINCHIP_READ(PDHAR2) >> 8);
   addr[3] = (uint8)IINCHIP_READ(PDHAR2);
   addr[4] = (uint8)(IINCHIP_READ(PDHAR4) >> 8);
   addr[5] = (uint8)IINCHIP_READ(PDHAR4);
   1efba:	15 96       	adiw	r26, 0x05	; 5
   1efbc:	8c 93       	st	X, r24
}
   1efbe:	08 95       	ret

0001efc0 <getUIPR>:


/* ICMP packets */

void     getUIPR(uint8* addr)
{
   1efc0:	fc 01       	movw	r30, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1efc2:	a8 e4       	ldi	r26, 0x48	; 72
   1efc4:	b0 e8       	ldi	r27, 0x80	; 128
   1efc6:	8c 91       	ld	r24, X

/* ICMP packets */

void     getUIPR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(UIPR) >> 8);
   1efc8:	10 82       	st	Z, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1efca:	8c 91       	ld	r24, X
/* ICMP packets */

void     getUIPR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(UIPR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(UIPR);
   1efcc:	81 83       	std	Z+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1efce:	aa e4       	ldi	r26, 0x4A	; 74
   1efd0:	b0 e8       	ldi	r27, 0x80	; 128
   1efd2:	8c 91       	ld	r24, X

void     getUIPR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(UIPR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(UIPR);
   addr[2] = (uint8)(IINCHIP_READ(UIPR2) >> 8);
   1efd4:	12 82       	std	Z+2, r1	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1efd6:	8c 91       	ld	r24, X
void     getUIPR(uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(UIPR) >> 8);
   addr[1] = (uint8)IINCHIP_READ(UIPR);
   addr[2] = (uint8)(IINCHIP_READ(UIPR2) >> 8);
   addr[3] = (uint8)IINCHIP_READ(UIPR2);   
   1efd8:	83 83       	std	Z+3, r24	; 0x03
}
   1efda:	08 95       	ret

0001efdc <getUPORTR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1efdc:	40 91 4c 80 	lds	r20, 0x804C
}

uint16   getUPORTR(void)
{
   return ((IINCHIP_READ(UPORTR0) << 8) | IINCHIP_READ(UPORTR1));
}
   1efe0:	20 91 4d 80 	lds	r18, 0x804D
   1efe4:	94 2f       	mov	r25, r20
   1efe6:	80 e0       	ldi	r24, 0x00	; 0
   1efe8:	30 e0       	ldi	r19, 0x00	; 0
   1efea:	28 2b       	or	r18, r24
   1efec:	39 2b       	or	r19, r25
   1efee:	c9 01       	movw	r24, r18
   1eff0:	08 95       	ret

0001eff2 <getFMTUR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1eff2:	40 91 4e 80 	lds	r20, 0x804E
}

uint16   getFMTUR(void)
{
   return ((IINCHIP_READ(FMTUR0) << 8) | IINCHIP_READ(FMTUR1));
}
   1eff6:	20 91 4f 80 	lds	r18, 0x804F
   1effa:	94 2f       	mov	r25, r20
   1effc:	80 e0       	ldi	r24, 0x00	; 0
   1effe:	30 e0       	ldi	r19, 0x00	; 0
   1f000:	28 2b       	or	r18, r24
   1f002:	39 2b       	or	r19, r25
   1f004:	c9 01       	movw	r24, r18
   1f006:	08 95       	ret

0001f008 <getPn_BRDYR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f008:	e8 2f       	mov	r30, r24
   1f00a:	f0 e0       	ldi	r31, 0x00	; 0
   1f00c:	e8 5e       	subi	r30, 0xE8	; 232
   1f00e:	ff 4d       	sbci	r31, 0xDF	; 223
   1f010:	ee 0f       	add	r30, r30
   1f012:	ff 1f       	adc	r31, r31
   1f014:	ee 0f       	add	r30, r30
   1f016:	ff 1f       	adc	r31, r31
   1f018:	80 81       	ld	r24, Z
/* PIN "BRYDn" */

uint8    getPn_BRDYR(uint8 p)
{
   return (uint8)IINCHIP_READ(Pn_BRDYR(p));
}
   1f01a:	08 95       	ret

0001f01c <setPn_BRDYR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f01c:	e8 2f       	mov	r30, r24
   1f01e:	f0 e0       	ldi	r31, 0x00	; 0
   1f020:	e8 5e       	subi	r30, 0xE8	; 232
   1f022:	ff 4d       	sbci	r31, 0xDF	; 223
   1f024:	ee 0f       	add	r30, r30
   1f026:	ff 1f       	adc	r31, r31
   1f028:	ee 0f       	add	r30, r30
   1f02a:	ff 1f       	adc	r31, r31
   1f02c:	60 83       	st	Z, r22
   return (uint8)IINCHIP_READ(Pn_BRDYR(p));
}
void     setPn_BRDYR(uint8 p, uint8 cfg)
{
   IINCHIP_WRITE(Pn_BRDYR(p),cfg);   
}
   1f02e:	08 95       	ret

0001f030 <getPn_BDPTHR>:


uint16   getPn_BDPTHR(uint8 p)
{
   return ((IINCHIP_READ(Pn_BDPTHR0(p) << 8)) | IINCHIP_READ(Pn_BDPTHR1(p)));   
   1f030:	e8 2f       	mov	r30, r24
   1f032:	f0 e0       	ldi	r31, 0x00	; 0
   1f034:	ee 0f       	add	r30, r30
   1f036:	ff 1f       	adc	r31, r31
   1f038:	ee 0f       	add	r30, r30
   1f03a:	ff 1f       	adc	r31, r31
   1f03c:	ee 59       	subi	r30, 0x9E	; 158
   1f03e:	ff 47       	sbci	r31, 0x7F	; 127
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f040:	be 2f       	mov	r27, r30
   1f042:	aa 27       	eor	r26, r26
   1f044:	9c 91       	ld	r25, X


uint16   getPn_BDPTHR(uint8 p)
{
   return ((IINCHIP_READ(Pn_BDPTHR0(p) << 8)) | IINCHIP_READ(Pn_BDPTHR1(p)));   
}
   1f046:	81 81       	ldd	r24, Z+1	; 0x01
   1f048:	89 2b       	or	r24, r25
   1f04a:	90 e0       	ldi	r25, 0x00	; 0
   1f04c:	08 95       	ret

0001f04e <setPn_BDPTHR>:
void     setPn_BDPTHR(uint8 p, uint16 depth)
{
   IINCHIP_WRITE(Pn_BDPTHR0(p),depth >> 8);
   1f04e:	e8 2f       	mov	r30, r24
   1f050:	f0 e0       	ldi	r31, 0x00	; 0
   1f052:	ee 0f       	add	r30, r30
   1f054:	ff 1f       	adc	r31, r31
   1f056:	ee 0f       	add	r30, r30
   1f058:	ff 1f       	adc	r31, r31
   1f05a:	ee 59       	subi	r30, 0x9E	; 158
   1f05c:	ff 47       	sbci	r31, 0x7F	; 127
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f05e:	70 83       	st	Z, r23
}
void     setPn_BDPTHR(uint8 p, uint16 depth)
{
   IINCHIP_WRITE(Pn_BDPTHR0(p),depth >> 8);
   IINCHIP_WRITE(Pn_BDPTHR1(p),depth);
}
   1f060:	61 83       	std	Z+1, r22	; 0x01
   1f062:	08 95       	ret

0001f064 <getIDR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f064:	40 91 fe 80 	lds	r20, 0x80FE

/* IINCHIP ID */
uint16   getIDR(void)
{
   return ((IINCHIP_READ(IDR) << 8) | IINCHIP_READ(IDR1));
}
   1f068:	20 91 ff 80 	lds	r18, 0x80FF
   1f06c:	94 2f       	mov	r25, r20
   1f06e:	80 e0       	ldi	r24, 0x00	; 0
   1f070:	30 e0       	ldi	r19, 0x00	; 0
   1f072:	28 2b       	or	r18, r24
   1f074:	39 2b       	or	r19, r25
   1f076:	c9 01       	movw	r24, r18
   1f078:	08 95       	ret

0001f07a <getSn_MR>:

/* SOCKET control */

uint16   getSn_MR(SOCKET s)
{
   return ((IINCHIP_READ(Sn_MR_(s) << 8) | IINCHIP_READ(Sn_MR(s))));
   1f07a:	e8 2f       	mov	r30, r24
   1f07c:	f0 e0       	ldi	r31, 0x00	; 0
   1f07e:	e8 5f       	subi	r30, 0xF8	; 248
   1f080:	fd 4f       	sbci	r31, 0xFD	; 253
   1f082:	66 e0       	ldi	r22, 0x06	; 6
   1f084:	ee 0f       	add	r30, r30
   1f086:	ff 1f       	adc	r31, r31
   1f088:	6a 95       	dec	r22
   1f08a:	e1 f7       	brne	.-8      	; 0x1f084 <getSn_MR+0xa>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f08c:	be 2f       	mov	r27, r30
   1f08e:	aa 27       	eor	r26, r26
   1f090:	9c 91       	ld	r25, X
/* SOCKET control */

uint16   getSn_MR(SOCKET s)
{
   return ((IINCHIP_READ(Sn_MR_(s) << 8) | IINCHIP_READ(Sn_MR(s))));
}
   1f092:	81 81       	ldd	r24, Z+1	; 0x01
   1f094:	89 2b       	or	r24, r25
   1f096:	90 e0       	ldi	r25, 0x00	; 0
   1f098:	08 95       	ret

0001f09a <setSn_MR>:
void     setSn_MR(SOCKET s, uint8 mode)
{
   IINCHIP_WRITE(Sn_MR_(s),mode >> 8);
   1f09a:	e8 2f       	mov	r30, r24
   1f09c:	f0 e0       	ldi	r31, 0x00	; 0
   1f09e:	e8 5f       	subi	r30, 0xF8	; 248
   1f0a0:	fd 4f       	sbci	r31, 0xFD	; 253
   1f0a2:	76 e0       	ldi	r23, 0x06	; 6
   1f0a4:	ee 0f       	add	r30, r30
   1f0a6:	ff 1f       	adc	r31, r31
   1f0a8:	7a 95       	dec	r23
   1f0aa:	e1 f7       	brne	.-8      	; 0x1f0a4 <setSn_MR+0xa>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f0ac:	10 82       	st	Z, r1
}
void     setSn_MR(SOCKET s, uint8 mode)
{
   IINCHIP_WRITE(Sn_MR_(s),mode >> 8);
   IINCHIP_WRITE(Sn_MR(s),mode);
}
   1f0ae:	61 83       	std	Z+1, r22	; 0x01
   1f0b0:	08 95       	ret

0001f0b2 <getSn_CR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f0b2:	e8 2f       	mov	r30, r24
   1f0b4:	f0 e0       	ldi	r31, 0x00	; 0
   1f0b6:	a6 e0       	ldi	r26, 0x06	; 6
   1f0b8:	ee 0f       	add	r30, r30
   1f0ba:	ff 1f       	adc	r31, r31
   1f0bc:	aa 95       	dec	r26
   1f0be:	e1 f7       	brne	.-8      	; 0x1f0b8 <getSn_CR+0x6>
   1f0c0:	ee 5f       	subi	r30, 0xFE	; 254
   1f0c2:	fd 47       	sbci	r31, 0x7D	; 125
   1f0c4:	81 81       	ldd	r24, Z+1	; 0x01
}

uint8    getSn_CR(SOCKET s)
{
   return IINCHIP_READ(Sn_CR(s));
}
   1f0c6:	08 95       	ret

0001f0c8 <setSn_CR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f0c8:	e8 2f       	mov	r30, r24
   1f0ca:	f0 e0       	ldi	r31, 0x00	; 0
   1f0cc:	b6 e0       	ldi	r27, 0x06	; 6
   1f0ce:	ee 0f       	add	r30, r30
   1f0d0:	ff 1f       	adc	r31, r31
   1f0d2:	ba 95       	dec	r27
   1f0d4:	e1 f7       	brne	.-8      	; 0x1f0ce <setSn_CR+0x6>
   1f0d6:	ee 5f       	subi	r30, 0xFE	; 254
   1f0d8:	fd 47       	sbci	r31, 0x7D	; 125
   1f0da:	df 01       	movw	r26, r30
   1f0dc:	11 96       	adiw	r26, 0x01	; 1
   1f0de:	61 83       	std	Z+1, r22	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f0e0:	8c 91       	ld	r24, X
   return IINCHIP_READ(Sn_CR(s));
}
void     setSn_CR(SOCKET s, uint8 com)
{
   IINCHIP_WRITE(Sn_CR(s),com);
   while(IINCHIP_READ(Sn_CR(s))); // wait until Sn_CR is cleared.
   1f0e2:	88 23       	and	r24, r24
   1f0e4:	e9 f7       	brne	.-6      	; 0x1f0e0 <setSn_CR+0x18>
}
   1f0e6:	08 95       	ret

0001f0e8 <getSn_IMR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f0e8:	e8 2f       	mov	r30, r24
   1f0ea:	f0 e0       	ldi	r31, 0x00	; 0
   1f0ec:	86 e0       	ldi	r24, 0x06	; 6
   1f0ee:	ee 0f       	add	r30, r30
   1f0f0:	ff 1f       	adc	r31, r31
   1f0f2:	8a 95       	dec	r24
   1f0f4:	e1 f7       	brne	.-8      	; 0x1f0ee <getSn_IMR+0x6>
   1f0f6:	ec 5f       	subi	r30, 0xFC	; 252
   1f0f8:	fd 47       	sbci	r31, 0x7D	; 125
   1f0fa:	81 81       	ldd	r24, Z+1	; 0x01
}

uint8    getSn_IMR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_IMR(s));
}
   1f0fc:	08 95       	ret

0001f0fe <setSn_IMR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f0fe:	e8 2f       	mov	r30, r24
   1f100:	f0 e0       	ldi	r31, 0x00	; 0
   1f102:	96 e0       	ldi	r25, 0x06	; 6
   1f104:	ee 0f       	add	r30, r30
   1f106:	ff 1f       	adc	r31, r31
   1f108:	9a 95       	dec	r25
   1f10a:	e1 f7       	brne	.-8      	; 0x1f104 <setSn_IMR+0x6>
   1f10c:	ec 5f       	subi	r30, 0xFC	; 252
   1f10e:	fd 47       	sbci	r31, 0x7D	; 125
   1f110:	61 83       	std	Z+1, r22	; 0x01
   return (uint8)IINCHIP_READ(Sn_IMR(s));
}
void     setSn_IMR(SOCKET s, uint8 mask)
{
   IINCHIP_WRITE(Sn_IMR(s),mask);
}
   1f112:	08 95       	ret

0001f114 <getSn_IR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f114:	e8 2f       	mov	r30, r24
   1f116:	f0 e0       	ldi	r31, 0x00	; 0
   1f118:	e8 5f       	subi	r30, 0xF8	; 248
   1f11a:	fd 4f       	sbci	r31, 0xFD	; 253
   1f11c:	26 e0       	ldi	r18, 0x06	; 6
   1f11e:	ee 0f       	add	r30, r30
   1f120:	ff 1f       	adc	r31, r31
   1f122:	2a 95       	dec	r18
   1f124:	e1 f7       	brne	.-8      	; 0x1f11e <getSn_IR+0xa>
   1f126:	87 81       	ldd	r24, Z+7	; 0x07
   #ifdef __DEF_IINCHIP_INT__    // In case of using ISR routine of iinchip
      return (uint8)IINCHIP_READ(Sn_IR(s));
   #else                         // In case of processing directly
      return (uint8)IINCHIP_READ(Sn_IR(s));
   #endif   
}
   1f128:	08 95       	ret

0001f12a <setSn_IR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f12a:	e8 2f       	mov	r30, r24
   1f12c:	f0 e0       	ldi	r31, 0x00	; 0
   1f12e:	e8 5f       	subi	r30, 0xF8	; 248
   1f130:	fd 4f       	sbci	r31, 0xFD	; 253
   1f132:	36 e0       	ldi	r19, 0x06	; 6
   1f134:	ee 0f       	add	r30, r30
   1f136:	ff 1f       	adc	r31, r31
   1f138:	3a 95       	dec	r19
   1f13a:	e1 f7       	brne	.-8      	; 0x1f134 <setSn_IR+0xa>
   1f13c:	67 83       	std	Z+7, r22	; 0x07
   #ifdef __DEF_IINCHIP_INT__    // In case of using ISR routine of iinchip
      IINCHIP_WRITE(Sn_IR(s),ir);
   #else                         // In case of processing directly
      IINCHIP_WRITE(Sn_IR(s),ir);
   #endif   
}
   1f13e:	08 95       	ret

0001f140 <getSn_SSR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f140:	e8 2f       	mov	r30, r24
   1f142:	f0 e0       	ldi	r31, 0x00	; 0
   1f144:	46 e0       	ldi	r20, 0x06	; 6
   1f146:	ee 0f       	add	r30, r30
   1f148:	ff 1f       	adc	r31, r31
   1f14a:	4a 95       	dec	r20
   1f14c:	e1 f7       	brne	.-8      	; 0x1f146 <getSn_SSR+0x6>
   1f14e:	e8 5f       	subi	r30, 0xF8	; 248
   1f150:	fd 47       	sbci	r31, 0x7D	; 125
   1f152:	df 01       	movw	r26, r30
   1f154:	11 96       	adiw	r26, 0x01	; 1
   1f156:	81 81       	ldd	r24, Z+1	; 0x01
   ssr = (uint8)IINCHIP_READ(Sn_SSR(s));     // first read

   while(1)
   {
      ssr1 = (uint8)IINCHIP_READ(Sn_SSR(s)); // second read
      if(ssr == ssr1) break;                 // if first == sencond, Sn_SSR value is valid.
   1f158:	9c 91       	ld	r25, X
   1f15a:	89 17       	cp	r24, r25
   1f15c:	11 f0       	breq	.+4      	; 0x1f162 <getSn_SSR+0x22>
   1f15e:	89 2f       	mov	r24, r25
   1f160:	fb cf       	rjmp	.-10     	; 0x1f158 <getSn_SSR+0x18>
      ssr = ssr1;                            // if first <> second, save second value into first.
   }
   return ssr;
}
   1f162:	08 95       	ret

0001f164 <getSn_DHAR>:

void     getSn_DHAR(SOCKET s, uint8* addr)
{
   1f164:	cf 93       	push	r28
   1f166:	df 93       	push	r29
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   1f168:	e8 2f       	mov	r30, r24
   1f16a:	f0 e0       	ldi	r31, 0x00	; 0
   1f16c:	e8 5f       	subi	r30, 0xF8	; 248
   1f16e:	fd 4f       	sbci	r31, 0xFD	; 253
   1f170:	df 01       	movw	r26, r30
   1f172:	56 e0       	ldi	r21, 0x06	; 6
   1f174:	aa 0f       	add	r26, r26
   1f176:	bb 1f       	adc	r27, r27
   1f178:	5a 95       	dec	r21
   1f17a:	e1 f7       	brne	.-8      	; 0x1f174 <getSn_DHAR+0x10>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f17c:	1c 96       	adiw	r26, 0x0c	; 12
   1f17e:	8c 91       	ld	r24, X
   1f180:	1c 97       	sbiw	r26, 0x0c	; 12
   return ssr;
}

void     getSn_DHAR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   1f182:	eb 01       	movw	r28, r22
   1f184:	18 82       	st	Y, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f186:	1c 96       	adiw	r26, 0x0c	; 12
   1f188:	8c 91       	ld	r24, X
   1f18a:	1c 97       	sbiw	r26, 0x0c	; 12
}

void     getSn_DHAR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   1f18c:	89 83       	std	Y+1, r24	; 0x01
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f18e:	1e 96       	adiw	r26, 0x0e	; 14
   1f190:	8c 91       	ld	r24, X
   1f192:	1e 97       	sbiw	r26, 0x0e	; 14

void     getSn_DHAR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DHAR2(s))>>8);
   1f194:	1a 82       	std	Y+2, r1	; 0x02
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f196:	1e 96       	adiw	r26, 0x0e	; 14
   1f198:	8c 91       	ld	r24, X
   1f19a:	1e 97       	sbiw	r26, 0x0e	; 14
void     getSn_DHAR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DHAR2(s))>>8);
   addr[3] = (uint8)IINCHIP_READ(Sn_DHAR2(s));
   1f19c:	8b 83       	std	Y+3, r24	; 0x03
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f19e:	fd 01       	movw	r30, r26
   1f1a0:	70 96       	adiw	r30, 0x10	; 16
   1f1a2:	80 81       	ld	r24, Z
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DHAR2(s))>>8);
   addr[3] = (uint8)IINCHIP_READ(Sn_DHAR2(s));
   addr[4] = (uint8)(IINCHIP_READ(Sn_DHAR4(s))>>8);
   1f1a4:	1c 82       	std	Y+4, r1	; 0x04
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f1a6:	80 81       	ld	r24, Z
   addr[0] = (uint8)(IINCHIP_READ(Sn_DHAR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DHAR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DHAR2(s))>>8);
   addr[3] = (uint8)IINCHIP_READ(Sn_DHAR2(s));
   addr[4] = (uint8)(IINCHIP_READ(Sn_DHAR4(s))>>8);
   addr[5] = (uint8)IINCHIP_READ(Sn_DHAR4(s));
   1f1a8:	8d 83       	std	Y+5, r24	; 0x05
}
   1f1aa:	df 91       	pop	r29
   1f1ac:	cf 91       	pop	r28
   1f1ae:	08 95       	ret

0001f1b0 <setSn_DHAR>:

void     setSn_DHAR(SOCKET s, uint8* addr)
{
   1f1b0:	cf 93       	push	r28
   1f1b2:	df 93       	push	r29
   1f1b4:	db 01       	movw	r26, r22
   IINCHIP_WRITE(Sn_DHAR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   1f1b6:	e8 2f       	mov	r30, r24
   1f1b8:	f0 e0       	ldi	r31, 0x00	; 0
   1f1ba:	e8 5f       	subi	r30, 0xF8	; 248
   1f1bc:	fd 4f       	sbci	r31, 0xFD	; 253
   1f1be:	9f 01       	movw	r18, r30
   1f1c0:	66 e0       	ldi	r22, 0x06	; 6
   1f1c2:	22 0f       	add	r18, r18
   1f1c4:	33 1f       	adc	r19, r19
   1f1c6:	6a 95       	dec	r22
   1f1c8:	e1 f7       	brne	.-8      	; 0x1f1c2 <setSn_DHAR+0x12>
   1f1ca:	11 96       	adiw	r26, 0x01	; 1
   1f1cc:	8c 91       	ld	r24, X
   1f1ce:	11 97       	sbiw	r26, 0x01	; 1
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f1d0:	e9 01       	movw	r28, r18
   1f1d2:	8c 87       	std	Y+12, r24	; 0x0c
}

void     setSn_DHAR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DHAR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DHAR2(s), ((uint16)(addr[2]<<8)) + addr[3]);
   1f1d4:	13 96       	adiw	r26, 0x03	; 3
   1f1d6:	8c 91       	ld	r24, X
   1f1d8:	13 97       	sbiw	r26, 0x03	; 3
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f1da:	8e 87       	std	Y+14, r24	; 0x0e

void     setSn_DHAR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DHAR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DHAR2(s), ((uint16)(addr[2]<<8)) + addr[3]);
   IINCHIP_WRITE(Sn_DHAR4(s), ((uint16)(addr[4]<<8)) + addr[5]);
   1f1dc:	15 96       	adiw	r26, 0x05	; 5
   1f1de:	8c 91       	ld	r24, X
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f1e0:	f9 01       	movw	r30, r18
   1f1e2:	70 96       	adiw	r30, 0x10	; 16
   1f1e4:	80 83       	st	Z, r24
void     setSn_DHAR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DHAR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DHAR2(s), ((uint16)(addr[2]<<8)) + addr[3]);
   IINCHIP_WRITE(Sn_DHAR4(s), ((uint16)(addr[4]<<8)) + addr[5]);
}
   1f1e6:	df 91       	pop	r29
   1f1e8:	cf 91       	pop	r28
   1f1ea:	08 95       	ret

0001f1ec <setSn_DPORTR>:
//}


void     setSn_DPORTR(SOCKET s, uint16 port)
{
 	 IINCHIP_WRITE(Sn_DPORTR0(s), port >> 8);
   1f1ec:	e8 2f       	mov	r30, r24
   1f1ee:	f0 e0       	ldi	r31, 0x00	; 0
   1f1f0:	e8 5f       	subi	r30, 0xF8	; 248
   1f1f2:	fd 4f       	sbci	r31, 0xFD	; 253
   1f1f4:	a6 e0       	ldi	r26, 0x06	; 6
   1f1f6:	ee 0f       	add	r30, r30
   1f1f8:	ff 1f       	adc	r31, r31
   1f1fa:	aa 95       	dec	r26
   1f1fc:	e1 f7       	brne	.-8      	; 0x1f1f6 <setSn_DPORTR+0xa>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f1fe:	72 8b       	std	Z+18, r23	; 0x12

void     setSn_DPORTR(SOCKET s, uint16 port)
{
 	 IINCHIP_WRITE(Sn_DPORTR0(s), port >> 8);
	 IINCHIP_WRITE(Sn_DPORTR1(s), port);
}
   1f200:	63 8b       	std	Z+19, r22	; 0x13
   1f202:	08 95       	ret

0001f204 <getSn_DIPR>:

void     getSn_DIPR(SOCKET s, uint8* addr)
{
   1f204:	db 01       	movw	r26, r22
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
   1f206:	e8 2f       	mov	r30, r24
   1f208:	f0 e0       	ldi	r31, 0x00	; 0
   1f20a:	e8 5f       	subi	r30, 0xF8	; 248
   1f20c:	fd 4f       	sbci	r31, 0xFD	; 253
   1f20e:	86 e0       	ldi	r24, 0x06	; 6
   1f210:	ee 0f       	add	r30, r30
   1f212:	ff 1f       	adc	r31, r31
   1f214:	8a 95       	dec	r24
   1f216:	e1 f7       	brne	.-8      	; 0x1f210 <getSn_DIPR+0xc>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f218:	84 89       	ldd	r24, Z+20	; 0x14
	 IINCHIP_WRITE(Sn_DPORTR1(s), port);
}

void     getSn_DIPR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
   1f21a:	1c 92       	st	X, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f21c:	84 89       	ldd	r24, Z+20	; 0x14
}

void     getSn_DIPR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DIPR(s));
   1f21e:	11 96       	adiw	r26, 0x01	; 1
   1f220:	8c 93       	st	X, r24
   1f222:	11 97       	sbiw	r26, 0x01	; 1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f224:	86 89       	ldd	r24, Z+22	; 0x16

void     getSn_DIPR(SOCKET s, uint8* addr)
{
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DIPR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DIPR2(s))>>8);
   1f226:	12 96       	adiw	r26, 0x02	; 2
   1f228:	1c 92       	st	X, r1
   1f22a:	12 97       	sbiw	r26, 0x02	; 2
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f22c:	86 89       	ldd	r24, Z+22	; 0x16
   addr[0] = (uint8)(IINCHIP_READ(Sn_DIPR(s))>>8);
   addr[1] = (uint8)IINCHIP_READ(Sn_DIPR(s));
   addr[2] = (uint8)(IINCHIP_READ(Sn_DIPR2(s))>>8);
// M_15052008 : Replace Sn_DHAR2 with Sn_DIPR.   
// addr[3] = (uint8)IINCHIP_READ(Sn_DHAR2(s));   
   addr[3] = (uint8)IINCHIP_READ(Sn_DIPR2(s));   
   1f22e:	13 96       	adiw	r26, 0x03	; 3
   1f230:	8c 93       	st	X, r24
}
   1f232:	08 95       	ret

0001f234 <setSn_DIPR>:
void     setSn_DIPR(SOCKET s, uint8* addr)
{
   1f234:	db 01       	movw	r26, r22
   IINCHIP_WRITE(Sn_DIPR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   1f236:	e8 2f       	mov	r30, r24
   1f238:	f0 e0       	ldi	r31, 0x00	; 0
   1f23a:	e8 5f       	subi	r30, 0xF8	; 248
   1f23c:	fd 4f       	sbci	r31, 0xFD	; 253
   1f23e:	96 e0       	ldi	r25, 0x06	; 6
   1f240:	ee 0f       	add	r30, r30
   1f242:	ff 1f       	adc	r31, r31
   1f244:	9a 95       	dec	r25
   1f246:	e1 f7       	brne	.-8      	; 0x1f240 <setSn_DIPR+0xc>
   1f248:	11 96       	adiw	r26, 0x01	; 1
   1f24a:	8c 91       	ld	r24, X
   1f24c:	11 97       	sbiw	r26, 0x01	; 1
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f24e:	84 8b       	std	Z+20, r24	; 0x14
   addr[3] = (uint8)IINCHIP_READ(Sn_DIPR2(s));   
}
void     setSn_DIPR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DIPR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DIPR2(s), ((uint16)(addr[2]<<8)) + addr[3]);  
   1f250:	13 96       	adiw	r26, 0x03	; 3
   1f252:	8c 91       	ld	r24, X
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f254:	86 8b       	std	Z+22, r24	; 0x16
}
void     setSn_DIPR(SOCKET s, uint8* addr)
{
   IINCHIP_WRITE(Sn_DIPR(s),  ((uint16)(addr[0]<<8)) + addr[1]);
   IINCHIP_WRITE(Sn_DIPR2(s), ((uint16)(addr[2]<<8)) + addr[3]);  
}
   1f256:	08 95       	ret

0001f258 <getSn_MSSR>:

uint16   getSn_MSSR(SOCKET s)
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_MSSR0(s)) << 8;
   1f258:	e8 2f       	mov	r30, r24
   1f25a:	f0 e0       	ldi	r31, 0x00	; 0
   1f25c:	e8 5f       	subi	r30, 0xF8	; 248
   1f25e:	fd 4f       	sbci	r31, 0xFD	; 253
   1f260:	26 e0       	ldi	r18, 0x06	; 6
   1f262:	ee 0f       	add	r30, r30
   1f264:	ff 1f       	adc	r31, r31
   1f266:	2a 95       	dec	r18
   1f268:	e1 f7       	brne	.-8      	; 0x1f262 <getSn_MSSR+0xa>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f26a:	20 8d       	ldd	r18, Z+24	; 0x18
}

uint16   getSn_MSSR(SOCKET s)
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_MSSR0(s)) << 8;
   1f26c:	92 2f       	mov	r25, r18
   1f26e:	80 e0       	ldi	r24, 0x00	; 0
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f270:	21 8d       	ldd	r18, Z+25	; 0x19
   1f272:	30 e0       	ldi	r19, 0x00	; 0
   1f274:	28 2b       	or	r18, r24
   1f276:	39 2b       	or	r19, r25
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_MSSR0(s)) << 8;
	 ret |= IINCHIP_READ(Sn_MSSR1(s));
   return ret;
}
   1f278:	c9 01       	movw	r24, r18
   1f27a:	08 95       	ret

0001f27c <setSn_MSSR>:

void     setSn_MSSR(SOCKET s, uint16 mss)
{
   IINCHIP_WRITE(Sn_MSSR0(s), mss >> 8);
   1f27c:	e8 2f       	mov	r30, r24
   1f27e:	f0 e0       	ldi	r31, 0x00	; 0
   1f280:	e8 5f       	subi	r30, 0xF8	; 248
   1f282:	fd 4f       	sbci	r31, 0xFD	; 253
   1f284:	36 e0       	ldi	r19, 0x06	; 6
   1f286:	ee 0f       	add	r30, r30
   1f288:	ff 1f       	adc	r31, r31
   1f28a:	3a 95       	dec	r19
   1f28c:	e1 f7       	brne	.-8      	; 0x1f286 <setSn_MSSR+0xa>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f28e:	70 8f       	std	Z+24, r23	; 0x18

void     setSn_MSSR(SOCKET s, uint16 mss)
{
   IINCHIP_WRITE(Sn_MSSR0(s), mss >> 8);
   IINCHIP_WRITE(Sn_MSSR1(s), mss);
}
   1f290:	61 8f       	std	Z+25, r22	; 0x19
   1f292:	08 95       	ret

0001f294 <getSn_KPALVTR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f294:	e8 2f       	mov	r30, r24
   1f296:	f0 e0       	ldi	r31, 0x00	; 0
   1f298:	e8 5f       	subi	r30, 0xF8	; 248
   1f29a:	fd 4f       	sbci	r31, 0xFD	; 253
   1f29c:	46 e0       	ldi	r20, 0x06	; 6
   1f29e:	ee 0f       	add	r30, r30
   1f2a0:	ff 1f       	adc	r31, r31
   1f2a2:	4a 95       	dec	r20
   1f2a4:	e1 f7       	brne	.-8      	; 0x1f29e <getSn_KPALVTR+0xa>
   1f2a6:	83 8d       	ldd	r24, Z+27	; 0x1b
/* SOCKET communication */

uint8    getSn_KPALVTR(SOCKET s)
{
   return (uint8)(IINCHIP_READ(Sn_KPALVTR(s)) >> 8);
}
   1f2a8:	80 e0       	ldi	r24, 0x00	; 0
   1f2aa:	08 95       	ret

0001f2ac <setSn_KPALVTR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f2ac:	e8 2f       	mov	r30, r24
   1f2ae:	f0 e0       	ldi	r31, 0x00	; 0
   1f2b0:	e8 5f       	subi	r30, 0xF8	; 248
   1f2b2:	fd 4f       	sbci	r31, 0xFD	; 253
   1f2b4:	56 e0       	ldi	r21, 0x06	; 6
   1f2b6:	ee 0f       	add	r30, r30
   1f2b8:	ff 1f       	adc	r31, r31
   1f2ba:	5a 95       	dec	r21
   1f2bc:	e1 f7       	brne	.-8      	; 0x1f2b6 <setSn_KPALVTR+0xa>
   1f2be:	23 8d       	ldd	r18, Z+27	; 0x1b

void     setSn_KPALVTR(SOCKET s, uint8 time)
{
   uint16 keepalive=0;
   keepalive = (IINCHIP_READ(Sn_KPALVTR(s)) & 0x00FF) + ((uint16)time<<8);
   IINCHIP_WRITE(Sn_KPALVTR(s),keepalive);
   1f2c0:	96 2f       	mov	r25, r22
   1f2c2:	80 e0       	ldi	r24, 0x00	; 0
   1f2c4:	82 0f       	add	r24, r18
   1f2c6:	91 1d       	adc	r25, r1
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f2c8:	83 8f       	std	Z+27, r24	; 0x1b
void     setSn_KPALVTR(SOCKET s, uint8 time)
{
   uint16 keepalive=0;
   keepalive = (IINCHIP_READ(Sn_KPALVTR(s)) & 0x00FF) + ((uint16)time<<8);
   IINCHIP_WRITE(Sn_KPALVTR(s),keepalive);
}
   1f2ca:	08 95       	ret

0001f2cc <getSn_TX_WRSR>:
	union {
		uint32 s32;
		uint8 s8[4];
	} u32;

	u32.s8[3] = IINCHIP_READ(Sn_TX_WRSR(s));
   1f2cc:	e8 2f       	mov	r30, r24
   1f2ce:	f0 e0       	ldi	r31, 0x00	; 0
   1f2d0:	ee 0f       	add	r30, r30
   1f2d2:	ff 1f       	adc	r31, r31
   1f2d4:	ef 5e       	subi	r30, 0xEF	; 239
   1f2d6:	fb 4f       	sbci	r31, 0xFB	; 251
   1f2d8:	df 01       	movw	r26, r30
   1f2da:	65 e0       	ldi	r22, 0x05	; 5
   1f2dc:	aa 0f       	add	r26, r26
   1f2de:	bb 1f       	adc	r27, r27
   1f2e0:	6a 95       	dec	r22
   1f2e2:	e1 f7       	brne	.-8      	; 0x1f2dc <getSn_TX_WRSR+0x10>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f2e4:	9c 91       	ld	r25, X
	u32.s8[2] = IINCHIP_READ(Sn_TX_WRSR1(s));
	u32.s8[1] = IINCHIP_READ(Sn_TX_WRSR2(s));
	u32.s8[0] = IINCHIP_READ(Sn_TX_WRSR3(s));

	return u32.s32;
}
   1f2e6:	11 96       	adiw	r26, 0x01	; 1
   1f2e8:	8c 91       	ld	r24, X
   1f2ea:	11 97       	sbiw	r26, 0x01	; 1
   1f2ec:	fd 01       	movw	r30, r26
   1f2ee:	32 96       	adiw	r30, 0x02	; 2
   1f2f0:	70 81       	ld	r23, Z
   1f2f2:	13 96       	adiw	r26, 0x03	; 3
   1f2f4:	6c 91       	ld	r22, X
   1f2f6:	08 95       	ret

0001f2f8 <setSn_TX_WRSR>:
		uint8 s8[4];
	} u32;

	u32.s32 = size;

	IINCHIP_WRITE(Sn_TX_WRSR(s), u32.s8[3]);
   1f2f8:	e8 2f       	mov	r30, r24
   1f2fa:	f0 e0       	ldi	r31, 0x00	; 0
   1f2fc:	ee 0f       	add	r30, r30
   1f2fe:	ff 1f       	adc	r31, r31
   1f300:	ef 5e       	subi	r30, 0xEF	; 239
   1f302:	fb 4f       	sbci	r31, 0xFB	; 251
   1f304:	df 01       	movw	r26, r30
   1f306:	e5 e0       	ldi	r30, 0x05	; 5
   1f308:	aa 0f       	add	r26, r26
   1f30a:	bb 1f       	adc	r27, r27
   1f30c:	ea 95       	dec	r30
   1f30e:	e1 f7       	brne	.-8      	; 0x1f308 <setSn_TX_WRSR+0x10>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f310:	7c 93       	st	X, r23

	IINCHIP_WRITE(Sn_TX_WRSR(s), u32.s8[3]);
	IINCHIP_WRITE(Sn_TX_WRSR1(s), u32.s8[2]);
	IINCHIP_WRITE(Sn_TX_WRSR2(s), u32.s8[1]);
	IINCHIP_WRITE(Sn_TX_WRSR3(s), u32.s8[0]);
}
   1f312:	11 96       	adiw	r26, 0x01	; 1
   1f314:	6c 93       	st	X, r22
   1f316:	11 97       	sbiw	r26, 0x01	; 1
   1f318:	fd 01       	movw	r30, r26
   1f31a:	32 96       	adiw	r30, 0x02	; 2
   1f31c:	50 83       	st	Z, r21
   1f31e:	13 96       	adiw	r26, 0x03	; 3
   1f320:	4c 93       	st	X, r20
   1f322:	08 95       	ret

0001f324 <getSn_TX_FSR>:

uint32   getSn_TX_FSR(SOCKET s)
{
   1f324:	6f 92       	push	r6
   1f326:	7f 92       	push	r7
   1f328:	8f 92       	push	r8
   1f32a:	9f 92       	push	r9
   1f32c:	af 92       	push	r10
   1f32e:	bf 92       	push	r11
   1f330:	cf 92       	push	r12
   1f332:	df 92       	push	r13
   1f334:	ef 92       	push	r14
   1f336:	ff 92       	push	r15
   1f338:	0f 93       	push	r16
   1f33a:	1f 93       	push	r17
   1f33c:	cf 93       	push	r28
   1f33e:	df 93       	push	r29
   uint32 free_tx_size=0;
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
   1f340:	90 e0       	ldi	r25, 0x00	; 0
   1f342:	88 5f       	subi	r24, 0xF8	; 248
   1f344:	9d 4f       	sbci	r25, 0xFD	; 253
   1f346:	56 e0       	ldi	r21, 0x06	; 6
   1f348:	88 0f       	add	r24, r24
   1f34a:	99 1f       	adc	r25, r25
   1f34c:	5a 95       	dec	r21
   1f34e:	e1 f7       	brne	.-8      	; 0x1f348 <getSn_TX_FSR+0x24>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f350:	44 e2       	ldi	r20, 0x24	; 36
   1f352:	84 2e       	mov	r8, r20
   1f354:	91 2c       	mov	r9, r1
   1f356:	88 0e       	add	r8, r24
   1f358:	99 1e       	adc	r9, r25
   uint32 free_tx_size=0;
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
   1f35a:	bc 01       	movw	r22, r24
   1f35c:	6b 5d       	subi	r22, 0xDB	; 219
   1f35e:	7f 4f       	sbci	r23, 0xFF	; 255
   1f360:	ec 01       	movw	r28, r24
   1f362:	a6 96       	adiw	r28, 0x26	; 38
   1f364:	37 e2       	ldi	r19, 0x27	; 39
   1f366:	63 2e       	mov	r6, r19
   1f368:	71 2c       	mov	r7, r1
   1f36a:	68 0e       	add	r6, r24
   1f36c:	79 1e       	adc	r7, r25
   1f36e:	aa 24       	eor	r10, r10
   1f370:	bb 24       	eor	r11, r11
   1f372:	65 01       	movw	r12, r10
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f374:	d4 01       	movw	r26, r8
   1f376:	8c 91       	ld	r24, X
   uint32 free_tx_size=0;
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
   1f378:	90 e0       	ldi	r25, 0x00	; 0
   1f37a:	a0 e0       	ldi	r26, 0x00	; 0
   1f37c:	b0 e0       	ldi	r27, 0x00	; 0
   1f37e:	ba 2f       	mov	r27, r26
   1f380:	a9 2f       	mov	r26, r25
   1f382:	98 2f       	mov	r25, r24
   1f384:	88 27       	eor	r24, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f386:	fb 01       	movw	r30, r22
   1f388:	20 81       	ld	r18, Z
   uint32 free_tx_size=0;
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
   1f38a:	82 0f       	add	r24, r18
   1f38c:	91 1d       	adc	r25, r1
   1f38e:	a1 1d       	adc	r26, r1
   1f390:	b1 1d       	adc	r27, r1
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR2(s));
   1f392:	ba 2f       	mov	r27, r26
   1f394:	a9 2f       	mov	r26, r25
   1f396:	98 2f       	mov	r25, r24
   1f398:	88 27       	eor	r24, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f39a:	28 81       	ld	r18, Y
   uint32 free_tx_size1=0;
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR2(s));
   1f39c:	82 0f       	add	r24, r18
   1f39e:	91 1d       	adc	r25, r1
   1f3a0:	a1 1d       	adc	r26, r1
   1f3a2:	b1 1d       	adc	r27, r1
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR3(s));                                                       
   1f3a4:	ee 24       	eor	r14, r14
   1f3a6:	f8 2e       	mov	r15, r24
   1f3a8:	09 2f       	mov	r16, r25
   1f3aa:	1a 2f       	mov	r17, r26
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f3ac:	d3 01       	movw	r26, r6
   1f3ae:	8c 91       	ld	r24, X
   while(1)
   {
      free_tx_size = IINCHIP_READ(Sn_TX_FSR(s));                           // read                                       
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR1(s));
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR2(s));
      free_tx_size = (free_tx_size << 8) + IINCHIP_READ(Sn_TX_FSR3(s));                                                       
   1f3b0:	e8 0e       	add	r14, r24
   1f3b2:	f1 1c       	adc	r15, r1
   1f3b4:	01 1d       	adc	r16, r1
   1f3b6:	11 1d       	adc	r17, r1
      if(free_tx_size == free_tx_size1) break;                             // if first == sencond, Sn_TX_FSR value is valid.                                                          
   1f3b8:	ea 14       	cp	r14, r10
   1f3ba:	fb 04       	cpc	r15, r11
   1f3bc:	0c 05       	cpc	r16, r12
   1f3be:	1d 05       	cpc	r17, r13
   1f3c0:	29 f0       	breq	.+10     	; 0x1f3cc <getSn_TX_FSR+0xa8>
   1f3c2:	c7 01       	movw	r24, r14
   1f3c4:	d8 01       	movw	r26, r16
   1f3c6:	5c 01       	movw	r10, r24
   1f3c8:	6d 01       	movw	r12, r26
   1f3ca:	d4 cf       	rjmp	.-88     	; 0x1f374 <getSn_TX_FSR+0x50>
      free_tx_size1 = free_tx_size;                                        // save second value into firs                                                    
   }                                                                       
   return free_tx_size;                                                    
}                                                                          
   1f3cc:	b5 01       	movw	r22, r10
   1f3ce:	c6 01       	movw	r24, r12
   1f3d0:	df 91       	pop	r29
   1f3d2:	cf 91       	pop	r28
   1f3d4:	1f 91       	pop	r17
   1f3d6:	0f 91       	pop	r16
   1f3d8:	ff 90       	pop	r15
   1f3da:	ef 90       	pop	r14
   1f3dc:	df 90       	pop	r13
   1f3de:	cf 90       	pop	r12
   1f3e0:	bf 90       	pop	r11
   1f3e2:	af 90       	pop	r10
   1f3e4:	9f 90       	pop	r9
   1f3e6:	8f 90       	pop	r8
   1f3e8:	7f 90       	pop	r7
   1f3ea:	6f 90       	pop	r6
   1f3ec:	08 95       	ret

0001f3ee <getSn_RX_RSR>:

uint32   getSn_RX_RSR(SOCKET s)
{
   1f3ee:	6f 92       	push	r6
   1f3f0:	7f 92       	push	r7
   1f3f2:	8f 92       	push	r8
   1f3f4:	9f 92       	push	r9
   1f3f6:	af 92       	push	r10
   1f3f8:	bf 92       	push	r11
   1f3fa:	cf 92       	push	r12
   1f3fc:	df 92       	push	r13
   1f3fe:	ef 92       	push	r14
   1f400:	ff 92       	push	r15
   1f402:	0f 93       	push	r16
   1f404:	1f 93       	push	r17
   1f406:	cf 93       	push	r28
   1f408:	df 93       	push	r29
   uint32 received_rx_size=0;
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
   1f40a:	90 e0       	ldi	r25, 0x00	; 0
   1f40c:	88 5f       	subi	r24, 0xF8	; 248
   1f40e:	9d 4f       	sbci	r25, 0xFD	; 253
   1f410:	46 e0       	ldi	r20, 0x06	; 6
   1f412:	88 0f       	add	r24, r24
   1f414:	99 1f       	adc	r25, r25
   1f416:	4a 95       	dec	r20
   1f418:	e1 f7       	brne	.-8      	; 0x1f412 <getSn_RX_RSR+0x24>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f41a:	38 e2       	ldi	r19, 0x28	; 40
   1f41c:	83 2e       	mov	r8, r19
   1f41e:	91 2c       	mov	r9, r1
   1f420:	88 0e       	add	r8, r24
   1f422:	99 1e       	adc	r9, r25
   uint32 received_rx_size=0;
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
   1f424:	bc 01       	movw	r22, r24
   1f426:	67 5d       	subi	r22, 0xD7	; 215
   1f428:	7f 4f       	sbci	r23, 0xFF	; 255
   1f42a:	ec 01       	movw	r28, r24
   1f42c:	aa 96       	adiw	r28, 0x2a	; 42
   1f42e:	2b e2       	ldi	r18, 0x2B	; 43
   1f430:	62 2e       	mov	r6, r18
   1f432:	71 2c       	mov	r7, r1
   1f434:	68 0e       	add	r6, r24
   1f436:	79 1e       	adc	r7, r25
   1f438:	01 e0       	ldi	r16, 0x01	; 1
   1f43a:	a0 2e       	mov	r10, r16
   1f43c:	b1 2c       	mov	r11, r1
   1f43e:	c1 2c       	mov	r12, r1
   1f440:	d1 2c       	mov	r13, r1
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f442:	d4 01       	movw	r26, r8
   1f444:	8c 91       	ld	r24, X
   uint32 received_rx_size=0;
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
   1f446:	90 e0       	ldi	r25, 0x00	; 0
   1f448:	a0 e0       	ldi	r26, 0x00	; 0
   1f44a:	b0 e0       	ldi	r27, 0x00	; 0
   1f44c:	ba 2f       	mov	r27, r26
   1f44e:	a9 2f       	mov	r26, r25
   1f450:	98 2f       	mov	r25, r24
   1f452:	88 27       	eor	r24, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f454:	fb 01       	movw	r30, r22
   1f456:	20 81       	ld	r18, Z
   uint32 received_rx_size=0;
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
   1f458:	82 0f       	add	r24, r18
   1f45a:	91 1d       	adc	r25, r1
   1f45c:	a1 1d       	adc	r26, r1
   1f45e:	b1 1d       	adc	r27, r1
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR2(s));
   1f460:	ba 2f       	mov	r27, r26
   1f462:	a9 2f       	mov	r26, r25
   1f464:	98 2f       	mov	r25, r24
   1f466:	88 27       	eor	r24, r24
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f468:	28 81       	ld	r18, Y
   uint32 received_rx_size1=1;
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR2(s));
   1f46a:	82 0f       	add	r24, r18
   1f46c:	91 1d       	adc	r25, r1
   1f46e:	a1 1d       	adc	r26, r1
   1f470:	b1 1d       	adc	r27, r1
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR3(s));                                  
   1f472:	ee 24       	eor	r14, r14
   1f474:	f8 2e       	mov	r15, r24
   1f476:	09 2f       	mov	r16, r25
   1f478:	1a 2f       	mov	r17, r26
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f47a:	d3 01       	movw	r26, r6
   1f47c:	8c 91       	ld	r24, X
   while(1)
   {
      received_rx_size = IINCHIP_READ(Sn_RX_RSR(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR1(s));  // read    
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR2(s));
      received_rx_size = (received_rx_size << 8) + IINCHIP_READ(Sn_RX_RSR3(s));                                  
   1f47e:	e8 0e       	add	r14, r24
   1f480:	f1 1c       	adc	r15, r1
   1f482:	01 1d       	adc	r16, r1
   1f484:	11 1d       	adc	r17, r1
      if(received_rx_size == received_rx_size1) break;                                                                         
   1f486:	ea 14       	cp	r14, r10
   1f488:	fb 04       	cpc	r15, r11
   1f48a:	0c 05       	cpc	r16, r12
   1f48c:	1d 05       	cpc	r17, r13
   1f48e:	29 f0       	breq	.+10     	; 0x1f49a <getSn_RX_RSR+0xac>
   1f490:	c7 01       	movw	r24, r14
   1f492:	d8 01       	movw	r26, r16
   1f494:	5c 01       	movw	r10, r24
   1f496:	6d 01       	movw	r12, r26
   1f498:	d4 cf       	rjmp	.-88     	; 0x1f442 <getSn_RX_RSR+0x54>
      received_rx_size1 = received_rx_size;                                      // if first == sencond, Sn_RX_RSR value is valid.
   }                                                                             // save second value into firs                
   return received_rx_size;   
}
   1f49a:	b5 01       	movw	r22, r10
   1f49c:	c6 01       	movw	r24, r12
   1f49e:	df 91       	pop	r29
   1f4a0:	cf 91       	pop	r28
   1f4a2:	1f 91       	pop	r17
   1f4a4:	0f 91       	pop	r16
   1f4a6:	ff 90       	pop	r15
   1f4a8:	ef 90       	pop	r14
   1f4aa:	df 90       	pop	r13
   1f4ac:	cf 90       	pop	r12
   1f4ae:	bf 90       	pop	r11
   1f4b0:	af 90       	pop	r10
   1f4b2:	9f 90       	pop	r9
   1f4b4:	8f 90       	pop	r8
   1f4b6:	7f 90       	pop	r7
   1f4b8:	6f 90       	pop	r6
   1f4ba:	08 95       	ret

0001f4bc <setSn_TX_FIFOR>:


void     setSn_TX_FIFOR(SOCKET s, uint16 data)
{
   IINCHIP_WRITE(Sn_TX_FIFOR(s), data >> 8);
   1f4bc:	e8 2f       	mov	r30, r24
   1f4be:	f0 e0       	ldi	r31, 0x00	; 0
   1f4c0:	e8 5f       	subi	r30, 0xF8	; 248
   1f4c2:	fd 4f       	sbci	r31, 0xFD	; 253
   1f4c4:	56 e0       	ldi	r21, 0x06	; 6
   1f4c6:	ee 0f       	add	r30, r30
   1f4c8:	ff 1f       	adc	r31, r31
   1f4ca:	5a 95       	dec	r21
   1f4cc:	e1 f7       	brne	.-8      	; 0x1f4c6 <setSn_TX_FIFOR+0xa>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f4ce:	76 a7       	std	Z+46, r23	; 0x2e

void     setSn_TX_FIFOR(SOCKET s, uint16 data)
{
   IINCHIP_WRITE(Sn_TX_FIFOR(s), data >> 8);
   IINCHIP_WRITE(Sn_TX_FIFOR1(s), data);
}
   1f4d0:	67 a7       	std	Z+47, r22	; 0x2f
   1f4d2:	08 95       	ret

0001f4d4 <getSn_RX_FIFOR>:

uint16   getSn_RX_FIFOR(SOCKET s)
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_RX_FIFOR(s)) << 8;
   1f4d4:	e8 2f       	mov	r30, r24
   1f4d6:	f0 e0       	ldi	r31, 0x00	; 0
   1f4d8:	e8 5f       	subi	r30, 0xF8	; 248
   1f4da:	fd 4f       	sbci	r31, 0xFD	; 253
   1f4dc:	66 e0       	ldi	r22, 0x06	; 6
   1f4de:	ee 0f       	add	r30, r30
   1f4e0:	ff 1f       	adc	r31, r31
   1f4e2:	6a 95       	dec	r22
   1f4e4:	e1 f7       	brne	.-8      	; 0x1f4de <getSn_RX_FIFOR+0xa>
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f4e6:	20 a9       	ldd	r18, Z+48	; 0x30
}

uint16   getSn_RX_FIFOR(SOCKET s)
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_RX_FIFOR(s)) << 8;
   1f4e8:	92 2f       	mov	r25, r18
   1f4ea:	80 e0       	ldi	r24, 0x00	; 0
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f4ec:	21 a9       	ldd	r18, Z+49	; 0x31
   1f4ee:	30 e0       	ldi	r19, 0x00	; 0
   1f4f0:	28 2b       	or	r18, r24
   1f4f2:	39 2b       	or	r19, r25
{
	 uint16 ret = 0;
	 ret = IINCHIP_READ(Sn_RX_FIFOR(s)) << 8;
	 ret |= IINCHIP_READ(Sn_RX_FIFOR1(s));
   return ret;
}
   1f4f4:	c9 01       	movw	r24, r18
   1f4f6:	08 95       	ret

0001f4f8 <getSn_PROTOR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f4f8:	e8 2f       	mov	r30, r24
   1f4fa:	f0 e0       	ldi	r31, 0x00	; 0
   1f4fc:	e8 5f       	subi	r30, 0xF8	; 248
   1f4fe:	fd 4f       	sbci	r31, 0xFD	; 253
   1f500:	76 e0       	ldi	r23, 0x06	; 6
   1f502:	ee 0f       	add	r30, r30
   1f504:	ff 1f       	adc	r31, r31
   1f506:	7a 95       	dec	r23
   1f508:	e1 f7       	brne	.-8      	; 0x1f502 <getSn_PROTOR+0xa>
   1f50a:	83 8d       	ldd	r24, Z+27	; 0x1b
/* IP header field */

uint8    getSn_PROTOR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_PROTOR(s));
}
   1f50c:	08 95       	ret

0001f50e <setSn_PROTOR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f50e:	e8 2f       	mov	r30, r24
   1f510:	f0 e0       	ldi	r31, 0x00	; 0
   1f512:	e8 5f       	subi	r30, 0xF8	; 248
   1f514:	fd 4f       	sbci	r31, 0xFD	; 253
   1f516:	a6 e0       	ldi	r26, 0x06	; 6
   1f518:	ee 0f       	add	r30, r30
   1f51a:	ff 1f       	adc	r31, r31
   1f51c:	aa 95       	dec	r26
   1f51e:	e1 f7       	brne	.-8      	; 0x1f518 <setSn_PROTOR+0xa>
   1f520:	83 8d       	ldd	r24, Z+27	; 0x1b
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f522:	63 8f       	std	Z+27, r22	; 0x1b
void     setSn_PROTOR(SOCKET s, uint8 pronum)
{
   uint16 protocolnum;
   protocolnum = (IINCHIP_READ(Sn_PROTOR(s)) & 0xFF00) + pronum;
   IINCHIP_WRITE(Sn_PROTOR(s),protocolnum);
}
   1f524:	08 95       	ret

0001f526 <getSn_TOSR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f526:	e8 2f       	mov	r30, r24
   1f528:	f0 e0       	ldi	r31, 0x00	; 0
   1f52a:	e8 5f       	subi	r30, 0xF8	; 248
   1f52c:	fd 4f       	sbci	r31, 0xFD	; 253
   1f52e:	b6 e0       	ldi	r27, 0x06	; 6
   1f530:	ee 0f       	add	r30, r30
   1f532:	ff 1f       	adc	r31, r31
   1f534:	ba 95       	dec	r27
   1f536:	e1 f7       	brne	.-8      	; 0x1f530 <getSn_TOSR+0xa>
   1f538:	84 8d       	ldd	r24, Z+28	; 0x1c
}

uint8    getSn_TOSR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_TOSR(s));
}
   1f53a:	08 95       	ret

0001f53c <setSn_TOSR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f53c:	e8 2f       	mov	r30, r24
   1f53e:	f0 e0       	ldi	r31, 0x00	; 0
   1f540:	e8 5f       	subi	r30, 0xF8	; 248
   1f542:	fd 4f       	sbci	r31, 0xFD	; 253
   1f544:	86 e0       	ldi	r24, 0x06	; 6
   1f546:	ee 0f       	add	r30, r30
   1f548:	ff 1f       	adc	r31, r31
   1f54a:	8a 95       	dec	r24
   1f54c:	e1 f7       	brne	.-8      	; 0x1f546 <setSn_TOSR+0xa>
   1f54e:	64 8f       	std	Z+28, r22	; 0x1c
   return (uint8)IINCHIP_READ(Sn_TOSR(s));
}
void     setSn_TOSR(SOCKET s, uint8 tos)
{
   IINCHIP_WRITE(Sn_TOSR(s),tos);
}
   1f550:	08 95       	ret

0001f552 <getSn_TTLR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f552:	e8 2f       	mov	r30, r24
   1f554:	f0 e0       	ldi	r31, 0x00	; 0
   1f556:	e8 5f       	subi	r30, 0xF8	; 248
   1f558:	fd 4f       	sbci	r31, 0xFD	; 253
   1f55a:	96 e0       	ldi	r25, 0x06	; 6
   1f55c:	ee 0f       	add	r30, r30
   1f55e:	ff 1f       	adc	r31, r31
   1f560:	9a 95       	dec	r25
   1f562:	e1 f7       	brne	.-8      	; 0x1f55c <getSn_TTLR+0xa>
   1f564:	86 8d       	ldd	r24, Z+30	; 0x1e
}

uint8    getSn_TTLR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_TTLR(s));
}
   1f566:	08 95       	ret

0001f568 <setSn_TTLR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f568:	e8 2f       	mov	r30, r24
   1f56a:	f0 e0       	ldi	r31, 0x00	; 0
   1f56c:	e8 5f       	subi	r30, 0xF8	; 248
   1f56e:	fd 4f       	sbci	r31, 0xFD	; 253
   1f570:	26 e0       	ldi	r18, 0x06	; 6
   1f572:	ee 0f       	add	r30, r30
   1f574:	ff 1f       	adc	r31, r31
   1f576:	2a 95       	dec	r18
   1f578:	e1 f7       	brne	.-8      	; 0x1f572 <setSn_TTLR+0xa>
   1f57a:	66 8f       	std	Z+30, r22	; 0x1e
   return (uint8)IINCHIP_READ(Sn_TTLR(s));
}
void     setSn_TTLR(SOCKET s, uint8 ttl)
{
   IINCHIP_WRITE(Sn_TTLR(s),ttl);
}
   1f57c:	08 95       	ret

0001f57e <getSn_FRAGR>:
 * Basic I/O  Function *
 ***********************/
uint8 IINCHIP_READ(uint16 addr)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
	 return ({*((vuint8*)(addr));});
   1f57e:	e8 2f       	mov	r30, r24
   1f580:	f0 e0       	ldi	r31, 0x00	; 0
   1f582:	e8 5f       	subi	r30, 0xF8	; 248
   1f584:	fd 4f       	sbci	r31, 0xFD	; 253
   1f586:	36 e0       	ldi	r19, 0x06	; 6
   1f588:	ee 0f       	add	r30, r30
   1f58a:	ff 1f       	adc	r31, r31
   1f58c:	3a 95       	dec	r19
   1f58e:	e1 f7       	brne	.-8      	; 0x1f588 <getSn_FRAGR+0xa>
   1f590:	84 a5       	ldd	r24, Z+44	; 0x2c
}

uint8    getSn_FRAGR(SOCKET s)
{
   return (uint8)IINCHIP_READ(Sn_FRAGR(s));
}
   1f592:	08 95       	ret

0001f594 <setSn_FRAGR>:
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f594:	e8 2f       	mov	r30, r24
   1f596:	f0 e0       	ldi	r31, 0x00	; 0
   1f598:	e8 5f       	subi	r30, 0xF8	; 248
   1f59a:	fd 4f       	sbci	r31, 0xFD	; 253
   1f59c:	46 e0       	ldi	r20, 0x06	; 6
   1f59e:	ee 0f       	add	r30, r30
   1f5a0:	ff 1f       	adc	r31, r31
   1f5a2:	4a 95       	dec	r20
   1f5a4:	e1 f7       	brne	.-8      	; 0x1f59e <setSn_FRAGR+0xa>
   1f5a6:	64 a7       	std	Z+44, r22	; 0x2c
}

void     setSn_FRAGR(SOCKET s, uint8 frag)
{
   IINCHIP_WRITE(Sn_FRAGR(s),frag);
}
   1f5a8:	08 95       	ret

0001f5aa <sysinit>:


/* Internal memory operation */
 
uint8    sysinit(uint8* tx_size, uint8* rx_size)
{
   1f5aa:	cf 92       	push	r12
   1f5ac:	df 92       	push	r13
   1f5ae:	ef 92       	push	r14
   1f5b0:	ff 92       	push	r15
   1f5b2:	0f 93       	push	r16
   1f5b4:	1f 93       	push	r17
   1f5b6:	cf 93       	push	r28
   1f5b8:	df 93       	push	r29
   1f5ba:	6c 01       	movw	r12, r24
   1f5bc:	9b 01       	movw	r18, r22
   1f5be:	7b 01       	movw	r14, r22
   1f5c0:	b6 01       	movw	r22, r12
   1f5c2:	e9 01       	movw	r28, r18
   1f5c4:	00 e0       	ldi	r16, 0x00	; 0
   1f5c6:	10 e0       	ldi	r17, 0x00	; 0
   1f5c8:	40 e0       	ldi	r20, 0x00	; 0
   1f5ca:	50 e0       	ldi	r21, 0x00	; 0
   1f5cc:	20 e0       	ldi	r18, 0x00	; 0
   1f5ce:	30 e0       	ldi	r19, 0x00	; 0
   uint16 ssum=0,rsum=0;
   uint mem_cfg = 0;
   
   for(i=0; i < MAX_SOCK_NUM; i++)
   {
      if(tx_size[i] > 64)
   1f5d0:	db 01       	movw	r26, r22
   1f5d2:	8c 91       	ld	r24, X
   1f5d4:	81 34       	cpi	r24, 0x41	; 65
   1f5d6:	08 f0       	brcs	.+2      	; 0x1f5da <sysinit+0x30>
   1f5d8:	6b c0       	rjmp	.+214    	; 0x1f6b0 <sysinit+0x106>
      #ifdef __DEF_IINCHIP_DBG__
         printf("Illegal Channel(%d) TX Memory Size.\r\n",i);
      #endif
         return 0;
      }
      if(rx_size[i] > 64)
   1f5da:	98 81       	ld	r25, Y
   1f5dc:	91 34       	cpi	r25, 0x41	; 65
   1f5de:	08 f0       	brcs	.+2      	; 0x1f5e2 <sysinit+0x38>
   1f5e0:	67 c0       	rjmp	.+206    	; 0x1f6b0 <sysinit+0x106>
      #ifdef __DEF_IINCHIP_DBG__         
         printf("Illegal Channel(%d) RX Memory Size.\r\n",i);
      #endif
         return 0;
      }
      ssum += (uint16)tx_size[i];
   1f5e2:	08 0f       	add	r16, r24
   1f5e4:	11 1d       	adc	r17, r1
      rsum += (uint16)rx_size[i];
   1f5e6:	49 0f       	add	r20, r25
   1f5e8:	51 1d       	adc	r21, r1
      TXMEM_SIZE[i] = ((uint32)tx_size[i]) << 10;
   1f5ea:	f9 01       	movw	r30, r18
   1f5ec:	e8 59       	subi	r30, 0x98	; 152
   1f5ee:	fc 4f       	sbci	r31, 0xFC	; 252
   1f5f0:	90 e0       	ldi	r25, 0x00	; 0
   1f5f2:	a0 e0       	ldi	r26, 0x00	; 0
   1f5f4:	b0 e0       	ldi	r27, 0x00	; 0
   1f5f6:	07 2e       	mov	r0, r23
   1f5f8:	7a e0       	ldi	r23, 0x0A	; 10
   1f5fa:	88 0f       	add	r24, r24
   1f5fc:	99 1f       	adc	r25, r25
   1f5fe:	aa 1f       	adc	r26, r26
   1f600:	bb 1f       	adc	r27, r27
   1f602:	7a 95       	dec	r23
   1f604:	d1 f7       	brne	.-12     	; 0x1f5fa <sysinit+0x50>
   1f606:	70 2d       	mov	r23, r0
   1f608:	80 83       	st	Z, r24
   1f60a:	91 83       	std	Z+1, r25	; 0x01
   1f60c:	a2 83       	std	Z+2, r26	; 0x02
   1f60e:	b3 83       	std	Z+3, r27	; 0x03
      RXMEM_SIZE[i] = ((uint32)rx_size[i]) << 10;
   1f610:	f9 01       	movw	r30, r18
   1f612:	e8 5b       	subi	r30, 0xB8	; 184
   1f614:	fc 4f       	sbci	r31, 0xFC	; 252
   1f616:	89 91       	ld	r24, Y+
   1f618:	90 e0       	ldi	r25, 0x00	; 0
   1f61a:	a0 e0       	ldi	r26, 0x00	; 0
   1f61c:	b0 e0       	ldi	r27, 0x00	; 0
   1f61e:	07 2e       	mov	r0, r23
   1f620:	7a e0       	ldi	r23, 0x0A	; 10
   1f622:	88 0f       	add	r24, r24
   1f624:	99 1f       	adc	r25, r25
   1f626:	aa 1f       	adc	r26, r26
   1f628:	bb 1f       	adc	r27, r27
   1f62a:	7a 95       	dec	r23
   1f62c:	d1 f7       	brne	.-12     	; 0x1f622 <sysinit+0x78>
   1f62e:	70 2d       	mov	r23, r0
   1f630:	80 83       	st	Z, r24
   1f632:	91 83       	std	Z+1, r25	; 0x01
   1f634:	a2 83       	std	Z+2, r26	; 0x02
   1f636:	b3 83       	std	Z+3, r27	; 0x03
   1f638:	6f 5f       	subi	r22, 0xFF	; 255
   1f63a:	7f 4f       	sbci	r23, 0xFF	; 255
   1f63c:	2c 5f       	subi	r18, 0xFC	; 252
   1f63e:	3f 4f       	sbci	r19, 0xFF	; 255
   uint8 k;
   uint16 i;
   uint16 ssum=0,rsum=0;
   uint mem_cfg = 0;
   
   for(i=0; i < MAX_SOCK_NUM; i++)
   1f640:	20 32       	cpi	r18, 0x20	; 32
   1f642:	31 05       	cpc	r19, r1
   1f644:	29 f6       	brne	.-118    	; 0x1f5d0 <sysinit+0x26>
      ssum += (uint16)tx_size[i];
      rsum += (uint16)rx_size[i];
      TXMEM_SIZE[i] = ((uint32)tx_size[i]) << 10;
      RXMEM_SIZE[i] = ((uint32)rx_size[i]) << 10;
   }
   if( (ssum % 8) || ((ssum + rsum) != 128) )
   1f646:	c8 01       	movw	r24, r16
   1f648:	87 70       	andi	r24, 0x07	; 7
   1f64a:	90 70       	andi	r25, 0x00	; 0
   1f64c:	89 2b       	or	r24, r25
   1f64e:	81 f5       	brne	.+96     	; 0x1f6b0 <sysinit+0x106>
   1f650:	40 0f       	add	r20, r16
   1f652:	51 1f       	adc	r21, r17
   1f654:	40 38       	cpi	r20, 0x80	; 128
   1f656:	51 05       	cpc	r21, r1
   1f658:	59 f5       	brne	.+86     	; 0x1f6b0 <sysinit+0x106>
   1f65a:	e0 e2       	ldi	r30, 0x20	; 32
   1f65c:	f0 e8       	ldi	r31, 0x80	; 128
      return 0;
   }
   
   k = 0;
   for(i = TMSR0; i <= TMSR7; i++) {
      IINCHIP_WRITE(i, tx_size[k]);
   1f65e:	d6 01       	movw	r26, r12
   1f660:	8d 91       	ld	r24, X+
   1f662:	6d 01       	movw	r12, r26
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f664:	81 93       	st	Z+, r24
   #endif
      return 0;
   }
   
   k = 0;
   for(i = TMSR0; i <= TMSR7; i++) {
   1f666:	b0 e8       	ldi	r27, 0x80	; 128
   1f668:	e8 32       	cpi	r30, 0x28	; 40
   1f66a:	fb 07       	cpc	r31, r27
   1f66c:	c1 f7       	brne	.-16     	; 0x1f65e <sysinit+0xb4>
   k++;
	 }
   
   k = 0;
   for(i = RMSR0; i <= RMSR7; i++) {
      IINCHIP_WRITE(i, rx_size[k]);
   1f66e:	d7 01       	movw	r26, r14
   1f670:	8d 91       	ld	r24, X+
   1f672:	7d 01       	movw	r14, r26
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f674:	81 93       	st	Z+, r24
      IINCHIP_WRITE(i, tx_size[k]);
   k++;
	 }
   
   k = 0;
   for(i = RMSR0; i <= RMSR7; i++) {
   1f676:	b0 e8       	ldi	r27, 0x80	; 128
   1f678:	e0 33       	cpi	r30, 0x30	; 48
   1f67a:	fb 07       	cpc	r31, r27
   1f67c:	c1 f7       	brne	.-16     	; 0x1f66e <sysinit+0xc4>
      IINCHIP_WRITE(i, rx_size[k]);
   k++;
   }
   
   for(i=0; i <ssum/8 ; i++)
   1f67e:	c8 01       	movw	r24, r16
   1f680:	73 e0       	ldi	r23, 0x03	; 3
   1f682:	96 95       	lsr	r25
   1f684:	87 95       	ror	r24
   1f686:	7a 95       	dec	r23
   1f688:	e1 f7       	brne	.-8      	; 0x1f682 <sysinit+0xd8>
   1f68a:	40 e0       	ldi	r20, 0x00	; 0
   1f68c:	50 e0       	ldi	r21, 0x00	; 0
   1f68e:	20 e0       	ldi	r18, 0x00	; 0
   1f690:	30 e0       	ldi	r19, 0x00	; 0
   1f692:	05 c0       	rjmp	.+10     	; 0x1f69e <sysinit+0xf4>
   {
      mem_cfg <<= 1;
   1f694:	22 0f       	add	r18, r18
   1f696:	33 1f       	adc	r19, r19
      mem_cfg |= 1;
   1f698:	21 60       	ori	r18, 0x01	; 1
   for(i = RMSR0; i <= RMSR7; i++) {
      IINCHIP_WRITE(i, rx_size[k]);
   k++;
   }
   
   for(i=0; i <ssum/8 ; i++)
   1f69a:	4f 5f       	subi	r20, 0xFF	; 255
   1f69c:	5f 4f       	sbci	r21, 0xFF	; 255
   1f69e:	48 17       	cp	r20, r24
   1f6a0:	59 07       	cpc	r21, r25
   1f6a2:	c0 f3       	brcs	.-16     	; 0x1f694 <sysinit+0xea>
}

void IINCHIP_WRITE(uint16 addr,uint8 data)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)  
	 ({*((vuint8*)(addr)) = data;});
   1f6a4:	30 93 30 80 	sts	0x8030, r19
      printf("%02d : %07dKB : %07dKB \r\n", 6, (uint8)(IINCHIP_READ(TMSR6)),(uint8)(IINCHIP_READ(RMSR6)));
      printf("%02d : %07dKB : %07dKB \r\n", 7, (uint8)(IINCHIP_READ(TMSR7)),(uint8)(IINCHIP_READ(RMSR7)));
      printf("\r\nMTYPER=%04x\r\n",IINCHIP_READ(MTYPER));
   #endif
   
   return 1;
   1f6a8:	20 93 31 80 	sts	0x8031, r18
   1f6ac:	81 e0       	ldi	r24, 0x01	; 1
   1f6ae:	01 c0       	rjmp	.+2      	; 0x1f6b2 <sysinit+0x108>
   1f6b0:	80 e0       	ldi	r24, 0x00	; 0
}
   1f6b2:	df 91       	pop	r29
   1f6b4:	cf 91       	pop	r28
   1f6b6:	1f 91       	pop	r17
   1f6b8:	0f 91       	pop	r16
   1f6ba:	ff 90       	pop	r15
   1f6bc:	ef 90       	pop	r14
   1f6be:	df 90       	pop	r13
   1f6c0:	cf 90       	pop	r12
   1f6c2:	08 95       	ret

0001f6c4 <wiz_write_buf>:

uint32   wiz_write_buf(SOCKET s,uint8* buf,uint32 len)
{
   1f6c4:	ef 92       	push	r14
   1f6c6:	ff 92       	push	r15
   1f6c8:	0f 93       	push	r16
   1f6ca:	1f 93       	push	r17
   1f6cc:	cf 93       	push	r28
   1f6ce:	df 93       	push	r29
   1f6d0:	79 01       	movw	r14, r18
   1f6d2:	8a 01       	movw	r16, r20
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;					
				for(z=0; z<len; z+=2) { 
					*((vuint8*)Sn_TX_FIFOR(s)) = *(buf+z);
   1f6d4:	90 e0       	ldi	r25, 0x00	; 0
   1f6d6:	88 5f       	subi	r24, 0xF8	; 248
   1f6d8:	9d 4f       	sbci	r25, 0xFD	; 253
   1f6da:	26 e0       	ldi	r18, 0x06	; 6
   1f6dc:	88 0f       	add	r24, r24
   1f6de:	99 1f       	adc	r25, r25
   1f6e0:	2a 95       	dec	r18
   1f6e2:	e1 f7       	brne	.-8      	; 0x1f6dc <wiz_write_buf+0x18>
   1f6e4:	ec 01       	movw	r28, r24
   1f6e6:	ae 96       	adiw	r28, 0x2e	; 46
					*((vuint8*)Sn_TX_FIFOR1(s)) = *(buf+z+1);
   1f6e8:	dc 01       	movw	r26, r24
   1f6ea:	9f 96       	adiw	r26, 0x2f	; 47
   1f6ec:	fb 01       	movw	r30, r22
   1f6ee:	20 e0       	ldi	r18, 0x00	; 0
   1f6f0:	30 e0       	ldi	r19, 0x00	; 0
   1f6f2:	40 e0       	ldi	r20, 0x00	; 0
   1f6f4:	50 e0       	ldi	r21, 0x00	; 0
   1f6f6:	09 c0       	rjmp	.+18     	; 0x1f70a <wiz_write_buf+0x46>
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;					
				for(z=0; z<len; z+=2) { 
					*((vuint8*)Sn_TX_FIFOR(s)) = *(buf+z);
   1f6f8:	80 81       	ld	r24, Z
   1f6fa:	88 83       	st	Y, r24
					*((vuint8*)Sn_TX_FIFOR1(s)) = *(buf+z+1);
   1f6fc:	81 81       	ldd	r24, Z+1	; 0x01
   1f6fe:	8c 93       	st	X, r24
uint32   wiz_write_buf(SOCKET s,uint8* buf,uint32 len)
{
#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;					
				for(z=0; z<len; z+=2) { 
   1f700:	2e 5f       	subi	r18, 0xFE	; 254
   1f702:	3f 4f       	sbci	r19, 0xFF	; 255
   1f704:	4f 4f       	sbci	r20, 0xFF	; 255
   1f706:	5f 4f       	sbci	r21, 0xFF	; 255
   1f708:	32 96       	adiw	r30, 0x02	; 2
   1f70a:	2e 15       	cp	r18, r14
   1f70c:	3f 05       	cpc	r19, r15
   1f70e:	40 07       	cpc	r20, r16
   1f710:	51 07       	cpc	r21, r17
   1f712:	90 f3       	brcs	.-28     	; 0x1f6f8 <wiz_write_buf+0x34>
   #endif 
#else
   #error "Undefined __DEF_IINCHIP_ADDRESS_MODE__"   
#endif
    return len;   
}
   1f714:	b7 01       	movw	r22, r14
   1f716:	c8 01       	movw	r24, r16
   1f718:	df 91       	pop	r29
   1f71a:	cf 91       	pop	r28
   1f71c:	1f 91       	pop	r17
   1f71e:	0f 91       	pop	r16
   1f720:	ff 90       	pop	r15
   1f722:	ef 90       	pop	r14
   1f724:	08 95       	ret

0001f726 <wiz_read_buf>:

uint32   wiz_read_buf(SOCKET s, uint8* buf,uint32 len)
{
   1f726:	ef 92       	push	r14
   1f728:	ff 92       	push	r15
   1f72a:	0f 93       	push	r16
   1f72c:	1f 93       	push	r17
   1f72e:	cf 93       	push	r28
   1f730:	df 93       	push	r29
   1f732:	79 01       	movw	r14, r18
   1f734:	8a 01       	movw	r16, r20

#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;	
				for(z=0; z<len; z+=2) { 
					*(buf+z) = *((vuint8*)Sn_RX_FIFOR(s));
   1f736:	90 e0       	ldi	r25, 0x00	; 0
   1f738:	88 5f       	subi	r24, 0xF8	; 248
   1f73a:	9d 4f       	sbci	r25, 0xFD	; 253
   1f73c:	36 e0       	ldi	r19, 0x06	; 6
   1f73e:	88 0f       	add	r24, r24
   1f740:	99 1f       	adc	r25, r25
   1f742:	3a 95       	dec	r19
   1f744:	e1 f7       	brne	.-8      	; 0x1f73e <wiz_read_buf+0x18>
   1f746:	ec 01       	movw	r28, r24
   1f748:	e0 96       	adiw	r28, 0x30	; 48
					*(buf+z+1) = *((vuint8*)Sn_RX_FIFOR1(s));
   1f74a:	dc 01       	movw	r26, r24
   1f74c:	d1 96       	adiw	r26, 0x31	; 49
   1f74e:	fb 01       	movw	r30, r22
   1f750:	20 e0       	ldi	r18, 0x00	; 0
   1f752:	30 e0       	ldi	r19, 0x00	; 0
   1f754:	40 e0       	ldi	r20, 0x00	; 0
   1f756:	50 e0       	ldi	r21, 0x00	; 0
   1f758:	09 c0       	rjmp	.+18     	; 0x1f76c <wiz_read_buf+0x46>

#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;	
				for(z=0; z<len; z+=2) { 
					*(buf+z) = *((vuint8*)Sn_RX_FIFOR(s));
   1f75a:	88 81       	ld	r24, Y
   1f75c:	80 83       	st	Z, r24
					*(buf+z+1) = *((vuint8*)Sn_RX_FIFOR1(s));
   1f75e:	8c 91       	ld	r24, X
   1f760:	81 83       	std	Z+1, r24	; 0x01
{

#if (__DEF_IINCHIP_ADDRESS_MODE__ == __DEF_IINCHIP_DIRECT_MODE__)
   #if (__DEF_IINCHIP_BUF_OP__ == __DEF_C__)
				uint32 z;	
				for(z=0; z<len; z+=2) { 
   1f762:	2e 5f       	subi	r18, 0xFE	; 254
   1f764:	3f 4f       	sbci	r19, 0xFF	; 255
   1f766:	4f 4f       	sbci	r20, 0xFF	; 255
   1f768:	5f 4f       	sbci	r21, 0xFF	; 255
   1f76a:	32 96       	adiw	r30, 0x02	; 2
   1f76c:	2e 15       	cp	r18, r14
   1f76e:	3f 05       	cpc	r19, r15
   1f770:	40 07       	cpc	r20, r16
   1f772:	51 07       	cpc	r21, r17
   1f774:	90 f3       	brcs	.-28     	; 0x1f75a <wiz_read_buf+0x34>
   #endif 
#else
   #error "Undefined __DEF_IINCHIP_ADDRESS_MODE__"   
#endif
    return len;
}
   1f776:	b7 01       	movw	r22, r14
   1f778:	c8 01       	movw	r24, r16
   1f77a:	df 91       	pop	r29
   1f77c:	cf 91       	pop	r28
   1f77e:	1f 91       	pop	r17
   1f780:	0f 91       	pop	r16
   1f782:	ff 90       	pop	r15
   1f784:	ef 90       	pop	r14
   1f786:	08 95       	ret

0001f788 <getIINCHIP_TxMAX>:


uint32   getIINCHIP_TxMAX(SOCKET s)
{
   1f788:	e8 2f       	mov	r30, r24
   1f78a:	f0 e0       	ldi	r31, 0x00	; 0
   1f78c:	ee 0f       	add	r30, r30
   1f78e:	ff 1f       	adc	r31, r31
   1f790:	ee 0f       	add	r30, r30
   1f792:	ff 1f       	adc	r31, r31
   1f794:	e8 59       	subi	r30, 0x98	; 152
   1f796:	fc 4f       	sbci	r31, 0xFC	; 252
   1f798:	60 81       	ld	r22, Z
   1f79a:	71 81       	ldd	r23, Z+1	; 0x01
   return TXMEM_SIZE[s];
}
   1f79c:	82 81       	ldd	r24, Z+2	; 0x02
   1f79e:	93 81       	ldd	r25, Z+3	; 0x03
   1f7a0:	08 95       	ret

0001f7a2 <getIINCHIP_RxMAX>:

uint32   getIINCHIP_RxMAX(SOCKET s)
{
   1f7a2:	e8 2f       	mov	r30, r24
   1f7a4:	f0 e0       	ldi	r31, 0x00	; 0
   1f7a6:	ee 0f       	add	r30, r30
   1f7a8:	ff 1f       	adc	r31, r31
   1f7aa:	ee 0f       	add	r30, r30
   1f7ac:	ff 1f       	adc	r31, r31
   1f7ae:	e8 5b       	subi	r30, 0xB8	; 184
   1f7b0:	fc 4f       	sbci	r31, 0xFC	; 252
   1f7b2:	60 81       	ld	r22, Z
   1f7b4:	71 81       	ldd	r23, Z+1	; 0x01
   return RXMEM_SIZE[s];
}
   1f7b6:	82 81       	ldd	r24, Z+2	; 0x02
   1f7b8:	93 81       	ldd	r25, Z+3	; 0x03
   1f7ba:	08 95       	ret

0001f7bc <iinchip_init>:

/* Initialization & Interrupt request routine */

void     iinchip_init(void)
{
	*((volatile uint8*)MR) = MR_RST;
   1f7bc:	80 e8       	ldi	r24, 0x80	; 128
   1f7be:	80 93 01 80 	sts	0x8001, r24
	wait_1ms(5);				// wait PLL lock
   1f7c2:	85 e0       	ldi	r24, 0x05	; 5
   1f7c4:	90 e0       	ldi	r25, 0x00	; 0
   1f7c6:	0e 94 82 f0 	call	0x1e104	; 0x1e104 <wait_1ms>
		*((volatile uint8*)MR) = MR_IND;
    #ifndef __DEF_IINCHIP_DBG__	
	      printf("MR value is %04x\r\n",*((volatile uint8*)MR));
    #endif	
#endif
}
   1f7ca:	08 95       	ret

0001f7cc <__eerd_block>:
   1f7cc:	a0 e0       	ldi	r26, 0x00	; 0
   1f7ce:	b0 e0       	ldi	r27, 0x00	; 0
   1f7d0:	ec ee       	ldi	r30, 0xEC	; 236
   1f7d2:	fb ef       	ldi	r31, 0xFB	; 251
   1f7d4:	0c 94 d3 fe 	jmp	0x1fda6	; 0x1fda6 <__prologue_saves__+0x14>
   1f7d8:	7c 01       	movw	r14, r24
   1f7da:	eb 01       	movw	r28, r22
   1f7dc:	8a 01       	movw	r16, r20
   1f7de:	69 01       	movw	r12, r18
   1f7e0:	09 c0       	rjmp	.+18     	; 0x1f7f4 <__eerd_block+0x28>
   1f7e2:	ce 01       	movw	r24, r28
   1f7e4:	21 96       	adiw	r28, 0x01	; 1
   1f7e6:	f6 01       	movw	r30, r12
   1f7e8:	09 95       	icall
   1f7ea:	f7 01       	movw	r30, r14
   1f7ec:	81 93       	st	Z+, r24
   1f7ee:	7f 01       	movw	r14, r30
   1f7f0:	01 50       	subi	r16, 0x01	; 1
   1f7f2:	10 40       	sbci	r17, 0x00	; 0
   1f7f4:	01 15       	cp	r16, r1
   1f7f6:	11 05       	cpc	r17, r1
   1f7f8:	a1 f7       	brne	.-24     	; 0x1f7e2 <__eerd_block+0x16>
   1f7fa:	cd b7       	in	r28, 0x3d	; 61
   1f7fc:	de b7       	in	r29, 0x3e	; 62
   1f7fe:	e8 e0       	ldi	r30, 0x08	; 8
   1f800:	0c 94 ef fe 	jmp	0x1fdde	; 0x1fdde <__epilogue_restores__+0x14>

0001f804 <printf>:
   1f804:	a0 e0       	ldi	r26, 0x00	; 0
   1f806:	b0 e0       	ldi	r27, 0x00	; 0
   1f808:	e8 e0       	ldi	r30, 0x08	; 8
   1f80a:	fc ef       	ldi	r31, 0xFC	; 252
   1f80c:	0c 94 d9 fe 	jmp	0x1fdb2	; 0x1fdb2 <__prologue_saves__+0x20>
   1f810:	fe 01       	movw	r30, r28
   1f812:	35 96       	adiw	r30, 0x05	; 5
   1f814:	61 91       	ld	r22, Z+
   1f816:	71 91       	ld	r23, Z+
   1f818:	80 91 8a 03 	lds	r24, 0x038A
   1f81c:	90 91 8b 03 	lds	r25, 0x038B
   1f820:	af 01       	movw	r20, r30
   1f822:	0e 94 4c fc 	call	0x1f898	; 0x1f898 <vfprintf>
   1f826:	20 96       	adiw	r28, 0x00	; 0
   1f828:	e2 e0       	ldi	r30, 0x02	; 2
   1f82a:	0c 94 f5 fe 	jmp	0x1fdea	; 0x1fdea <__epilogue_restores__+0x20>

0001f82e <puts>:
   1f82e:	0f 93       	push	r16
   1f830:	1f 93       	push	r17
   1f832:	cf 93       	push	r28
   1f834:	df 93       	push	r29
   1f836:	8c 01       	movw	r16, r24
   1f838:	e0 91 8a 03 	lds	r30, 0x038A
   1f83c:	f0 91 8b 03 	lds	r31, 0x038B
   1f840:	83 81       	ldd	r24, Z+3	; 0x03
   1f842:	81 ff       	sbrs	r24, 1
   1f844:	21 c0       	rjmp	.+66     	; 0x1f888 <puts+0x5a>
   1f846:	c0 e0       	ldi	r28, 0x00	; 0
   1f848:	d0 e0       	ldi	r29, 0x00	; 0
   1f84a:	0d c0       	rjmp	.+26     	; 0x1f866 <puts+0x38>
   1f84c:	e0 91 8a 03 	lds	r30, 0x038A
   1f850:	f0 91 8b 03 	lds	r31, 0x038B
   1f854:	20 85       	ldd	r18, Z+8	; 0x08
   1f856:	31 85       	ldd	r19, Z+9	; 0x09
   1f858:	bf 01       	movw	r22, r30
   1f85a:	f9 01       	movw	r30, r18
   1f85c:	09 95       	icall
   1f85e:	89 2b       	or	r24, r25
   1f860:	11 f0       	breq	.+4      	; 0x1f866 <puts+0x38>
   1f862:	cf ef       	ldi	r28, 0xFF	; 255
   1f864:	df ef       	ldi	r29, 0xFF	; 255
   1f866:	f8 01       	movw	r30, r16
   1f868:	81 91       	ld	r24, Z+
   1f86a:	8f 01       	movw	r16, r30
   1f86c:	88 23       	and	r24, r24
   1f86e:	71 f7       	brne	.-36     	; 0x1f84c <puts+0x1e>
   1f870:	e0 91 8a 03 	lds	r30, 0x038A
   1f874:	f0 91 8b 03 	lds	r31, 0x038B
   1f878:	20 85       	ldd	r18, Z+8	; 0x08
   1f87a:	31 85       	ldd	r19, Z+9	; 0x09
   1f87c:	8a e0       	ldi	r24, 0x0A	; 10
   1f87e:	bf 01       	movw	r22, r30
   1f880:	f9 01       	movw	r30, r18
   1f882:	09 95       	icall
   1f884:	89 2b       	or	r24, r25
   1f886:	11 f0       	breq	.+4      	; 0x1f88c <puts+0x5e>
   1f888:	cf ef       	ldi	r28, 0xFF	; 255
   1f88a:	df ef       	ldi	r29, 0xFF	; 255
   1f88c:	ce 01       	movw	r24, r28
   1f88e:	df 91       	pop	r29
   1f890:	cf 91       	pop	r28
   1f892:	1f 91       	pop	r17
   1f894:	0f 91       	pop	r16
   1f896:	08 95       	ret

0001f898 <vfprintf>:
   1f898:	ab e0       	ldi	r26, 0x0B	; 11
   1f89a:	b0 e0       	ldi	r27, 0x00	; 0
   1f89c:	e2 e5       	ldi	r30, 0x52	; 82
   1f89e:	fc ef       	ldi	r31, 0xFC	; 252
   1f8a0:	0c 94 c9 fe 	jmp	0x1fd92	; 0x1fd92 <__prologue_saves__>
   1f8a4:	3c 01       	movw	r6, r24
   1f8a6:	2b 01       	movw	r4, r22
   1f8a8:	5a 01       	movw	r10, r20
   1f8aa:	fc 01       	movw	r30, r24
   1f8ac:	17 82       	std	Z+7, r1	; 0x07
   1f8ae:	16 82       	std	Z+6, r1	; 0x06
   1f8b0:	83 81       	ldd	r24, Z+3	; 0x03
   1f8b2:	81 fd       	sbrc	r24, 1
   1f8b4:	03 c0       	rjmp	.+6      	; 0x1f8bc <vfprintf+0x24>
   1f8b6:	6f ef       	ldi	r22, 0xFF	; 255
   1f8b8:	7f ef       	ldi	r23, 0xFF	; 255
   1f8ba:	c6 c1       	rjmp	.+908    	; 0x1fc48 <vfprintf+0x3b0>
   1f8bc:	9a e0       	ldi	r25, 0x0A	; 10
   1f8be:	89 2e       	mov	r8, r25
   1f8c0:	1e 01       	movw	r2, r28
   1f8c2:	08 94       	sec
   1f8c4:	21 1c       	adc	r2, r1
   1f8c6:	31 1c       	adc	r3, r1
   1f8c8:	f3 01       	movw	r30, r6
   1f8ca:	23 81       	ldd	r18, Z+3	; 0x03
   1f8cc:	f2 01       	movw	r30, r4
   1f8ce:	23 fd       	sbrc	r18, 3
   1f8d0:	85 91       	lpm	r24, Z+
   1f8d2:	23 ff       	sbrs	r18, 3
   1f8d4:	81 91       	ld	r24, Z+
   1f8d6:	2f 01       	movw	r4, r30
   1f8d8:	88 23       	and	r24, r24
   1f8da:	09 f4       	brne	.+2      	; 0x1f8de <vfprintf+0x46>
   1f8dc:	b2 c1       	rjmp	.+868    	; 0x1fc42 <vfprintf+0x3aa>
   1f8de:	85 32       	cpi	r24, 0x25	; 37
   1f8e0:	39 f4       	brne	.+14     	; 0x1f8f0 <vfprintf+0x58>
   1f8e2:	23 fd       	sbrc	r18, 3
   1f8e4:	85 91       	lpm	r24, Z+
   1f8e6:	23 ff       	sbrs	r18, 3
   1f8e8:	81 91       	ld	r24, Z+
   1f8ea:	2f 01       	movw	r4, r30
   1f8ec:	85 32       	cpi	r24, 0x25	; 37
   1f8ee:	29 f4       	brne	.+10     	; 0x1f8fa <vfprintf+0x62>
   1f8f0:	90 e0       	ldi	r25, 0x00	; 0
   1f8f2:	b3 01       	movw	r22, r6
   1f8f4:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1f8f8:	e7 cf       	rjmp	.-50     	; 0x1f8c8 <vfprintf+0x30>
   1f8fa:	98 2f       	mov	r25, r24
   1f8fc:	ff 24       	eor	r15, r15
   1f8fe:	ee 24       	eor	r14, r14
   1f900:	99 24       	eor	r9, r9
   1f902:	ff e1       	ldi	r31, 0x1F	; 31
   1f904:	ff 15       	cp	r31, r15
   1f906:	d0 f0       	brcs	.+52     	; 0x1f93c <vfprintf+0xa4>
   1f908:	9b 32       	cpi	r25, 0x2B	; 43
   1f90a:	69 f0       	breq	.+26     	; 0x1f926 <vfprintf+0x8e>
   1f90c:	9c 32       	cpi	r25, 0x2C	; 44
   1f90e:	28 f4       	brcc	.+10     	; 0x1f91a <vfprintf+0x82>
   1f910:	90 32       	cpi	r25, 0x20	; 32
   1f912:	59 f0       	breq	.+22     	; 0x1f92a <vfprintf+0x92>
   1f914:	93 32       	cpi	r25, 0x23	; 35
   1f916:	91 f4       	brne	.+36     	; 0x1f93c <vfprintf+0xa4>
   1f918:	0e c0       	rjmp	.+28     	; 0x1f936 <vfprintf+0x9e>
   1f91a:	9d 32       	cpi	r25, 0x2D	; 45
   1f91c:	49 f0       	breq	.+18     	; 0x1f930 <vfprintf+0x98>
   1f91e:	90 33       	cpi	r25, 0x30	; 48
   1f920:	69 f4       	brne	.+26     	; 0x1f93c <vfprintf+0xa4>
   1f922:	41 e0       	ldi	r20, 0x01	; 1
   1f924:	24 c0       	rjmp	.+72     	; 0x1f96e <vfprintf+0xd6>
   1f926:	52 e0       	ldi	r21, 0x02	; 2
   1f928:	f5 2a       	or	r15, r21
   1f92a:	84 e0       	ldi	r24, 0x04	; 4
   1f92c:	f8 2a       	or	r15, r24
   1f92e:	28 c0       	rjmp	.+80     	; 0x1f980 <vfprintf+0xe8>
   1f930:	98 e0       	ldi	r25, 0x08	; 8
   1f932:	f9 2a       	or	r15, r25
   1f934:	25 c0       	rjmp	.+74     	; 0x1f980 <vfprintf+0xe8>
   1f936:	e0 e1       	ldi	r30, 0x10	; 16
   1f938:	fe 2a       	or	r15, r30
   1f93a:	22 c0       	rjmp	.+68     	; 0x1f980 <vfprintf+0xe8>
   1f93c:	f7 fc       	sbrc	r15, 7
   1f93e:	29 c0       	rjmp	.+82     	; 0x1f992 <vfprintf+0xfa>
   1f940:	89 2f       	mov	r24, r25
   1f942:	80 53       	subi	r24, 0x30	; 48
   1f944:	8a 30       	cpi	r24, 0x0A	; 10
   1f946:	70 f4       	brcc	.+28     	; 0x1f964 <vfprintf+0xcc>
   1f948:	f6 fe       	sbrs	r15, 6
   1f94a:	05 c0       	rjmp	.+10     	; 0x1f956 <vfprintf+0xbe>
   1f94c:	98 9c       	mul	r9, r8
   1f94e:	90 2c       	mov	r9, r0
   1f950:	11 24       	eor	r1, r1
   1f952:	98 0e       	add	r9, r24
   1f954:	15 c0       	rjmp	.+42     	; 0x1f980 <vfprintf+0xe8>
   1f956:	e8 9c       	mul	r14, r8
   1f958:	e0 2c       	mov	r14, r0
   1f95a:	11 24       	eor	r1, r1
   1f95c:	e8 0e       	add	r14, r24
   1f95e:	f0 e2       	ldi	r31, 0x20	; 32
   1f960:	ff 2a       	or	r15, r31
   1f962:	0e c0       	rjmp	.+28     	; 0x1f980 <vfprintf+0xe8>
   1f964:	9e 32       	cpi	r25, 0x2E	; 46
   1f966:	29 f4       	brne	.+10     	; 0x1f972 <vfprintf+0xda>
   1f968:	f6 fc       	sbrc	r15, 6
   1f96a:	6b c1       	rjmp	.+726    	; 0x1fc42 <vfprintf+0x3aa>
   1f96c:	40 e4       	ldi	r20, 0x40	; 64
   1f96e:	f4 2a       	or	r15, r20
   1f970:	07 c0       	rjmp	.+14     	; 0x1f980 <vfprintf+0xe8>
   1f972:	9c 36       	cpi	r25, 0x6C	; 108
   1f974:	19 f4       	brne	.+6      	; 0x1f97c <vfprintf+0xe4>
   1f976:	50 e8       	ldi	r21, 0x80	; 128
   1f978:	f5 2a       	or	r15, r21
   1f97a:	02 c0       	rjmp	.+4      	; 0x1f980 <vfprintf+0xe8>
   1f97c:	98 36       	cpi	r25, 0x68	; 104
   1f97e:	49 f4       	brne	.+18     	; 0x1f992 <vfprintf+0xfa>
   1f980:	f2 01       	movw	r30, r4
   1f982:	23 fd       	sbrc	r18, 3
   1f984:	95 91       	lpm	r25, Z+
   1f986:	23 ff       	sbrs	r18, 3
   1f988:	91 91       	ld	r25, Z+
   1f98a:	2f 01       	movw	r4, r30
   1f98c:	99 23       	and	r25, r25
   1f98e:	09 f0       	breq	.+2      	; 0x1f992 <vfprintf+0xfa>
   1f990:	b8 cf       	rjmp	.-144    	; 0x1f902 <vfprintf+0x6a>
   1f992:	89 2f       	mov	r24, r25
   1f994:	85 54       	subi	r24, 0x45	; 69
   1f996:	83 30       	cpi	r24, 0x03	; 3
   1f998:	18 f0       	brcs	.+6      	; 0x1f9a0 <vfprintf+0x108>
   1f99a:	80 52       	subi	r24, 0x20	; 32
   1f99c:	83 30       	cpi	r24, 0x03	; 3
   1f99e:	38 f4       	brcc	.+14     	; 0x1f9ae <vfprintf+0x116>
   1f9a0:	44 e0       	ldi	r20, 0x04	; 4
   1f9a2:	50 e0       	ldi	r21, 0x00	; 0
   1f9a4:	a4 0e       	add	r10, r20
   1f9a6:	b5 1e       	adc	r11, r21
   1f9a8:	5f e3       	ldi	r21, 0x3F	; 63
   1f9aa:	59 83       	std	Y+1, r21	; 0x01
   1f9ac:	0f c0       	rjmp	.+30     	; 0x1f9cc <vfprintf+0x134>
   1f9ae:	93 36       	cpi	r25, 0x63	; 99
   1f9b0:	31 f0       	breq	.+12     	; 0x1f9be <vfprintf+0x126>
   1f9b2:	93 37       	cpi	r25, 0x73	; 115
   1f9b4:	79 f0       	breq	.+30     	; 0x1f9d4 <vfprintf+0x13c>
   1f9b6:	93 35       	cpi	r25, 0x53	; 83
   1f9b8:	09 f0       	breq	.+2      	; 0x1f9bc <vfprintf+0x124>
   1f9ba:	56 c0       	rjmp	.+172    	; 0x1fa68 <vfprintf+0x1d0>
   1f9bc:	20 c0       	rjmp	.+64     	; 0x1f9fe <vfprintf+0x166>
   1f9be:	f5 01       	movw	r30, r10
   1f9c0:	80 81       	ld	r24, Z
   1f9c2:	89 83       	std	Y+1, r24	; 0x01
   1f9c4:	42 e0       	ldi	r20, 0x02	; 2
   1f9c6:	50 e0       	ldi	r21, 0x00	; 0
   1f9c8:	a4 0e       	add	r10, r20
   1f9ca:	b5 1e       	adc	r11, r21
   1f9cc:	61 01       	movw	r12, r2
   1f9ce:	01 e0       	ldi	r16, 0x01	; 1
   1f9d0:	10 e0       	ldi	r17, 0x00	; 0
   1f9d2:	12 c0       	rjmp	.+36     	; 0x1f9f8 <vfprintf+0x160>
   1f9d4:	f5 01       	movw	r30, r10
   1f9d6:	c0 80       	ld	r12, Z
   1f9d8:	d1 80       	ldd	r13, Z+1	; 0x01
   1f9da:	f6 fc       	sbrc	r15, 6
   1f9dc:	03 c0       	rjmp	.+6      	; 0x1f9e4 <vfprintf+0x14c>
   1f9de:	6f ef       	ldi	r22, 0xFF	; 255
   1f9e0:	7f ef       	ldi	r23, 0xFF	; 255
   1f9e2:	02 c0       	rjmp	.+4      	; 0x1f9e8 <vfprintf+0x150>
   1f9e4:	69 2d       	mov	r22, r9
   1f9e6:	70 e0       	ldi	r23, 0x00	; 0
   1f9e8:	42 e0       	ldi	r20, 0x02	; 2
   1f9ea:	50 e0       	ldi	r21, 0x00	; 0
   1f9ec:	a4 0e       	add	r10, r20
   1f9ee:	b5 1e       	adc	r11, r21
   1f9f0:	c6 01       	movw	r24, r12
   1f9f2:	0e 94 34 fe 	call	0x1fc68	; 0x1fc68 <strnlen>
   1f9f6:	8c 01       	movw	r16, r24
   1f9f8:	5f e7       	ldi	r21, 0x7F	; 127
   1f9fa:	f5 22       	and	r15, r21
   1f9fc:	14 c0       	rjmp	.+40     	; 0x1fa26 <vfprintf+0x18e>
   1f9fe:	f5 01       	movw	r30, r10
   1fa00:	c0 80       	ld	r12, Z
   1fa02:	d1 80       	ldd	r13, Z+1	; 0x01
   1fa04:	f6 fc       	sbrc	r15, 6
   1fa06:	03 c0       	rjmp	.+6      	; 0x1fa0e <vfprintf+0x176>
   1fa08:	6f ef       	ldi	r22, 0xFF	; 255
   1fa0a:	7f ef       	ldi	r23, 0xFF	; 255
   1fa0c:	02 c0       	rjmp	.+4      	; 0x1fa12 <vfprintf+0x17a>
   1fa0e:	69 2d       	mov	r22, r9
   1fa10:	70 e0       	ldi	r23, 0x00	; 0
   1fa12:	42 e0       	ldi	r20, 0x02	; 2
   1fa14:	50 e0       	ldi	r21, 0x00	; 0
   1fa16:	a4 0e       	add	r10, r20
   1fa18:	b5 1e       	adc	r11, r21
   1fa1a:	c6 01       	movw	r24, r12
   1fa1c:	0e 94 29 fe 	call	0x1fc52	; 0x1fc52 <strnlen_P>
   1fa20:	8c 01       	movw	r16, r24
   1fa22:	50 e8       	ldi	r21, 0x80	; 128
   1fa24:	f5 2a       	or	r15, r21
   1fa26:	f3 fe       	sbrs	r15, 3
   1fa28:	07 c0       	rjmp	.+14     	; 0x1fa38 <vfprintf+0x1a0>
   1fa2a:	1a c0       	rjmp	.+52     	; 0x1fa60 <vfprintf+0x1c8>
   1fa2c:	80 e2       	ldi	r24, 0x20	; 32
   1fa2e:	90 e0       	ldi	r25, 0x00	; 0
   1fa30:	b3 01       	movw	r22, r6
   1fa32:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1fa36:	ea 94       	dec	r14
   1fa38:	8e 2d       	mov	r24, r14
   1fa3a:	90 e0       	ldi	r25, 0x00	; 0
   1fa3c:	08 17       	cp	r16, r24
   1fa3e:	19 07       	cpc	r17, r25
   1fa40:	a8 f3       	brcs	.-22     	; 0x1fa2c <vfprintf+0x194>
   1fa42:	0e c0       	rjmp	.+28     	; 0x1fa60 <vfprintf+0x1c8>
   1fa44:	f6 01       	movw	r30, r12
   1fa46:	f7 fc       	sbrc	r15, 7
   1fa48:	85 91       	lpm	r24, Z+
   1fa4a:	f7 fe       	sbrs	r15, 7
   1fa4c:	81 91       	ld	r24, Z+
   1fa4e:	6f 01       	movw	r12, r30
   1fa50:	90 e0       	ldi	r25, 0x00	; 0
   1fa52:	b3 01       	movw	r22, r6
   1fa54:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1fa58:	e1 10       	cpse	r14, r1
   1fa5a:	ea 94       	dec	r14
   1fa5c:	01 50       	subi	r16, 0x01	; 1
   1fa5e:	10 40       	sbci	r17, 0x00	; 0
   1fa60:	01 15       	cp	r16, r1
   1fa62:	11 05       	cpc	r17, r1
   1fa64:	79 f7       	brne	.-34     	; 0x1fa44 <vfprintf+0x1ac>
   1fa66:	ea c0       	rjmp	.+468    	; 0x1fc3c <vfprintf+0x3a4>
   1fa68:	94 36       	cpi	r25, 0x64	; 100
   1fa6a:	11 f0       	breq	.+4      	; 0x1fa70 <vfprintf+0x1d8>
   1fa6c:	99 36       	cpi	r25, 0x69	; 105
   1fa6e:	69 f5       	brne	.+90     	; 0x1faca <vfprintf+0x232>
   1fa70:	f7 fe       	sbrs	r15, 7
   1fa72:	08 c0       	rjmp	.+16     	; 0x1fa84 <vfprintf+0x1ec>
   1fa74:	f5 01       	movw	r30, r10
   1fa76:	20 81       	ld	r18, Z
   1fa78:	31 81       	ldd	r19, Z+1	; 0x01
   1fa7a:	42 81       	ldd	r20, Z+2	; 0x02
   1fa7c:	53 81       	ldd	r21, Z+3	; 0x03
   1fa7e:	84 e0       	ldi	r24, 0x04	; 4
   1fa80:	90 e0       	ldi	r25, 0x00	; 0
   1fa82:	0a c0       	rjmp	.+20     	; 0x1fa98 <vfprintf+0x200>
   1fa84:	f5 01       	movw	r30, r10
   1fa86:	80 81       	ld	r24, Z
   1fa88:	91 81       	ldd	r25, Z+1	; 0x01
   1fa8a:	9c 01       	movw	r18, r24
   1fa8c:	44 27       	eor	r20, r20
   1fa8e:	37 fd       	sbrc	r19, 7
   1fa90:	40 95       	com	r20
   1fa92:	54 2f       	mov	r21, r20
   1fa94:	82 e0       	ldi	r24, 0x02	; 2
   1fa96:	90 e0       	ldi	r25, 0x00	; 0
   1fa98:	a8 0e       	add	r10, r24
   1fa9a:	b9 1e       	adc	r11, r25
   1fa9c:	9f e6       	ldi	r25, 0x6F	; 111
   1fa9e:	f9 22       	and	r15, r25
   1faa0:	57 ff       	sbrs	r21, 7
   1faa2:	09 c0       	rjmp	.+18     	; 0x1fab6 <vfprintf+0x21e>
   1faa4:	50 95       	com	r21
   1faa6:	40 95       	com	r20
   1faa8:	30 95       	com	r19
   1faaa:	21 95       	neg	r18
   1faac:	3f 4f       	sbci	r19, 0xFF	; 255
   1faae:	4f 4f       	sbci	r20, 0xFF	; 255
   1fab0:	5f 4f       	sbci	r21, 0xFF	; 255
   1fab2:	e0 e8       	ldi	r30, 0x80	; 128
   1fab4:	fe 2a       	or	r15, r30
   1fab6:	ca 01       	movw	r24, r20
   1fab8:	b9 01       	movw	r22, r18
   1faba:	a1 01       	movw	r20, r2
   1fabc:	2a e0       	ldi	r18, 0x0A	; 10
   1fabe:	30 e0       	ldi	r19, 0x00	; 0
   1fac0:	0e 94 6b fe 	call	0x1fcd6	; 0x1fcd6 <__ultoa_invert>
   1fac4:	d8 2e       	mov	r13, r24
   1fac6:	d2 18       	sub	r13, r2
   1fac8:	40 c0       	rjmp	.+128    	; 0x1fb4a <vfprintf+0x2b2>
   1faca:	95 37       	cpi	r25, 0x75	; 117
   1facc:	29 f4       	brne	.+10     	; 0x1fad8 <vfprintf+0x240>
   1face:	1f 2d       	mov	r17, r15
   1fad0:	1f 7e       	andi	r17, 0xEF	; 239
   1fad2:	2a e0       	ldi	r18, 0x0A	; 10
   1fad4:	30 e0       	ldi	r19, 0x00	; 0
   1fad6:	1d c0       	rjmp	.+58     	; 0x1fb12 <vfprintf+0x27a>
   1fad8:	1f 2d       	mov	r17, r15
   1fada:	19 7f       	andi	r17, 0xF9	; 249
   1fadc:	9f 36       	cpi	r25, 0x6F	; 111
   1fade:	61 f0       	breq	.+24     	; 0x1faf8 <vfprintf+0x260>
   1fae0:	90 37       	cpi	r25, 0x70	; 112
   1fae2:	20 f4       	brcc	.+8      	; 0x1faec <vfprintf+0x254>
   1fae4:	98 35       	cpi	r25, 0x58	; 88
   1fae6:	09 f0       	breq	.+2      	; 0x1faea <vfprintf+0x252>
   1fae8:	ac c0       	rjmp	.+344    	; 0x1fc42 <vfprintf+0x3aa>
   1faea:	0f c0       	rjmp	.+30     	; 0x1fb0a <vfprintf+0x272>
   1faec:	90 37       	cpi	r25, 0x70	; 112
   1faee:	39 f0       	breq	.+14     	; 0x1fafe <vfprintf+0x266>
   1faf0:	98 37       	cpi	r25, 0x78	; 120
   1faf2:	09 f0       	breq	.+2      	; 0x1faf6 <vfprintf+0x25e>
   1faf4:	a6 c0       	rjmp	.+332    	; 0x1fc42 <vfprintf+0x3aa>
   1faf6:	04 c0       	rjmp	.+8      	; 0x1fb00 <vfprintf+0x268>
   1faf8:	28 e0       	ldi	r18, 0x08	; 8
   1fafa:	30 e0       	ldi	r19, 0x00	; 0
   1fafc:	0a c0       	rjmp	.+20     	; 0x1fb12 <vfprintf+0x27a>
   1fafe:	10 61       	ori	r17, 0x10	; 16
   1fb00:	14 fd       	sbrc	r17, 4
   1fb02:	14 60       	ori	r17, 0x04	; 4
   1fb04:	20 e1       	ldi	r18, 0x10	; 16
   1fb06:	30 e0       	ldi	r19, 0x00	; 0
   1fb08:	04 c0       	rjmp	.+8      	; 0x1fb12 <vfprintf+0x27a>
   1fb0a:	14 fd       	sbrc	r17, 4
   1fb0c:	16 60       	ori	r17, 0x06	; 6
   1fb0e:	20 e1       	ldi	r18, 0x10	; 16
   1fb10:	32 e0       	ldi	r19, 0x02	; 2
   1fb12:	17 ff       	sbrs	r17, 7
   1fb14:	08 c0       	rjmp	.+16     	; 0x1fb26 <vfprintf+0x28e>
   1fb16:	f5 01       	movw	r30, r10
   1fb18:	60 81       	ld	r22, Z
   1fb1a:	71 81       	ldd	r23, Z+1	; 0x01
   1fb1c:	82 81       	ldd	r24, Z+2	; 0x02
   1fb1e:	93 81       	ldd	r25, Z+3	; 0x03
   1fb20:	44 e0       	ldi	r20, 0x04	; 4
   1fb22:	50 e0       	ldi	r21, 0x00	; 0
   1fb24:	08 c0       	rjmp	.+16     	; 0x1fb36 <vfprintf+0x29e>
   1fb26:	f5 01       	movw	r30, r10
   1fb28:	80 81       	ld	r24, Z
   1fb2a:	91 81       	ldd	r25, Z+1	; 0x01
   1fb2c:	bc 01       	movw	r22, r24
   1fb2e:	80 e0       	ldi	r24, 0x00	; 0
   1fb30:	90 e0       	ldi	r25, 0x00	; 0
   1fb32:	42 e0       	ldi	r20, 0x02	; 2
   1fb34:	50 e0       	ldi	r21, 0x00	; 0
   1fb36:	a4 0e       	add	r10, r20
   1fb38:	b5 1e       	adc	r11, r21
   1fb3a:	a1 01       	movw	r20, r2
   1fb3c:	0e 94 6b fe 	call	0x1fcd6	; 0x1fcd6 <__ultoa_invert>
   1fb40:	d8 2e       	mov	r13, r24
   1fb42:	d2 18       	sub	r13, r2
   1fb44:	8f e7       	ldi	r24, 0x7F	; 127
   1fb46:	f8 2e       	mov	r15, r24
   1fb48:	f1 22       	and	r15, r17
   1fb4a:	f6 fe       	sbrs	r15, 6
   1fb4c:	0b c0       	rjmp	.+22     	; 0x1fb64 <vfprintf+0x2cc>
   1fb4e:	5e ef       	ldi	r21, 0xFE	; 254
   1fb50:	f5 22       	and	r15, r21
   1fb52:	d9 14       	cp	r13, r9
   1fb54:	38 f4       	brcc	.+14     	; 0x1fb64 <vfprintf+0x2cc>
   1fb56:	f4 fe       	sbrs	r15, 4
   1fb58:	07 c0       	rjmp	.+14     	; 0x1fb68 <vfprintf+0x2d0>
   1fb5a:	f2 fc       	sbrc	r15, 2
   1fb5c:	05 c0       	rjmp	.+10     	; 0x1fb68 <vfprintf+0x2d0>
   1fb5e:	8f ee       	ldi	r24, 0xEF	; 239
   1fb60:	f8 22       	and	r15, r24
   1fb62:	02 c0       	rjmp	.+4      	; 0x1fb68 <vfprintf+0x2d0>
   1fb64:	1d 2d       	mov	r17, r13
   1fb66:	01 c0       	rjmp	.+2      	; 0x1fb6a <vfprintf+0x2d2>
   1fb68:	19 2d       	mov	r17, r9
   1fb6a:	f4 fe       	sbrs	r15, 4
   1fb6c:	0d c0       	rjmp	.+26     	; 0x1fb88 <vfprintf+0x2f0>
   1fb6e:	fe 01       	movw	r30, r28
   1fb70:	ed 0d       	add	r30, r13
   1fb72:	f1 1d       	adc	r31, r1
   1fb74:	80 81       	ld	r24, Z
   1fb76:	80 33       	cpi	r24, 0x30	; 48
   1fb78:	19 f4       	brne	.+6      	; 0x1fb80 <vfprintf+0x2e8>
   1fb7a:	99 ee       	ldi	r25, 0xE9	; 233
   1fb7c:	f9 22       	and	r15, r25
   1fb7e:	08 c0       	rjmp	.+16     	; 0x1fb90 <vfprintf+0x2f8>
   1fb80:	1f 5f       	subi	r17, 0xFF	; 255
   1fb82:	f2 fe       	sbrs	r15, 2
   1fb84:	05 c0       	rjmp	.+10     	; 0x1fb90 <vfprintf+0x2f8>
   1fb86:	03 c0       	rjmp	.+6      	; 0x1fb8e <vfprintf+0x2f6>
   1fb88:	8f 2d       	mov	r24, r15
   1fb8a:	86 78       	andi	r24, 0x86	; 134
   1fb8c:	09 f0       	breq	.+2      	; 0x1fb90 <vfprintf+0x2f8>
   1fb8e:	1f 5f       	subi	r17, 0xFF	; 255
   1fb90:	0f 2d       	mov	r16, r15
   1fb92:	f3 fc       	sbrc	r15, 3
   1fb94:	14 c0       	rjmp	.+40     	; 0x1fbbe <vfprintf+0x326>
   1fb96:	f0 fe       	sbrs	r15, 0
   1fb98:	0f c0       	rjmp	.+30     	; 0x1fbb8 <vfprintf+0x320>
   1fb9a:	1e 15       	cp	r17, r14
   1fb9c:	10 f0       	brcs	.+4      	; 0x1fba2 <vfprintf+0x30a>
   1fb9e:	9d 2c       	mov	r9, r13
   1fba0:	0b c0       	rjmp	.+22     	; 0x1fbb8 <vfprintf+0x320>
   1fba2:	9d 2c       	mov	r9, r13
   1fba4:	9e 0c       	add	r9, r14
   1fba6:	91 1a       	sub	r9, r17
   1fba8:	1e 2d       	mov	r17, r14
   1fbaa:	06 c0       	rjmp	.+12     	; 0x1fbb8 <vfprintf+0x320>
   1fbac:	80 e2       	ldi	r24, 0x20	; 32
   1fbae:	90 e0       	ldi	r25, 0x00	; 0
   1fbb0:	b3 01       	movw	r22, r6
   1fbb2:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1fbb6:	1f 5f       	subi	r17, 0xFF	; 255
   1fbb8:	1e 15       	cp	r17, r14
   1fbba:	c0 f3       	brcs	.-16     	; 0x1fbac <vfprintf+0x314>
   1fbbc:	04 c0       	rjmp	.+8      	; 0x1fbc6 <vfprintf+0x32e>
   1fbbe:	1e 15       	cp	r17, r14
   1fbc0:	10 f4       	brcc	.+4      	; 0x1fbc6 <vfprintf+0x32e>
   1fbc2:	e1 1a       	sub	r14, r17
   1fbc4:	01 c0       	rjmp	.+2      	; 0x1fbc8 <vfprintf+0x330>
   1fbc6:	ee 24       	eor	r14, r14
   1fbc8:	04 ff       	sbrs	r16, 4
   1fbca:	0f c0       	rjmp	.+30     	; 0x1fbea <vfprintf+0x352>
   1fbcc:	80 e3       	ldi	r24, 0x30	; 48
   1fbce:	90 e0       	ldi	r25, 0x00	; 0
   1fbd0:	b3 01       	movw	r22, r6
   1fbd2:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1fbd6:	02 ff       	sbrs	r16, 2
   1fbd8:	1d c0       	rjmp	.+58     	; 0x1fc14 <vfprintf+0x37c>
   1fbda:	01 fd       	sbrc	r16, 1
   1fbdc:	03 c0       	rjmp	.+6      	; 0x1fbe4 <vfprintf+0x34c>
   1fbde:	88 e7       	ldi	r24, 0x78	; 120
   1fbe0:	90 e0       	ldi	r25, 0x00	; 0
   1fbe2:	0e c0       	rjmp	.+28     	; 0x1fc00 <vfprintf+0x368>
   1fbe4:	88 e5       	ldi	r24, 0x58	; 88
   1fbe6:	90 e0       	ldi	r25, 0x00	; 0
   1fbe8:	0b c0       	rjmp	.+22     	; 0x1fc00 <vfprintf+0x368>
   1fbea:	80 2f       	mov	r24, r16
   1fbec:	86 78       	andi	r24, 0x86	; 134
   1fbee:	91 f0       	breq	.+36     	; 0x1fc14 <vfprintf+0x37c>
   1fbf0:	01 ff       	sbrs	r16, 1
   1fbf2:	02 c0       	rjmp	.+4      	; 0x1fbf8 <vfprintf+0x360>
   1fbf4:	8b e2       	ldi	r24, 0x2B	; 43
   1fbf6:	01 c0       	rjmp	.+2      	; 0x1fbfa <vfprintf+0x362>
   1fbf8:	80 e2       	ldi	r24, 0x20	; 32
   1fbfa:	f7 fc       	sbrc	r15, 7
   1fbfc:	8d e2       	ldi	r24, 0x2D	; 45
   1fbfe:	90 e0       	ldi	r25, 0x00	; 0
   1fc00:	b3 01       	movw	r22, r6
   1fc02:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1fc06:	06 c0       	rjmp	.+12     	; 0x1fc14 <vfprintf+0x37c>
   1fc08:	80 e3       	ldi	r24, 0x30	; 48
   1fc0a:	90 e0       	ldi	r25, 0x00	; 0
   1fc0c:	b3 01       	movw	r22, r6
   1fc0e:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1fc12:	9a 94       	dec	r9
   1fc14:	d9 14       	cp	r13, r9
   1fc16:	c0 f3       	brcs	.-16     	; 0x1fc08 <vfprintf+0x370>
   1fc18:	da 94       	dec	r13
   1fc1a:	f1 01       	movw	r30, r2
   1fc1c:	ed 0d       	add	r30, r13
   1fc1e:	f1 1d       	adc	r31, r1
   1fc20:	80 81       	ld	r24, Z
   1fc22:	90 e0       	ldi	r25, 0x00	; 0
   1fc24:	b3 01       	movw	r22, r6
   1fc26:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1fc2a:	dd 20       	and	r13, r13
   1fc2c:	a9 f7       	brne	.-22     	; 0x1fc18 <vfprintf+0x380>
   1fc2e:	06 c0       	rjmp	.+12     	; 0x1fc3c <vfprintf+0x3a4>
   1fc30:	80 e2       	ldi	r24, 0x20	; 32
   1fc32:	90 e0       	ldi	r25, 0x00	; 0
   1fc34:	b3 01       	movw	r22, r6
   1fc36:	0e 94 3f fe 	call	0x1fc7e	; 0x1fc7e <fputc>
   1fc3a:	ea 94       	dec	r14
   1fc3c:	ee 20       	and	r14, r14
   1fc3e:	c1 f7       	brne	.-16     	; 0x1fc30 <vfprintf+0x398>
   1fc40:	43 ce       	rjmp	.-890    	; 0x1f8c8 <vfprintf+0x30>
   1fc42:	f3 01       	movw	r30, r6
   1fc44:	66 81       	ldd	r22, Z+6	; 0x06
   1fc46:	77 81       	ldd	r23, Z+7	; 0x07
   1fc48:	cb 01       	movw	r24, r22
   1fc4a:	2b 96       	adiw	r28, 0x0b	; 11
   1fc4c:	e2 e1       	ldi	r30, 0x12	; 18
   1fc4e:	0c 94 e5 fe 	jmp	0x1fdca	; 0x1fdca <__epilogue_restores__>

0001fc52 <strnlen_P>:
   1fc52:	fc 01       	movw	r30, r24
   1fc54:	05 90       	lpm	r0, Z+
   1fc56:	61 50       	subi	r22, 0x01	; 1
   1fc58:	70 40       	sbci	r23, 0x00	; 0
   1fc5a:	01 10       	cpse	r0, r1
   1fc5c:	d8 f7       	brcc	.-10     	; 0x1fc54 <strnlen_P+0x2>
   1fc5e:	80 95       	com	r24
   1fc60:	90 95       	com	r25
   1fc62:	8e 0f       	add	r24, r30
   1fc64:	9f 1f       	adc	r25, r31
   1fc66:	08 95       	ret

0001fc68 <strnlen>:
   1fc68:	fc 01       	movw	r30, r24
   1fc6a:	61 50       	subi	r22, 0x01	; 1
   1fc6c:	70 40       	sbci	r23, 0x00	; 0
   1fc6e:	01 90       	ld	r0, Z+
   1fc70:	01 10       	cpse	r0, r1
   1fc72:	d8 f7       	brcc	.-10     	; 0x1fc6a <strnlen+0x2>
   1fc74:	80 95       	com	r24
   1fc76:	90 95       	com	r25
   1fc78:	8e 0f       	add	r24, r30
   1fc7a:	9f 1f       	adc	r25, r31
   1fc7c:	08 95       	ret

0001fc7e <fputc>:
   1fc7e:	0f 93       	push	r16
   1fc80:	1f 93       	push	r17
   1fc82:	cf 93       	push	r28
   1fc84:	df 93       	push	r29
   1fc86:	8c 01       	movw	r16, r24
   1fc88:	eb 01       	movw	r28, r22
   1fc8a:	8b 81       	ldd	r24, Y+3	; 0x03
   1fc8c:	81 ff       	sbrs	r24, 1
   1fc8e:	1b c0       	rjmp	.+54     	; 0x1fcc6 <fputc+0x48>
   1fc90:	82 ff       	sbrs	r24, 2
   1fc92:	0d c0       	rjmp	.+26     	; 0x1fcae <fputc+0x30>
   1fc94:	2e 81       	ldd	r18, Y+6	; 0x06
   1fc96:	3f 81       	ldd	r19, Y+7	; 0x07
   1fc98:	8c 81       	ldd	r24, Y+4	; 0x04
   1fc9a:	9d 81       	ldd	r25, Y+5	; 0x05
   1fc9c:	28 17       	cp	r18, r24
   1fc9e:	39 07       	cpc	r19, r25
   1fca0:	64 f4       	brge	.+24     	; 0x1fcba <fputc+0x3c>
   1fca2:	e8 81       	ld	r30, Y
   1fca4:	f9 81       	ldd	r31, Y+1	; 0x01
   1fca6:	01 93       	st	Z+, r16
   1fca8:	f9 83       	std	Y+1, r31	; 0x01
   1fcaa:	e8 83       	st	Y, r30
   1fcac:	06 c0       	rjmp	.+12     	; 0x1fcba <fputc+0x3c>
   1fcae:	e8 85       	ldd	r30, Y+8	; 0x08
   1fcb0:	f9 85       	ldd	r31, Y+9	; 0x09
   1fcb2:	80 2f       	mov	r24, r16
   1fcb4:	09 95       	icall
   1fcb6:	89 2b       	or	r24, r25
   1fcb8:	31 f4       	brne	.+12     	; 0x1fcc6 <fputc+0x48>
   1fcba:	8e 81       	ldd	r24, Y+6	; 0x06
   1fcbc:	9f 81       	ldd	r25, Y+7	; 0x07
   1fcbe:	01 96       	adiw	r24, 0x01	; 1
   1fcc0:	9f 83       	std	Y+7, r25	; 0x07
   1fcc2:	8e 83       	std	Y+6, r24	; 0x06
   1fcc4:	02 c0       	rjmp	.+4      	; 0x1fcca <fputc+0x4c>
   1fcc6:	0f ef       	ldi	r16, 0xFF	; 255
   1fcc8:	1f ef       	ldi	r17, 0xFF	; 255
   1fcca:	c8 01       	movw	r24, r16
   1fccc:	df 91       	pop	r29
   1fcce:	cf 91       	pop	r28
   1fcd0:	1f 91       	pop	r17
   1fcd2:	0f 91       	pop	r16
   1fcd4:	08 95       	ret

0001fcd6 <__ultoa_invert>:
   1fcd6:	fa 01       	movw	r30, r20
   1fcd8:	aa 27       	eor	r26, r26
   1fcda:	28 30       	cpi	r18, 0x08	; 8
   1fcdc:	51 f1       	breq	.+84     	; 0x1fd32 <__ultoa_invert+0x5c>
   1fcde:	20 31       	cpi	r18, 0x10	; 16
   1fce0:	81 f1       	breq	.+96     	; 0x1fd42 <__ultoa_invert+0x6c>
   1fce2:	e8 94       	clt
   1fce4:	6f 93       	push	r22
   1fce6:	6e 7f       	andi	r22, 0xFE	; 254
   1fce8:	6e 5f       	subi	r22, 0xFE	; 254
   1fcea:	7f 4f       	sbci	r23, 0xFF	; 255
   1fcec:	8f 4f       	sbci	r24, 0xFF	; 255
   1fcee:	9f 4f       	sbci	r25, 0xFF	; 255
   1fcf0:	af 4f       	sbci	r26, 0xFF	; 255
   1fcf2:	b1 e0       	ldi	r27, 0x01	; 1
   1fcf4:	3e d0       	rcall	.+124    	; 0x1fd72 <__ultoa_invert+0x9c>
   1fcf6:	b4 e0       	ldi	r27, 0x04	; 4
   1fcf8:	3c d0       	rcall	.+120    	; 0x1fd72 <__ultoa_invert+0x9c>
   1fcfa:	67 0f       	add	r22, r23
   1fcfc:	78 1f       	adc	r23, r24
   1fcfe:	89 1f       	adc	r24, r25
   1fd00:	9a 1f       	adc	r25, r26
   1fd02:	a1 1d       	adc	r26, r1
   1fd04:	68 0f       	add	r22, r24
   1fd06:	79 1f       	adc	r23, r25
   1fd08:	8a 1f       	adc	r24, r26
   1fd0a:	91 1d       	adc	r25, r1
   1fd0c:	a1 1d       	adc	r26, r1
   1fd0e:	6a 0f       	add	r22, r26
   1fd10:	71 1d       	adc	r23, r1
   1fd12:	81 1d       	adc	r24, r1
   1fd14:	91 1d       	adc	r25, r1
   1fd16:	a1 1d       	adc	r26, r1
   1fd18:	20 d0       	rcall	.+64     	; 0x1fd5a <__ultoa_invert+0x84>
   1fd1a:	09 f4       	brne	.+2      	; 0x1fd1e <__ultoa_invert+0x48>
   1fd1c:	68 94       	set
   1fd1e:	3f 91       	pop	r19
   1fd20:	2a e0       	ldi	r18, 0x0A	; 10
   1fd22:	26 9f       	mul	r18, r22
   1fd24:	11 24       	eor	r1, r1
   1fd26:	30 19       	sub	r19, r0
   1fd28:	30 5d       	subi	r19, 0xD0	; 208
   1fd2a:	31 93       	st	Z+, r19
   1fd2c:	de f6       	brtc	.-74     	; 0x1fce4 <__ultoa_invert+0xe>
   1fd2e:	cf 01       	movw	r24, r30
   1fd30:	08 95       	ret
   1fd32:	46 2f       	mov	r20, r22
   1fd34:	47 70       	andi	r20, 0x07	; 7
   1fd36:	40 5d       	subi	r20, 0xD0	; 208
   1fd38:	41 93       	st	Z+, r20
   1fd3a:	b3 e0       	ldi	r27, 0x03	; 3
   1fd3c:	0f d0       	rcall	.+30     	; 0x1fd5c <__ultoa_invert+0x86>
   1fd3e:	c9 f7       	brne	.-14     	; 0x1fd32 <__ultoa_invert+0x5c>
   1fd40:	f6 cf       	rjmp	.-20     	; 0x1fd2e <__ultoa_invert+0x58>
   1fd42:	46 2f       	mov	r20, r22
   1fd44:	4f 70       	andi	r20, 0x0F	; 15
   1fd46:	40 5d       	subi	r20, 0xD0	; 208
   1fd48:	4a 33       	cpi	r20, 0x3A	; 58
   1fd4a:	18 f0       	brcs	.+6      	; 0x1fd52 <__ultoa_invert+0x7c>
   1fd4c:	49 5d       	subi	r20, 0xD9	; 217
   1fd4e:	31 fd       	sbrc	r19, 1
   1fd50:	40 52       	subi	r20, 0x20	; 32
   1fd52:	41 93       	st	Z+, r20
   1fd54:	02 d0       	rcall	.+4      	; 0x1fd5a <__ultoa_invert+0x84>
   1fd56:	a9 f7       	brne	.-22     	; 0x1fd42 <__ultoa_invert+0x6c>
   1fd58:	ea cf       	rjmp	.-44     	; 0x1fd2e <__ultoa_invert+0x58>
   1fd5a:	b4 e0       	ldi	r27, 0x04	; 4
   1fd5c:	a6 95       	lsr	r26
   1fd5e:	97 95       	ror	r25
   1fd60:	87 95       	ror	r24
   1fd62:	77 95       	ror	r23
   1fd64:	67 95       	ror	r22
   1fd66:	ba 95       	dec	r27
   1fd68:	c9 f7       	brne	.-14     	; 0x1fd5c <__ultoa_invert+0x86>
   1fd6a:	00 97       	sbiw	r24, 0x00	; 0
   1fd6c:	61 05       	cpc	r22, r1
   1fd6e:	71 05       	cpc	r23, r1
   1fd70:	08 95       	ret
   1fd72:	9b 01       	movw	r18, r22
   1fd74:	ac 01       	movw	r20, r24
   1fd76:	0a 2e       	mov	r0, r26
   1fd78:	06 94       	lsr	r0
   1fd7a:	57 95       	ror	r21
   1fd7c:	47 95       	ror	r20
   1fd7e:	37 95       	ror	r19
   1fd80:	27 95       	ror	r18
   1fd82:	ba 95       	dec	r27
   1fd84:	c9 f7       	brne	.-14     	; 0x1fd78 <__ultoa_invert+0xa2>
   1fd86:	62 0f       	add	r22, r18
   1fd88:	73 1f       	adc	r23, r19
   1fd8a:	84 1f       	adc	r24, r20
   1fd8c:	95 1f       	adc	r25, r21
   1fd8e:	a0 1d       	adc	r26, r0
   1fd90:	08 95       	ret

0001fd92 <__prologue_saves__>:
   1fd92:	2f 92       	push	r2
   1fd94:	3f 92       	push	r3
   1fd96:	4f 92       	push	r4
   1fd98:	5f 92       	push	r5
   1fd9a:	6f 92       	push	r6
   1fd9c:	7f 92       	push	r7
   1fd9e:	8f 92       	push	r8
   1fda0:	9f 92       	push	r9
   1fda2:	af 92       	push	r10
   1fda4:	bf 92       	push	r11
   1fda6:	cf 92       	push	r12
   1fda8:	df 92       	push	r13
   1fdaa:	ef 92       	push	r14
   1fdac:	ff 92       	push	r15
   1fdae:	0f 93       	push	r16
   1fdb0:	1f 93       	push	r17
   1fdb2:	cf 93       	push	r28
   1fdb4:	df 93       	push	r29
   1fdb6:	cd b7       	in	r28, 0x3d	; 61
   1fdb8:	de b7       	in	r29, 0x3e	; 62
   1fdba:	ca 1b       	sub	r28, r26
   1fdbc:	db 0b       	sbc	r29, r27
   1fdbe:	0f b6       	in	r0, 0x3f	; 63
   1fdc0:	f8 94       	cli
   1fdc2:	de bf       	out	0x3e, r29	; 62
   1fdc4:	0f be       	out	0x3f, r0	; 63
   1fdc6:	cd bf       	out	0x3d, r28	; 61
   1fdc8:	09 94       	ijmp

0001fdca <__epilogue_restores__>:
   1fdca:	2a 88       	ldd	r2, Y+18	; 0x12
   1fdcc:	39 88       	ldd	r3, Y+17	; 0x11
   1fdce:	48 88       	ldd	r4, Y+16	; 0x10
   1fdd0:	5f 84       	ldd	r5, Y+15	; 0x0f
   1fdd2:	6e 84       	ldd	r6, Y+14	; 0x0e
   1fdd4:	7d 84       	ldd	r7, Y+13	; 0x0d
   1fdd6:	8c 84       	ldd	r8, Y+12	; 0x0c
   1fdd8:	9b 84       	ldd	r9, Y+11	; 0x0b
   1fdda:	aa 84       	ldd	r10, Y+10	; 0x0a
   1fddc:	b9 84       	ldd	r11, Y+9	; 0x09
   1fdde:	c8 84       	ldd	r12, Y+8	; 0x08
   1fde0:	df 80       	ldd	r13, Y+7	; 0x07
   1fde2:	ee 80       	ldd	r14, Y+6	; 0x06
   1fde4:	fd 80       	ldd	r15, Y+5	; 0x05
   1fde6:	0c 81       	ldd	r16, Y+4	; 0x04
   1fde8:	1b 81       	ldd	r17, Y+3	; 0x03
   1fdea:	aa 81       	ldd	r26, Y+2	; 0x02
   1fdec:	b9 81       	ldd	r27, Y+1	; 0x01
   1fdee:	ce 0f       	add	r28, r30
   1fdf0:	d1 1d       	adc	r29, r1
   1fdf2:	0f b6       	in	r0, 0x3f	; 63
   1fdf4:	f8 94       	cli
   1fdf6:	de bf       	out	0x3e, r29	; 62
   1fdf8:	0f be       	out	0x3f, r0	; 63
   1fdfa:	cd bf       	out	0x3d, r28	; 61
   1fdfc:	ed 01       	movw	r28, r26
   1fdfe:	08 95       	ret

0001fe00 <_exit>:
   1fe00:	f8 94       	cli

0001fe02 <__stop_program>:
   1fe02:	ff cf       	rjmp	.-2      	; 0x1fe02 <__stop_program>
